definition
module WebDSL-EntityDerive

imports
  WebDSL-Lexical
  WebDSL-Action

exports

  context-free syntax

    Exp "with" ExpEntityDeriveProp* -> TemplateArgExp {cons("ExpEntityDerive"), avoid}
    Id "(" {Exp ","}* ")" -> ExpEntityDeriveProp {cons("ExpEntityDeriveProp")}
    Id UNDEFINED* -> ExpEntityDeriveProp {cons("ExpEntityDeriveProp")}

    Id "with" ArgEntityDeriveProp -> Sort{cons("ArgEntityDerive")}
    Id "(" {ArgEntityDerivePropArg ","}* ")" -> ArgEntityDeriveProp{cons("ArgEntityDeriveProp")}
    Id UNDEFINED* -> ArgEntityDeriveProp{cons("ArgEntityDeriveProp")}
    Id ":" Sort -> ArgEntityDerivePropArg{cons("ArgEntityDerivePropArg")}

    "foreach" Id "{" TemplateElement* "}" -> TemplateElement{cons("ForeachElementEntityDerive")}
    "foreach" Id "{" Statement* "}"       -> Statement{cons("ForeachStatementEntityDerive")}

module WebDSL-Attributes

imports
  WebDSL-Lexical
  WebDSL-Action

exports

  sorts AttributeAssign AttributeSelection
  
context-free syntax

  AttributeCollectionOverride "attributes" Id "{" AttributeElem* "}" -> Definition {cons("AttributeCollection")}
  
  AttributeId "=" Exp -> AttributeElem {cons("AttributeAssign")}
  
  AttributeId "attributes" AttributeIncludeIgnore -> AttributeElem {cons("AttributeInclude")}

  -> AttributeIncludeIgnore{cons("None")}
  "ignore" AttributeId+ -> AttributeIncludeIgnore {cons("AttributeIncludeIgnore")}

  -> AttributeCollectionOverride{cons("None")}
  "override" -> AttributeCollectionOverride {cons("AttributeCollectionOverride")}

  "ignore" AttributeId "attributes" -> AttributeElem {cons("AttributeIgnore")}

context-free syntax
	
  Id -> AttributeId
  "all" -> AttributeId {reject}
  "attributes" -> AttributeId {reject}

context-free syntax

  AttributeId "attributes" -> AttributeSelection {cons("AttributeSelection")}
  "ignore" "default" AttributeId -> AttributeSelection {cons("AttributeIgnoreDefault")}
  
  AttributeSelection -> PropertyAssignment
  AttributeSelection -> Attribute

module WebDSL-Routing

exports

  context-free syntax

    "routing" "{" RoutingElement* "}" -> Definition {cons("Routing")}
    
    "receive" OptRoutingArgs Block -> RoutingElement{cons("RoutingReceive")}
    
    "construct" OptRoutingArgs Block -> RoutingElement{cons("RoutingConstruct")}
    
    "(" {FormalArg ","}* ")" -> OptRoutingArgs {cons("RoutingArgs")}
    -> OptRoutingArgs {cons("None")}

module WebDSL-Prefetch

imports
  WebDSL-Lexical
  WebDSL-Action
  WebDSL-UI

exports

  sorts TemplateElement Statement PrefetchFor PrefetchChildren PrefetchNode PrefetchTemplateArgs PrefetchTemplateArg PrefetchNodeMod PrefetchCondition PrefetchCondVal PrefetchCond PrefetchWhere PrefetchWhereMod

  context-free syntax

    "prefetch-for" PrefetchForVar
                   PrefetchTemplateArgs
                   PrefetchWhere
                   PrefetchChildren                               -> PrefetchFor       {cons("PrefetchFor")}
    "{" PrefetchNode* "}"                                         -> PrefetchChildren  {cons("PrefetchChildren")}
                                                                  -> PrefetchChildrenOpt {cons("None")}
    PrefetchChildren                                              -> PrefetchChildrenOpt
    PrefetchFor                                                   -> TemplateElement
    PrefetchFor                                                   -> Statement

    PrefetchOwnerCast?  %% The SimpleSort to cast to before accessing the property
    Id                  %% The name of the property
    PrefetchNodeMod*
    PrefetchTemplateArgs   %% A list of templates that should have its default implementation (not dynamically redefined)
    PrefetchCondition   %% A condition under which the property is accessed (can only contain simple conditions)
    PrefetchWhere       %% A condition for the elements of a collection
    PrefetchChildrenOpt %% A list of child nodes
                                                                  -> PrefetchNode      {cons("PrefetchNode")}
                                                                  -> PrefetchIfDefault {cons("None")}
    Id                                                            -> PrefetchForVar    {cons("Var")}
    "no-empty-batch"                                              -> PrefetchNodeMod   {cons("NoEmptyBatch")}
    "fetch-early"                                                 -> PrefetchNodeMod   {cons("FetchEarly")}
    Id "(" {SortOrThis ","}* ")"                                  -> TemplateArgOrThis {cons("TemplateArgOrThis")}
    Sort                                                          -> SortOrThis
    PrefetchThis                                                  -> SortOrThis {prefer}
    PrefetchThis "as" Sort                                        -> SortOrThis {cons("PrefetchThisCast")}
    "this"                                                        -> PrefetchThis {cons("PrefetchThis")}
    %%"default" "[" {TemplateArg "," }+ "]"                         -> PrefetchTemplateArgs {cons("PrefetchIfDefault")}
                                                                  -> PrefetchTemplateArgs {cons("None")}
    "templates" "[" {TemplateArgOrThis "," }+ "]"                 -> PrefetchTemplateArgs {cons("PrefetchTemplateArgs")}
                                                                  -> PrefetchCondition {cons("None")}
    "if" "(" PrefetchCondOrTrue ")"                               -> PrefetchCondition {cons("PrefetchCondition")}
                                                                  -> PrefetchWhere     {cons("None")}
    "where" PrefetchWhereMod* "("  PrefetchCondOrTrue ")"         -> PrefetchWhere     {cons("PrefetchWhere")}
    "hint"                                                        -> PrefetchWhereMod  {cons("Hint")}

                                                                  -> NoneCons          {cons("None")}
    SimpleSort "."                                                -> PrefetchOwnerCast {ast("<1>")}

    PrefetchCond                                                  -> PrefetchCondOrTrue
    "true"                                                        -> PrefetchCondVal {cons("True")}

    %% Intentionally matches Exp
    "true"                                                        -> PrefetchCondVal {prefer,cons("True")}
    "false"                                                       -> PrefetchCondVal {prefer,cons("False")}
    "null"                                                        -> PrefetchCondVal {prefer,cons("Null")}
    ConstValue                                                    -> PrefetchCondVal {prefer}
    Id                                                            -> PrefetchCondVal {cons("Var")}
    NoneCons "." Id                                               -> PrefetchCondVal {cons("RelativeFieldAccess")}
    SimpleSort "." Id                                             -> PrefetchCondVal {cons("RelativeFieldAccess")}
    PrefetchCondVal "*" PrefetchCondVal                           -> PrefetchCondVal {cons("Mul"),assoc}
    PrefetchCondVal "/" PrefetchCondVal                           -> PrefetchCondVal {cons("Div"),assoc}
    PrefetchCondVal "%" PrefetchCondVal                           -> PrefetchCondVal {cons("Mod"),assoc}
    PrefetchCondVal "+" PrefetchCondVal                           -> PrefetchCondVal {cons("Add"),assoc}
    PrefetchCondVal "-" PrefetchCondVal                           -> PrefetchCondVal {cons("Sub"),assoc}


    PrefetchCondVal                                               -> PrefetchCond
    PrefetchCondVal "==" PrefetchCondVal                          -> PrefetchCond {cons("Eq")}
    PrefetchCondVal "!=" PrefetchCondVal                          -> PrefetchCond {cons("NotEq")}
    PrefetchCondVal ">"  PrefetchCondVal                          -> PrefetchCond {cons("LargerThan")}
    PrefetchCondVal ">=" PrefetchCondVal                          -> PrefetchCond {cons("LargerThanOrEqual")}
    PrefetchCondVal "<"  PrefetchCondVal                          -> PrefetchCond {cons("SmallerThan")}
    PrefetchCondVal "<=" PrefetchCondVal                          -> PrefetchCond {cons("SmallerThanOrEqual")}

    PrefetchCond "&&" PrefetchCond                                -> PrefetchCond {cons("And"), assoc}
    PrefetchCond "||" PrefetchCond                                -> PrefetchCond {cons("Or"), assoc}
    "!" PrefetchCond                                              -> PrefetchCond {cons("Not")}
    "(" PrefetchCond ")"                                          -> PrefetchCond {bracket}

context-free priorities
  {left:
       PrefetchCondVal "*" PrefetchCondVal -> PrefetchCondVal
       PrefetchCondVal "%" PrefetchCondVal -> PrefetchCondVal
       PrefetchCondVal "/" PrefetchCondVal -> PrefetchCondVal }
  > {left:
       PrefetchCondVal "+" PrefetchCondVal -> PrefetchCondVal
       PrefetchCondVal "-" PrefetchCondVal -> PrefetchCondVal }

context-free priorities
  "!" PrefetchCond -> PrefetchCond
  > {left:
       PrefetchCond "&&" PrefetchCond -> PrefetchCond }
  > {left:
       PrefetchCond "||" PrefetchCond -> PrefetchCond }

module WebDSL-Search

imports
    WebDSL-Lexical

exports
    sorts Definition Annotation Exp

    context-free syntax

    FullTextAnalyzer                                            -> Definition

    DEFAULT? "analyzer" Id "{" FullTextAnalyzerBody "}"         -> FullTextAnalyzer{cons("FullTextAnalyzer")}

    FullTextAnalyzerBodyDef                                     -> FullTextAnalyzerBody

    INDEXORQUERY "{" FullTextAnalyzerBodyDef "}"
    INDEXORQUERY "{" FullTextAnalyzerBodyDef "}"                -> FullTextAnalyzerBody{cons("DualFullTextAnalyzerBodyDef")}
    CharFilter* Tokenizer TokenFilter*                          -> FullTextAnalyzerBodyDef{cons("FullTextAnalyzerBodyDef")}

    "char filter" "=" CHARFILTERNAME "(" {Argument ","}* ")"     -> CharFilter{cons("CharFilter")}
    "char filter" "=" CHARFILTERNAME                             -> CharFilter{cons("CharFilterNoArgs")}

    "tokenizer" "=" TOKENIZERNAME "(" {Argument ","}* ")"       -> Tokenizer{cons("Tokenizer")}
    "tokenizer" "=" TOKENIZERNAME                               -> Tokenizer{cons("TokenizerNoArgs")}

    "token filter" "=" TOKENFILTERNAME "(" {Argument ","}* ")"   -> TokenFilter{cons("TokenFilter")}
    "token filter" "=" TOKENFILTERNAME                           -> TokenFilter{cons("TokenFilterNoArgs")}

    Id "=" String                                               -> Argument{cons("Argument")}

    Id    -> CHARFILTERNAME
    Id    -> TOKENIZERNAME
    Id    -> TOKENFILTERNAME

  context-free syntax

    %%searchable without params is left as SimpleAnno, but desugared to SearchableAnno,
    %%because "searchable" won't get rejected as Id (sdf strangeness).
    "searchable"                               -> SearchableAnno         {cons("SearchableAnno"), prefer}
    "searchable" "(" {SA-Argument ","}* ")"    -> SearchableAnno         {cons("SearchableAnno")}
    "search" "namespace"                       -> SearchNamespaceAnno    {cons("SearchNamespaceAnno"), prefer}
    SearchableAnno    "^" Float                -> Annotation             {cons("SearchableAnnoBoost")}
    SearchableAnno                             -> Annotation
    SearchNamespaceAnno                        -> Annotation

    SA-Key "=" SA-Value                        -> SA-Argument            {cons("SA-Argument")}
    "autocomplete"                             -> SA-Argument            {cons("Autocomplete-Argument")}
    "spellcheck"                               -> SA-Argument            {cons("Spellcheck-Argument")}
    "numeric"                                  -> SA-Argument            {cons("Numeric-Argument")}
    "default"                                  -> SA-Argument            {cons("DefaultSF-Argument")}

  context-free syntax
    SearchMapping                                    -> Definition
    SearchMappingEmbedded                            -> EntityBodyDeclaration
    "search" "mapping" "{" SearchMappingContent* "}"    -> SearchMappingEmbedded  {cons("SearchMappingEmbedded")}
    "search" "mapping" Id "{" SearchMappingContent* "}" -> SearchMapping          {cons("SearchMapping")}

    "namespace" "by" Id                              -> SearchMappingContent      {cons("SearchNamespaceMapping"), prefer}
    "namespace" "by" Id    ";"                       -> SearchMappingContent      {cons("SearchNamespaceMapping")}

    DEFAULTSF? KW MappingPart*    ";"                -> SearchMappingContent      {cons("SearchFieldMapping")}
    DEFAULTSF? "index" Id MappingPart*    ";"        -> SearchMappingContent      {cons("SearchFieldMapping")} %% more natural language
    DEFAULTSF? KW MappingPart*                       -> SearchMappingContent      {cons("SearchFieldMapping")}
    DEFAULTSF? "index" Id MappingPart*               -> SearchMappingContent      {cons("SearchFieldMapping")} %% more natural language

    "as" Id                                          -> MappingPart               {cons("FieldName")}
    "using" Id                                       -> MappingPart               {cons("AnalyzerName")}
    "boosted" "to" Float                             -> MappingPart               {cons("Boost")}
    "for" "subclass" Id                              -> MappingPart               {cons("TargetEntity")}
    "(" {SearchMappingAnnoKW ","}* ")"               -> MappingPart               {cons("SearchMappingAnno")}
    "depth" Int                                      -> MappingPart               {cons("EmbeddedDepth")}
    "with" "depth" Int                               -> MappingPart               {cons("EmbeddedDepth")} %% more natural language
    Boost                                            -> MappingPart

    "^" Float                                        -> Boost                     {cons("Boost")}

    Id           -> KW
    "as"         -> KW {reject}
    "using"      -> KW {reject}
    "boosted"    -> KW {reject}
    "by"         -> KW {reject}
    "with"       -> KW {reject}
    "index"      -> KW {reject}
    "depth"      -> KW {reject}
    "for"        -> KW {reject}

  lexical syntax
    "analyzer"                   -> SA-Key
    "name"                       -> SA-Key
    "boost"                      -> SA-Key
    "subclass"                   -> SA-Key
    "depth"                      -> SA-Key
    "default"                    -> DEFAULT
    "default_builtin_analyzer"   -> DEFAULT
    "+"                          -> DEFAULTSF
    Id                           -> SA-Value
    Float                        -> SA-Value
    Int                          -> SA-Value
    "spellcheck"                 -> SearchMappingAnnoKW
    "autocomplete"               -> SearchMappingAnnoKW
    "index"                      -> INDEXORQUERY
    "query"                      -> INDEXORQUERY

  context-free syntax

    SearcherDef                                      -> Exp

    "search" ENTITY SearcherPart*                    -> SearcherDef         {cons("SearcherInit")}
    "~" Exp SearcherPart+                            -> SearcherDef         {cons("SearcherRefMod")}

    ConstraintFilter    -> SearcherPart
    QueryDef            -> SearcherPart
    Offset              -> SearcherPart
    MaxResults          -> SearcherPart
    SortBy              -> SearcherPart
    FacetDef            -> SearcherPart
    SearchAttributes    -> SearcherPart
    NamespaceConstraint -> SearcherPart

    "matching" MatchGroup+                           -> QueryDef            {cons("QueryDef"),prefer}
    "offset"    Exp                                  -> Offset              {cons("Start")}
    "limit"    Exp                                   -> MaxResults          {cons("MaxResults")}
    "order" "by" {(SortExp) ","}+                    -> SortBy              {cons("SortBy")}
    "with" "filter" {(FilterConstraint) ","}+        -> ConstraintFilter    {cons("ConstraintFilter")}
    "with" "filters" {(FilterConstraint) ","}+       -> ConstraintFilter    {cons("ConstraintFilter")}
    "with" "facet" {FacetExp ","}+                   -> FacetDef            {cons("FacetDef")}
    "with" "facets" {FacetExp ","}+                  -> FacetDef            {cons("FacetDef")}
    "[" {SearchAttribute ","}+ "]"                   -> SearchAttributes    {cons("SearchAttributes")}
    "in" "namespace" Exp                             -> NamespaceConstraint {cons("NamespaceConstraint")}

    "no" "lucene"                                    -> SearchAttribute    {cons("NoLucene")}
    "lucene"                                         -> SearchAttribute    {cons("Lucene")}
    "strict" "matching"                              -> SearchAttribute    {cons("DefaultAnd")}
    "loose" "matching"                               -> SearchAttribute    {cons("DefaultOr")}

    SearchField "(" Exp ")"                          -> FacetExp           {cons("DiscreteFacetDef")}
    SearchField "(" {Range ","}+ ")"                 -> FacetExp           {cons("RangeFacetDef")}

    SearchField ":" Exp                              -> FilterConstraint   {cons("FieldFilterConstraint")}
    %% Exp                                              -> FilterConstraint   {cons("FacetFilterConstraint")}

    {QuerySearchField "," }+ ":"                     -> FieldsConstraint   {cons("FieldsConstraint")}
    SearchField QueryBoost?                          -> QuerySearchField   {cons("QuerySearchField")}
    {QueryExp ","}+                                  -> QueryConstraint    {cons("QueryConstraint"), avoid}
    "^" Exp                                          -> QueryBoost         {cons("QueryBoost")}

    BoolOp? "(" MatchGroup+ ")"                      -> MatchGroup         {cons("Clause"),avoid}
    FieldsConstraint? QueryConstraint                -> MatchGroup         {cons("Query"), avoid}
    "*" ":" "*"                                      -> MatchGroup         {cons("MatchAllQuery")}

    BoolOp? "(" QueryExp+ ")" Slop?                  -> QueryExp           {cons("GroupDef"), prefer}
    BoolOp? QueryTerm Slop?                          -> QueryExp           {cons("TermDef"), avoid}
    BoolOp? Range                                    -> QueryExp           {cons("RangeDef")}
    "~" Exp                                          -> Slop               {cons("Slop")}
    RangeOpen ExpOrWildCard "to"
              ExpOrWildCard RangeClose               -> Range              {cons("Range")}
    RangeOpen ExpOrWildCard "TO"
              ExpOrWildCard RangeClose               -> Range              {cons("Range")}

    Exp                                              -> ExpOrWildCard
    "*"                                              -> ExpOrWildCard      {cons("WildCard")}

    "{"                                              -> RangeOpen          {cons("ExcludingOpen")}
    "}"                                              -> RangeClose         {cons("ExcludingClose")}
    "["                                              -> RangeOpen          {cons("IncludingOpen")}
    "]"                                              -> RangeClose         {cons("IncludingClose")}

    "+"                                              -> BoolOp             {cons("Must")}
    "-"                                              -> BoolOp             {cons("MustNot")}

    Exp                                              -> QueryTerm
    SearcherDef                                      -> QueryTerm          {reject}

    SearchField Direction?                           -> SortExp            {cons("SortDef")}
    "asc"                                            -> Direction          {cons("Ascending")}
    "ascending"                                      -> Direction          {cons("Ascending")}
    "desc"                                           -> Direction          {cons("Descending")}
    "descending"                                     -> Direction          {cons("Descending")}

    "highlight"                                      -> Highlight          {cons("NormalHighlight")}
    "highlightHTML"                                  -> Highlight          {cons("HTMLHighlight")}

    Highlight SearchField ":" Exp "from" Exp         -> RetrievalExp       {cons("Highlight")}
    Highlight SearchField ":" Exp "from" Exp
        "with" "tags" "(" Exp "," Exp ")"            -> RetrievalExp       {cons("HighlightTags"), prefer}
    "results" "from"  Exp                            -> RetrievalExp       {cons("SearchResults")}
    SearchField "facets" "from" Exp                  -> RetrievalExp       {cons("FacetResults")}
    "count" "from" Exp                               -> RetrievalExp       {cons("SearchResultsSize")}
    "searchtime" "from" Exp                          -> RetrievalExp       {cons("SearchTimeString")}
    ENTITY SuggestType SuggestionPart+               -> RetrievalExp       {cons("Suggest")}
    "completions"                                    -> SuggestType        {cons("AutoComplete")}
    "corrections"                                    -> SuggestType        {cons("SpellCheck")}
    RetrievalExp                                     -> Exp

    "~" Exp                                          -> SearchField        {cons("SearchFieldExp")}
    PlainField                                       -> SearchField
    SearchFieldId                                    -> PlainField         {cons("SearchFieldPlain")}
    SearchFieldId "." PlainField                     -> PlainField         {cons("SearchFieldPlain")}


    "similarity" Exp                 -> SuggestionPart {cons("Similarity")}
    "matching" FieldsConstraint Exp  -> SuggestionPart {cons("SuggestTerm")}
    NamespaceConstraint              -> SuggestionPart
    MaxResults                       -> SuggestionPart

    %% disambiguate over Var("") terms allowed by QueryTerm and SearcherPart keywords, dont allow keywords to be used as varref
    SearcherKW             -> QueryTerm {reject}
    SearcherKW "(" Exp ")" -> QueryTerm {reject}
    "[" {Exp ","}* "]"     -> QueryTerm {reject}

  context-free restrictions
    %% Don't treat -200 as 'must not match 200', but as int '-200' instead
    BoolOp  -/- [0-9]
    %% 'matching tags.name: +tag.replace(" ","\\ ")' , interpret as method call, not as field/prop access followed by a new clause
    QueryTerm -/- [\(]

  context-free priorities
    %% search User matching credit: -(-200) //interpret as 'must not match -200'
    Exp -> QueryTerm
    >
    "(" Exp ")"  -> Exp

  context-free priorities
  %% search Movie matching +book.title  //Dont treat '.title' as method-call/property access for whole searcher exp, but restrict to inner exp 'book'.
  %% Movie completions similarity 5 / 11 != null // interpret as (Movie completions similarity 5/11) != (null)
    {QueryExp ","}+ -> QueryConstraint
  > {
      Exp "." Id "(" {Exp ","}* ")"  -> Exp
      Exp "." Id                     -> Exp
    }
  > "!" Exp -> Exp
  > {left:
       Exp "*" Exp -> Exp
       Exp "%" Exp -> Exp
       Exp "/" Exp -> Exp }
  > {left:
       Exp "+" Exp -> Exp
       Exp "-" Exp -> Exp }
  > {
      RetrievalExp -> Exp
      SearcherDef -> Exp
      "similarity" Exp                   -> SuggestionPart
      "matching" FieldsConstraint Exp    -> SuggestionPart
      NamespaceConstraint                -> SuggestionPart
      MaxResults                         -> SuggestionPart
    }
  > Exp "in" Exp -> Exp

  context-free priorities
    %% all category facets from mySearcher == [Facet{}] //interpret as (all category facets from mySearcher) == ([Facet{}])
    {
      Highlight Exp "for" Exp "on" SearchField
          "surround" "with" "(" Exp "," Exp ")"        -> RetrievalExp
      Highlight Exp "for" Exp "on" SearchField         -> RetrievalExp
      "results" "from"  Exp                            -> RetrievalExp
      SearchField "facets" "from" Exp                  -> RetrievalExp
      "count" "from" Exp                               -> RetrievalExp
      "searchtime" "from" Exp                          -> RetrievalExp
    }
  > Exp "in" Exp -> Exp

  context-free priorities
     %% search Movie matching +"hello" -"goodbye" //Dont treat this as sub
    {QueryExp ","}+ -> QueryConstraint
  > {
      Exp "+" Exp -> Exp
      Exp "-" Exp -> Exp
    }

  lexical syntax
    Id             -> SearchFieldId
    "_id"          -> SearchFieldId %%this field is added by hibernate search
    Id             -> ENTITY
    Id             -> SEARCHERREF
    "limit"            -> SearcherKW
    "offset"           -> SearcherKW
    "with"             -> SearcherKW
    "order"            -> SearcherKW
    "in"               -> SearcherKW
    "matching"         -> SearcherKW

 context-free restrictions
    "as" "asc" "ascending" "analyzer" "autocomplete" "boost" "boosted" "by"           -/- [a-zA-Z0-9]
    "desc" "descending" "default" "default_builtin_analyzer" "depth" "extend" "for"   -/- [a-zA-Z0-9]
    "facet" "facets" "from" "get" "highlight" "index" "limit"                         -/- [a-zA-Z0-9]
    "matching" "name" "namespace" "nolucene" "on" "query"                             -/- [a-zA-Z0-9]
    "results" "search" "sort" "spellcheck" "start" "subclass"                         -/- [a-zA-Z0-9]
    "using" "with" "where"                                                            -/- [a-zA-Z0-9]


%% DEPRECATED:
  context-free syntax
    "searchmapping" "{" SearchMappingContent* "}"               -> SearchMappingEmbedded{cons("SearchMappingEmbedded"), deprecated("keyword `searchmapping` is replaced with `search mapping`")}
    "searchmapping" Id "{" SearchMappingContent* "}"            -> SearchMapping{cons("SearchMapping"), deprecated("keyword `searchmapping` is replaced with `search mapping`")}
    "charfilter" "=" CHARFILTERNAME "(" {Argument ","}* ")"     -> CharFilter{cons("CharFilter"), deprecated("keyword `charfilter` is replaced with `char filter`")}
    "charfilter" "=" CHARFILTERNAME                             -> CharFilter{cons("CharFilterNoArgs"), deprecated("keyword `charfilter` is replaced with `char filter`")}
    "tokenfilter" "=" TOKENFILTERNAME "(" {Argument ","}* ")"   -> TokenFilter{cons("TokenFilter"), deprecated("keyword `tokenfilter` is replaced with `token filter`")}
    "tokenfilter" "=" TOKENFILTERNAME                           -> TokenFilter{cons("TokenFilterNoArgs"), deprecated("keyword `tokenfilter` is replaced with `token filter`")}
    "all" SearchField "facets" "from" Exp                       -> RetrievalExp{cons("AllFacetResults"), deprecated("the `all` keyword has been deprecated and has no effect on facet retrieval anymore")}
    "(" SearchField "," Exp ")"                                 -> FacetExp{cons("DiscreteFacetDef"), deprecated("the notation: (field,topN) has been replaced with field(topN) ")}
    "(" SearchField ":" {Range ","}+ ")"                        -> FacetExp{cons("RangeFacetDef"), deprecated("the notation: (field:[min to max], ...) has been replaced with field([min to max], ...) ")}

module WebDSL

imports
  WebDSL-Lexical
  WebDSL-Keywords
  WebDSL-UI
  WebDSL-Ajax
  WebDSL-Action
  WebDSL-DataModel
  WebDSL-DataValidation
  WebDSL-AccessControl
  WebDSL-XML
  WebDSL-JavaScript
  WebDSL-CSS
  WebDSL-Regex
  WebDSL-Enums
  WebDSL-Expand
  WebDSL-Native
  WebDSL-Exception
  WebDSL-Type
  WebDSL-Test
  WebDSL-TimeInterval
  WebDSL-Service
  WebDSL-Search
  WebDSL-Prefetch
  WebDSL-Routing
  WebDSL-Attributes
  WebDSL-EntityDerive

hiddens
  context-free start-symbols
    Unit

exports

  sorts
    Id QId Int ModuleName SectionHeader Float FloatDigits ExponentPart
    SignedInteger String UNDEFINED Eof


  context-free syntax
    Id         -> QId
    QId "." Id -> QId {cons("Qualified")}

  context-free syntax %% Types
    SimpleSort   -> Sort
    GenericSort  -> Sort
    RefSort      -> Sort
    ListSort     -> Sort
    SetSort      -> Sort
    FunctionSort -> Sort

    Id                     -> SimpleSort {cons("SimpleSort")}
    Id "<" {Sort ","}+ ">" -> GenericSort {cons("GenericSort")}
    "Ref" "<" Sort ">"     -> RefSort {cons("RefSort")}
    "ref" Sort             -> RefSort {cons("RefSort")}
    "Ref" "<" Sort ">"     -> GenericSort {reject}

    %% List type '[Type]' and Set type '{Type}' notation
    "[" Sort "]" -> ListSort {ast("GenericSort(\"List\",[<1>])")}
    "{" Sort "}" -> SetSort  {ast("GenericSort(\"Set\",[<1>])")}

    %% function type; optionally specify (named) args and return type
    "function" FunctionSortParams FunctionSortReturn -> FunctionSort {cons("FunctionSort")}
    -> FunctionSortParams {ast("[]")}
    "(" {FunctionSortParam ","}* ")" -> FunctionSortParams {ast("<1>")}
    Sort -> FunctionSortParam {cons("UnnamedArg")}
    Id ":" Sort -> FunctionSortParam {cons("Arg")}
    -> FunctionSortReturn {ast("SimpleSort(\"Void\")")}
    ":" Sort -> FunctionSortReturn {ast("<1>")}
     "function" -> SimpleSort {reject}


    Id ":" Sort            -> FormalArg {cons("Arg")}

exports

  sorts Application Module Unit

  syntax

    "section" <SectionName-CF> <LAYOUT?-CF> <Definition*-CF> -> <Section-CF> {cons("Section")}

  context-free syntax

    "application" QId Definition+ Section* -> Application {cons("ApplicationDefs")}
    "application" QId Section*      -> Application {cons("Application")}

    "description" "{" Word* "}"     -> Description {cons("Description")}

    "note" "{" Word* "}"            -> Description {cons("Note")}

    Description                   -> Definition
    %%Description                   -> Definition {prefer}

    "module" ModuleName Section*  -> Module {cons("Module")}
    "module" ModuleName Definition+ Section*  -> Module {cons("ModuleDefs")}

    "imports" ModuleName          -> Definition {cons("Imports")}

    Application                   -> Unit
    Module                        -> Unit

exports

  sorts Action Statements Statement Exp

  context-free syntax

    Action		       	        -> Definition
    Statement*		   	        -> Statements
    NativeClassDeclaration      -> Definition



module WebDSL-Service

imports
    WebDSL-Lexical
    WebDSL

exports

  context-free syntax

     "service" Modifier* Id "(" {FormalArg ","}* ")" 
        Block                                                                  -> Definition {cons("ServiceFunction")}

	 "derive" "webservices" "for" Id "," "with" "nameproperty" Id			   -> Definition {cons("DeriveWebServices")}
	 
	  SyncConfigEmbedded                            	                       -> EntityBodyDeclaration
	 "synchronization" "configuration" "{" SyncOption* "}"                     -> SyncConfigEmbedded  {cons("SyncConfigEmbedded")}
	 
	 "toplevel" "name" "property" ":" Id			                           -> SyncOption {cons("SyncTopLevelNameProperty")}
	 
	 "restricted" "properties" ":" {Id ","}*			                       -> SyncOption {cons("SyncRestrictedProperties")}
	 
	 "access" "read" ":"  Exp			                       		           -> SyncOption {cons("SyncACRead")}
	 
	 "access" "write" ":"  Exp			                       	               -> SyncOption {cons("SyncACWrite")}
	 
	 "access" "create" ":"  Exp			                       		           -> SyncOption {cons("SyncACCreate")}

module WebDSL-TimeInterval

imports
  WebDSL-Lexical
  WebDSL-Action

exports

  context-free syntax
    Exp "weeks"        -> TimeIntervalPart {cons("Weeks")}
    Exp "days"         -> TimeIntervalPart {cons("Days")}
    Exp "hours"        -> TimeIntervalPart {cons("Hours")}
    Exp "minutes"      -> TimeIntervalPart {cons("Minutes")}
    Exp "seconds"      -> TimeIntervalPart {cons("Seconds")}
    Exp "milliseconds" -> TimeIntervalPart {cons("Milliseconds")}
    "every" TimeIntervalPart*  -> TimeInterval {cons("TimeInterval")}
    
    "on application start"    -> OnAppStart {cons("OnAppStart")}
    "on application stop"  -> OnAppStart {cons("OnAppStop")}

  context-free syntax
    "invoke" Exp TriggerExp -> Definition {cons("InvokeTimedTask")}
    TimeInterval -> TriggerExp
    OnAppStart   -> TriggerExp
    OnAppStop -> TriggerExp


module WebDSL-Test

exports

context-free syntax

  "test" Id Block -> Definition {cons("Test")}
  "test" Block -> Definition {ast("Test(\"\",<1>)")}

module WebDSL-Type

exports

  context-free syntax
  
    %%  Construct for creating custom value types, and altering the existing value types.
    %%
    %%  example: 
    %%    type String { validate(this.length() <= 255 , "input too long (max 255 characters)") }
    %%    type USDate : Date { format = "MM/dd/yyyy" }
    %% 
    %%  Will also need to cope with input/output decode/encode.
    %%

    "type" Id "{" TypeProperty* "}" -> Definition {cons("TypeDef")}
    
    Annotation -> TypeProperty {cons("TypeDefAnno")}
    
    NativeClassFunction -> TypeProperty
    %%solve ambiguities
    "static" -> TypeProperty {reject}
    
    QId "as" NativeClassFunction -> TypeProperty{cons("NativeClassFunctionFromStatic")}

module WebDSL-Exception

exports

  context-free syntax
  
    %%
    %%  Exceptions, for supporting data validation
    %%
    %%  example: 
    %%  entity ValidationException{message:String}
    %%  throw ValidationException{ message := "error" }
    %%  try{}catch(ve : ValidationException){}
    %%  throw ValidationException{ message := "error1" }, ValidationException{ message := "error2" }
    %%  try{}catch(l : List<ValidationException>)

    "throw" {Exp ","}+ ";" -> Statement {cons("ThrowStatement"), prefer}
    "throw" {Exp ","}+     -> TemplateCall {cons("ThrowTemplate"), prefer}
    
    "try" Block Catch+ -> Statement {cons("TryStatement"), prefer}
    "try" Block Catch+ -> TemplateCall {cons("TryTemplate"), prefer}
    
    "catch" "(" Id ":" Sort ")" Block -> Catch {cons("Catch")}

module WebDSL-Native

imports
  WebDSL-Lexical

exports

  sorts Derive DeriveType DeriveProperty

context-free syntax

  "native" "class" QId NativeClassAlias NativeClassSuper "{" NativeClassElement* "}" -> NativeClassDeclaration {cons("NativeClass")}

  "as" Id -> NativeClassAlias{cons("NativeClassAlias"),prefer}
  -> NativeClassAlias{cons("None")}

  ":" Id -> NativeClassSuper{cons("NativeClassSuper"),prefer}
  -> NativeClassSuper{cons("None")}

context-free syntax %%properties

  Id ":" NativeType -> NativeClassElement{cons("NativeClassProperty")}

context-free syntax %%functions

  NativeClassFunction -> NativeClassElement

  NativeClassFunctionStatic NativeFunId "(" {NativeType ","}* ")" NativeClassFunctionReturn -> NativeClassFunction{cons("NativeClassFunction")}
  "constructor" "(" {NativeType ","}* ")" NativeClassFunctionReturn -> NativeClassElement{reject}

  ":" NativeType ->  NativeClassFunctionReturn{cons("NativeClassFunctionReturn"),prefer}
  ->  NativeClassFunctionReturn{cons("None")}

  "static" ->  NativeClassFunctionStatic{cons("NativeClassFunctionStatic"),prefer}
  ->  NativeClassFunctionStatic{cons("None")}

  QId "as" NativeClassFunction -> NativeClassElement{cons("NativeClassFunctionFromStatic")}

  "constructor" "(" {NativeType ","}* ")" -> NativeClassElement{cons("NativeClassConstructor")}
  QId "as" "constructor" "(" {NativeType ","}* ")" -> NativeClassElement{cons("NativeClassConstructorFromStatic")}
  "constructor" -> NativeFunId{reject}

  Id "<" {NativeType ","}* ">" -> NativeType{cons("NativeGenericType")}
  "[" {NativeType ","}* "]" -> NativeType{ast("NativeGenericType(\"List\",<1>)")}
  "{" {NativeType ","}* "}" -> NativeType{ast("NativeGenericType(\"Set\",<1>)")}
  Id -> NativeType{cons("NativeSimpleType")}

  lexical syntax
    Id -> NativeFunId


module WebDSL-Expand

imports
  WebDSL-UI
  WebDSL-Lexical

exports

  sorts Derive DeriveType DeriveProperty

context-free syntax

  "derive" Id "from" Exp "for" "("
    {DeriveProperty ","}*
  ")"                               -> TemplateElement {cons("Derive"), prefer}
  "derive" Id "from" Exp            -> TemplateElement {cons("Derive"), prefer}
  %%"derive" Id                       -> TemplateElement {cons("Derive"), prefer}
  %% Disabled this one for now because it is causing ambiguities, have a look at this Ruben!

  "derive" Id "from" Exp "for" "("
    {DeriveProperty ","}*
  ")" DeriveBody                    -> TemplateElement {cons("Derive"), prefer}
  "derive" Id "from" Exp DeriveBody -> TemplateElement {cons("Derive"), prefer}
  "derive" Id DeriveBody            -> TemplateElement {cons("Derive"), prefer}

  Id                                -> DeriveProperty {cons("DeriveDefault")}
  Id "(" Id ")"                     -> DeriveProperty {cons("DeriveMode")}

  "{" DeriveBodyElement* "}"        -> DeriveBody {cons("DeriveBody")}

  Id "{" TemplateElement* "}"       -> DeriveBodyElement {cons("DeriveBodyElement")}

  "derive"                          -> TemplateCall {reject}

  "derive" "crud" Id -> Definition {cons("DeriveCrud"), prefer}
  "derive" "CRUD" Id -> Definition {cons("DeriveCrud"), prefer}


context-free syntax %% custom expand templates

  "expand" ExpandId+ "to" Id -> Definition {cons("ExpandTemplateCall")}

  "expandtemplate" Id "to" ExpandArgId+ "{" Definition* "}" -> Definition {cons("ExpandTemplateDefinition")}

  "expand" ExpandId+ "to" ExpandArgId+ "{" TemplateElement* "}" -> TemplateElement {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" EntityBodyDeclaration* "}" -> EntityBodyDeclaration {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" Statement* "}" -> Statement {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" ObjectPropertyAssignment* "}" -> ObjectPropertyAssignment {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" Definition* "}" -> Definition {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" Exp "}" -> Exp {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" Attribute "}" -> Attribute {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" PropertyAssignment "}" -> PropertyAssignment {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" FormalArg "}" -> FormalArg {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" Case "}" -> Case {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" TemplateCaseAlt "}" -> TemplateCaseAlt {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" TypeCaseAlt "}" -> TypeCaseAlt {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" TemplateTypeCaseAlt "}" -> TemplateTypeCaseAlt {cons("ExpandLocal"), prefer}

  "expandtemplate" -> ExpandId {reject}
  "template" -> ExpandId {reject}
  "expand" -> ExpandId {reject}
  "to" -> ExpandId {reject}

  "expandtemplate" -> ExpandArgId {reject}
  "template" -> ExpandArgId {reject}
  "expand" -> ExpandArgId {reject}
  "to" -> ExpandArgId {reject}

  lexical syntax
    [a-zA-Z0-9\_\-]+ -> ExpandId
    Id -> ExpandArgId

  lexical restrictions
    ExpandId -/- [a-zA-Z0-9\_\-]

module WebDSL-Enums

imports
  WebDSL-DataModel
  WebDSL-Lexical

exports
  sorts Defintion EnumValue

  context-free syntax

  "enum" Id "{" {EnumValue ","}* "}"                    -> Definition {cons("Enum")}

  Id "(" String ")"                               -> EnumValue {cons("EnumValue")}

module WebDSL-Regex


exports
%%d  context-free start-symbols
%%d    PatternDecl Pattern
  sorts Pattern PatternDecl Exp
  context-free syntax
    RegexExp "." Id "(" {Exp ","}* ")"  -> Exp {cons("Call")} %% always used with a call, regex directly as exp results in ambiguity with xml embedding

    "/" Pattern "/"            -> RegexExp { cons("RegexPattern") }
    Branche                    -> Pattern {cons("SingleBranch")}
    Pattern "|" Pattern        -> Pattern {cons("TupleBranch"), right, prefer}


  sorts Branche
  context-free syntax
    Piece+                     -> Branche {cons("Pieces")}

  sorts Piece
  context-free syntax
    Atom                       -> Piece {cons("SingleAtom")}
    Atom Quantifier            -> Piece {cons("QuantifiedAtom")}

  sorts Quantifier
  context-free syntax
   "{" Integer "}"              -> Quantifier {cons("GreedyExactBound")}
   "{" Integer "," "}"          -> Quantifier {cons("GreedyLowerBound")}
   "{" Integer "," Integer "}"  -> Quantifier {cons("GreedyLowerUpperBound")}
   "?"                          -> Quantifier {cons("GreedyOnceOrNot")}
   "*"                          -> Quantifier {cons("GreedyZeroOrMore")}
   "+"                          -> Quantifier {cons("GreedyOneOrMore")}
   "{" Integer "}?"             -> Quantifier {cons("ReluctantExactBound")}
   "{" Integer "," "}?"         -> Quantifier {cons("ReluctantLowerBound")}
   "{" Integer "," Integer "}?" -> Quantifier {cons("ReluctantLowerUpperBound")}
   "??"                         -> Quantifier {cons("ReluctantOnceOrNot")}
   "*?"                         -> Quantifier {cons("ReluctantZeroOrMore")}
   "+?"                         -> Quantifier {cons("ReluctantOneOrMore")}  
   "{" Integer "}+"             -> Quantifier {cons("PossessiveExactBound")}
   "{" Integer "," "}+"         -> Quantifier {cons("PossessiveLowerBound")}
   "{" Integer "," Integer "}+" -> Quantifier {cons("PossessiveLowerUpperBound")}
   "?+"                         -> Quantifier {cons("PossessiveOnceOrNot")}
   "*+"                         -> Quantifier {cons("PossessiveZeroOrMore")}
   "++"                         -> Quantifier {cons("PossessiveOneOrMore")}   

  sorts Atom
  context-free syntax
    "("   Pattern ")"          -> Atom {cons("Capture")}
    "(?:" Pattern ")"          -> Atom {cons("NonCapture")}
    "(?=" Pattern ")"          -> Atom {cons("PositiveLookahead")}
    "(?!" Pattern ")"          -> Atom {cons("NegativeLookahead")}
    "(?<=" Pattern ")"         -> Atom {cons("PositiveLookbehind")}
    "(?<!" Pattern ")"         -> Atom {cons("NegativeLookbehind")}
    "(?P<" RegexId ">" Pattern ")"  -> Atom {cons("PythonCapture")}
    "(" Pattern ")@{" RegexId "}"   -> Atom {cons("RegexCapture")}
    "()"                       -> Atom {cons("Empty")}
    "."                        -> Atom {cons("SingleCharacter")}
    "^"                        -> Atom {cons("LineStart")}
    "$"                        -> Atom {cons("LineEnd")}
    CharacterClass             -> Atom {cons("CharacterClass")}
    AtomLiteral                -> Atom {cons("AtomLiteral")}
    AtomCharacter              -> Atom {cons("AtomCharacter")}
    "\\Q" AllChars "\\E"       -> Atom {cons("QuotedAtom")}    
    
  sorts CharacterClass BracketItem
  context-free syntax
    "[" BracketItem+ "]"       -> CharacterClass {cons("BracketList")}
    "[^" BracketItem+ "]"      -> CharacterClass {cons("NegatedBracketList")}
%%d "\\p\{" ClassKeyword "\}"   -> CharacterClass {cons("PredefineClass")}
%%d "\\P\{" ClassKeyword "\}"   -> CharacterClass {cons("NegatedPredefineClass")}
   

    (BracketLiteral | BracketCharacter)
     "-" 
    (BracketLiteral | BracketCharacter)   -> BracketItem {cons("Range")}
    CharacterClass                        -> BracketItem {cons("Union")}
%%d "\&\&" CharacterClass                 -> BracketItem {cons("Intersection")}
    BracketLiteral                        -> BracketItem {cons("BracketLiteral")}
    BracketCharacter                      -> BracketItem {cons("BracketCharacter")}
   

%%
 %%   Defining characterclasses
  %% 
sorts ClassKeyword
  context-free syntax    
    "Lower"                    -> ClassKeyword {cons("LowerClass")}
    "Upper"                    -> ClassKeyword {cons("UpperClass")}
    "ASCII"                    -> ClassKeyword {cons("ASCIIClass")}
    "Alpha"                    -> ClassKeyword {cons("AlphaClass")}
    "Digit"                    -> ClassKeyword {cons("DigitClass")}
    "Alnum"                    -> ClassKeyword {cons("AlnumClass")}
    "Punct"                    -> ClassKeyword {cons("PunctClass")}
    "Graph"                    -> ClassKeyword {cons("GraphClass")}
    "Print"                    -> ClassKeyword {cons("PrintClass")}
    "Blank"                    -> ClassKeyword {cons("BlankClass")}
    "Cntrl"                    -> ClassKeyword {cons("CntrlClass")}
    "XDigit"                   -> ClassKeyword {cons("XDigitClass")}
    "Space"                    -> ClassKeyword {cons("WhiteSpace")}
    "javaLowerCase"            -> ClassKeyword {cons("JavaIsLowerCase")}
    "javaUpperCase"            -> ClassKeyword {cons("JavaIsLowerCase")}
    "javaWhitespace"           -> ClassKeyword {cons("JavaIsWhitespace")}
    "javaMirrored"             -> ClassKeyword {cons("JavaIsMirrored")}
    "InGreek"                  -> ClassKeyword {cons("GreekBlock")}
    "Lu"                       -> ClassKeyword {cons("UppercaseLetter")}
    "Sc"                       -> ClassKeyword {cons("CurrencySymbol")}

%%
 %%   Defining the Character -> Characters that appear as Atom and in Brackets  
  %%   

%%  ASCII characters:  
%%  $*+?.{}()                             %% OnlyBranchSpecial
%%  &]-                                   %% OnlyClassSpecial
%%  [^\                                   %% AlwaysSpecial
%%  !"#%',/:;<=>@_`~                      %% NeverSpecialCharacter
%%  ABCDEFGHIJKLMNOPQRSTUVWXYZ            %% Character
%%  abcdefghijklmnopqrstuvwxyz            %% Charater
%%  0123456789                            %% Charater
%%  <tab> <newline> <return> <form-feed>  %% SpecialEscapeCharacter


  sorts BracketLiteral AtomLiteral AllChars
  lexical syntax
    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\$\*\+\?\.\}\|]
                                                  -> BracketLiteral
    "/"                                           -> BracketLiteral 
    [\&\]\-]                                      -> BracketLiteral {reject}
    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\&\]\-]
                                                  -> AtomLiteral
    "/"                                           -> AtomLiteral
    [\}\)\|\[]                                    -> AtomLiteral {reject}
    
    [\\\|\$\*\+\?\.\{\}\(\)\&\]\-\[\^\!\#\%\'\,\:\;\<\=\>\@\_\`\~a-zA-Z0-9\t\n\r]*              
          -> AllChars
    "/"   -> AllChars
    "\""  -> AllChars {cons("DoubleQuote") }
    
   lexical restrictions                                                 
   AtomLiteral -/- [\n]
     
  sorts BracketCharacter AtomCharacter
  context-free syntax
%%d    "\{"                -> BracketCharacter {cons("CurlyBraceOpen") }
%%d    "\{"                -> AtomCharacter    {cons("CurlyBraceOpen"), avoid}
    "\""                -> BracketCharacter {cons("DoubleQuote") }
    "\""                -> AtomCharacter    {cons("DoubleQuote") }
%%d    "\)"                -> BracketCharacter {cons("BraceClose"), avoid }
%%d    "\)"                -> AtomCharacter    {cons("BraceClose") }


%%
 %%   Escaping with a '\' to express a special character
  %%
  context-free syntax
    "\\0" OctalValue       -> BracketCharacter {cons("OctalChar")}
    "\\x" TwoHexValue      -> BracketCharacter {cons("HexHexChar")}
    "\\u" FourHexValue     -> BracketCharacter {cons("DecHexChar")}
    "\\t"                  -> BracketCharacter {cons("Tab")}
    "\\n"                  -> BracketCharacter {cons("Newline")}
    "\\r"                  -> BracketCharacter {cons("Return")}
    "\\f"                  -> BracketCharacter {cons("Formfeed")}
    "\\a"                  -> BracketCharacter {cons("Alarm")}
    "\\e"                  -> BracketCharacter {cons("Escape")}
    "\\w"                  -> BracketCharacter {cons("WordChar")}
    "\\W"                  -> BracketCharacter {cons("NonWordChar")}
    "\\s"                  -> BracketCharacter {cons("WhiteSpaceChar")}
    "\\S"                  -> BracketCharacter {cons("NonWhiteSpaceChar")}
    "\\d"                  -> BracketCharacter {cons("DigitChar")}
    "\\D"                  -> BracketCharacter {cons("NonDigitChar")}
    "\\c" ControlValue     -> BracketCharacter {cons("ControlCharacter")}
    "\\b"                  -> BracketCharacter {cons("WordBoundry")}
    "\\B"                  -> BracketCharacter {cons("NonWordBoundry")}
    "\\A"                  -> BracketCharacter {cons("InputBeginBoundry")}
    "\\G"                  -> BracketCharacter {cons("PrevMatchEndBoundry")}
    "\\Z"                  -> BracketCharacter {cons("EndInputBoundry")}
    "\\z"                  -> BracketCharacter {cons("EndInputFinalBoundry")}
    "\\" BackReference     -> BracketCharacter {cons("BackReference")}
    "\\ "                  -> BracketCharacter {cons("Space")}
    "\\\t"                 -> BracketCharacter {cons("Tab")}
%%d    "\\\r"                 -> BracketCharacter {cons("Return")}
    "\\\n"                 -> BracketCharacter {cons("Newline")}
    
    "\\0" OctalValue       -> AtomCharacter {cons("OctalChar")}
    "\\x" TwoHexValue      -> AtomCharacter {cons("HexHexChar")}
    "\\u" FourHexValue     -> AtomCharacter {cons("DecHexChar")}
    "\\t"                  -> AtomCharacter {cons("Tab")}
    "\\n"                  -> AtomCharacter {cons("Newline")}
    "\\r"                  -> AtomCharacter {cons("Return")}
    "\\f"                  -> AtomCharacter {cons("Formfeed")}
    "\\a"                  -> AtomCharacter {cons("Alarm")}
    "\\e"                  -> AtomCharacter {cons("Escape")}
    "\\w"                  -> AtomCharacter {cons("WordChar")}
    "\\W"                  -> AtomCharacter {cons("NonWordChar")}
    "\\s"                  -> AtomCharacter {cons("WhiteSpaceChar")}
    "\\S"                  -> AtomCharacter {cons("NonWhiteSpaceChar")}
    "\\d"                  -> AtomCharacter {cons("DigitChar")}
    "\\D"                  -> AtomCharacter {cons("NonDigitChar")}
    "\\c" ControlValue     -> AtomCharacter {cons("ControlCharacter")}
    "\\b"                  -> AtomCharacter {cons("WordBoundry")}
    "\\B"                  -> AtomCharacter {cons("NonWordBoundry")}
    "\\A"                  -> AtomCharacter {cons("InputBeginBoundry")}
    "\\G"                  -> AtomCharacter {cons("PrevMatchEndBoundry")}
    "\\Z"                  -> AtomCharacter {cons("EndInputBoundry")}
    "\\z"                  -> AtomCharacter {cons("EndInputFinalBoundry")}
    "\\" BackReference     -> AtomCharacter {cons("BackReference")}
    "\\ "                  -> AtomCharacter {cons("Space")}
    "\\\t"                 -> AtomCharacter {cons("Tab")}
%%d    "\\\r"                 -> AtomCharacter {cons("Return")}
    "\\\n"                 -> AtomCharacter {cons("Newline")}
    
%%
 %%   Quoting of symbols is always allowed to express that symbol
  %%
  sorts QuotablePatternSymbol
  context-free syntax
    "\\" QuotablePatternSymbol            -> AtomCharacter {cons("Quoted")}
    "\\" QuotablePatternSymbol            -> BracketCharacter {cons("Quoted")}    
  lexical syntax
    [\|\$\*\+\?\.\{\}\(\)\&\]\[\-\^\\\!\#\%\'\,\:\;\<\=\>\@\_\`\~\/]
                                   -> QuotablePatternSymbol
  context-free syntax
    "\""                -> QuotablePatternSymbol {cons("DoubleQuote") }
    "\""                -> QuotablePatternSymbol {cons("DoubleQuote") }    
%%
 %%   Defining integers and number values
  %% 
  sorts Integer OctalValue TwoHexValue FourHexValue BackReference ControlValue
  lexical syntax      
    [0-9]+                                       -> Integer
    [1-9] [0-9]*                                 -> BackReference
    [0-7]                                        -> OctalValue
    [0-7][0-7]                                   -> OctalValue
    [0-3][0-7][0-7]                              -> OctalValue
    [0-9A-Fa-f][0-9A-Fa-f]                       -> TwoHexValue
    [0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f] -> FourHexValue
    [0-9]                                        -> ControlValue
    [0-9][0-9]                                   -> ControlValue

%%d  lexical restrictions
%%d    "/"  -/- [\]]
%%d    "\\" -/- [\ \t\12\n\r]   
    
    
exports
  sorts
    RegexId
    RegexID

  context-free syntax
    RegexID -> RegexId {cons("RegexId")}

  lexical syntax
    [A-Za-z\_\$][A-Za-z0-9\_\$]* -> RegexID
    
    "true"  -> RegexID {reject}
    "false" -> RegexID {reject}
    "null"  -> RegexID {reject}

  lexical restrictions
    RegexID -/- [a-zA-Z0-9\_\$]

module WebDSL-CSS

exports
  sorts TemplateElement
  context-free syntax
    "<" "style" Attribute* ">"
    JSParts
    "</" "style" ">"
    -> TemplateElement { cons("StyleElement"), prefer}

module WebDSL-JavaScript
  
exports 
  sorts TemplateElement
  context-free syntax
    "<" "script" Attribute* ">" 
    %%todo: should be javascript embedding
    JSParts
    "</" "script" ">"
    -> TemplateElement { cons("JSElement"), prefer}

  syntax  %% in kernel syntax to preserve spaces after ~exp, e.g. in a jquery selector $('~id span')
    JSPart*        -> <JSParts-CF>

	"~" <Exp-CF>   -> JSPart{cons("JSExp"), prefer}
	<JSString-LEX> -> JSPart{cons("JSString")}
    "\\~"          -> JSPart{cons("JSTilde"), prefer}

  sorts JSChar JSString
  lexical syntax
    JSChar+     -> JSString
    ~[\<\~]     -> JSChar
    SmallerThan -> JSChar
    [\<]        -> SmallerThan
 
    %% otherwise a '<' can split the JSString causing ambiguity, because '<' is allowed in follow restriction below for ending JSString with </script>
    [\<] JSChar* -> JSString{reject}

  lexical restrictions
    SmallerThan -/- [\/]
    JSString    -/- ~[\<\~]

module WebDSL-XML

exports
  context-free syntax

    "<" QualName Attribute* "/>" -> TemplateElement {cons("XMLEmptyElement")}

    "<" QualName Attribute* ">"
      TemplateElement*
    "</" QualName ">" -> TemplateElement {cons("XMLElement")}

  %% http://www.w3.org/html/wg/drafts/html/master/single-page.html#void-elements
  context-free syntax
    "<" HTML5VoidElement Attribute* ">" -> TemplateElement {cons("XMLEmptyElementUnclosed")}
  lexical syntax
    "area" -> HTML5VoidElement
    "base" -> HTML5VoidElement
    "br" -> HTML5VoidElement
    "col" -> HTML5VoidElement
    "embed" -> HTML5VoidElement
    "hr" -> HTML5VoidElement
    "img" -> HTML5VoidElement
    "input" -> HTML5VoidElement
    "keygen" -> HTML5VoidElement
    "link" -> HTML5VoidElement
    "menuitem" -> HTML5VoidElement
    "meta" -> HTML5VoidElement
    "param" -> HTML5VoidElement
    "source" -> HTML5VoidElement
    "track" -> HTML5VoidElement
    "wbr" -> HTML5VoidElement

  %% <!-- --> comments
  context-free syntax
    XMLComment -> TemplateElement {cons("XMLComment")}
  lexical syntax
    "<!--" XMLCommentChar* "-->" -> XMLComment
    ~[\-]                        -> XMLCommentChar
    OneDash                      -> XMLCommentChar
    TwoDashes                    -> XMLCommentChar
    [\-]                         -> OneDash
    [\-][\-]                     -> TwoDashes
  lexical restrictions
    OneDash   -/- [\-]
    TwoDashes -/- [\>]

  context-free syntax %% if(){} and if(){}else{} inside an XML element containing a list of attributes

    "if" "(" Exp ")" "{" Attribute* "}"		          -> Attribute {cons("XMLAttributesIf")}
    "if" "(" Exp ")" "{" Attribute* "}" "else" "{" Attribute* "}" -> Attribute {cons("XMLAttributesIfElse")}

  context-free syntax

    QualName "=" Exp -> Attribute {cons("Attribute")}

    %%easy injection of attributes from template call
    CommonAttribute -> Attribute
    "all attributes"  -> CommonAttribute {cons("AllAttributes")}
    "all attributes except" Exp        -> CommonAttribute {cons("AllAttributeExceptExp")}
    "attributes" Exp        -> CommonAttribute {cons("AttributesExp")}

    "attributes" -> KEYWORD

exports

  lexical syntax
    Qualifier? NCName -> QualName
    NCName ":"        -> Qualifier


    [A-Za-z\_] [A-Za-z0-9\.\-\_]* -> NCName

  lexical restrictions
    NCName -/- [A-Za-z0-9\.\-\_]

module WebDSL-AccessControl

imports
  WebDSL-UI
  WebDSL-Action
  WebDSL-DataModel
  WebDSL-Lexical

%% syntax for access control  
exports

  sorts MatchId

  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_\-]*[\*]? -> MatchId
    [\*]                          -> MatchId
    [\*]                          -> WildCardArg 

context-free syntax

  "access" "control" "rules" Id? AccessControlDefinition*  -> Section {cons("AccessControlDefinition")}
  %%deprecated: 
  "access" "control" "rules" "{" Id? AccessControlDefinition* "}"  -> Section {cons("AccessControlDefinition")}
  
  "principal" "is" Id "with" "credentials" {Id ","}+            -> Definition {cons("AccessControlPrincipal")} 
  "principal" "is" Id "with" "credentials" {Id ","}+            -> AccessControlDefinition {cons("AccessControlPrincipal")} 
  
  AccessControlRule                                             -> AccessControlDefinition
 
  "rule" Id MatchId OptMatchArgs
  "{" AccessControlCheck AccessControlRule* "}"                 -> AccessControlRule {cons("AccessControlRule")}

  "(" MatchArgs ")"             -> OptMatchArgs {ast("<1>")}
                                -> OptMatchArgs {ast("MatchArgs([],None())")}
  {FormalArg ","}* WildCardArg? -> MatchArgs {cons("MatchArgs"),prefer}
  {Exp ","}* WildCardArg?       -> MatchArgs {cons("MatchArgs")}

  Exp                                                           -> AccessControlCheck
  
  %% special rules, e.g. to protect ?logsql
  "rule" Id "{" AccessControlCheck "}"                 -> AccessControlRule {cons("SpecialAccessControlRule")}  
  
  %% pagecheck
  %%"pagecheck" "<" Id "," Exp ">"  -> TemplateElement {cons("PageCheck"),prefer}
  %%"pagecheck" "(" Id "," Exp ")"  -> TemplateCall {reject}
  %%"pagecheck" "(" {Exp ","}* ")"                          -> TemplateCall {reject}
  
  "predicate" Id OptFormalArgs "{" Exp "}" -> Definition {cons("Predicate")}
  "predicate" Id OptFormalArgs "{" Exp "}" -> AccessControlDefinition {cons("Predicate")}
  "predicate" Id OptFormalArgs "{" Exp "}" -> EntityBodyDeclaration {cons("PredicateInEntity")}
  
  Id MatchId "(" {Id ","}* WildCardArg? ")"                     -> AccessControlPointcutElement {cons("AccessControlPointcutElement")}
  
  "pointcut" Id "(" {FormalArg ","}* ")"
    "{" {AccessControlPointcutElement ","}* "}"                 -> AccessControlPointcut {cons("AccessControlPointcut")}
  
  AccessControlPointcut                                         -> AccessControlDefinition
  
  %%construct to import checks of another page or template, necessary for easily applying ac rules to lifted templates
  "apply ac rules" Id "(" {AccessControlImportRulesArg ","}* ")" -> TemplateElement {cons("AccessControlImportRules"), prefer}
  Id -> AccessControlImportRulesArg {cons("Var")} %%only vars supported, enough for current usage, see languages/access-control/access-control.str
  
context-free syntax  
  
  "access" "control" "policy" PolicyExp                         -> Section {cons("ACPolicy")}
  
  Id                                 -> PolicyExp {cons("Name")}
  "(" PolicyExp ")"                  -> PolicyExp {bracket}
  PolicyExp "AND" PolicyExp          -> PolicyExp {cons("PolicyAnd"), assoc}
  PolicyExp "OR" PolicyExp           -> PolicyExp {cons("PolicyOr"), assoc}
  
  
  %% hack for allowing multiple function checks to be added in different stages to a function call
  %%"acfunctioncheck" "(" Id "," Exp ")" Exp -> Exp {cons("ACFunctionCheck"), prefer}
  
context-free priorities
  {left:
       PolicyExp "AND" PolicyExp -> PolicyExp}
  > {left:
       PolicyExp "OR" PolicyExp -> PolicyExp}

context-free priorities
    Exp "in" Exp  -> Exp
  > Exp -> AccessControlCheck

context-free syntax
  
  "ignore-access-control" -> Modifier {cons("IgnoreAccessControl")}

module WebDSL-DataValidation

exports

  context-free syntax

    "validatecreate" "(" Exp "," Exp ")" -> Annotation {cons("ValidateCreateAnno"),prefer}
    "validateupdate" "(" Exp "," Exp ")" -> Annotation {cons("ValidateUpdateAnno"),prefer}
    "validatedelete" "(" Exp "," Exp ")" -> Annotation {cons("ValidateDeleteAnno"),prefer}
    "validate" "(" Exp "," Exp ")" -> Annotation {cons("ValidateAnno"),prefer}
    Id ":" "validate" "(" Exp "," Exp ")" -> Annotation {cons("NamedValidateAnno"),prefer}
    
    ValidateEntity -> EntityBodyDeclaration
    "validate" "(" Exp "," Exp ")" -> ValidateEntity {cons("ValidateEntity"),prefer}
    
    "validate" "(" Exp "," Exp ")" ";" -> Statement {cons("ValidateStatement"),prefer}
    Id ":" "validate" "(" Exp "," Exp ")" ";" -> Statement {cons("NamedValidateStatement"),prefer}
    
    "validationErrors" "(" Id ")" -> TemplateCall {cons("ValidationErrors"),prefer}
    "validationErrors" "(" ")" -> TemplateCall {cons("ValidationErrors"),prefer}

module WebDSL-DataModel

imports
  WebDSL-Action
  WebDSL-Lexical

exports

  context-free syntax

    "globals" "{" GlobalsDef* "}"                        -> Definition {prefer,cons("GlobalsDefinition"),deprecated("'globals{ }' block is no longer necessary around global variables and functions")}

    "entity" Id ":" Id "{" EntityBodyDeclaration* "}"       -> Entity {cons("Entity")}
    "entity" Id "{" EntityBodyDeclaration* "}"              -> Entity {cons("EntityNoSuper")}
    "session" Id "{" EntityBodyDeclaration* "}"             -> Entity {cons("SessionEntity")}
    Property -> EntityBodyDeclaration
    Function -> EntityBodyDeclaration
    StaticEntityFunction -> EntityBodyDeclaration
    "cache" -> EntityBodyDeclaration {cons("CachedEntity")}

    Entity                                   		     -> Definition

    "extend" "entity" Id "{" EntityBodyDeclaration* "}"	 -> Definition {cons("ExtendEntity")}
    "extend" "session" Id "{" EntityBodyDeclaration* "}"   -> Definition {cons("ExtendSessionEntity")}

  context-free restrictions
    "cache" -/- [a-zA-Z0-9\_] %% prevent ambiguity between CachedEntity and a property id beginning with cache

exports

  sorts Entity Property Sort Annotation

  context-free syntax

    "var" Id ":" Sort 	       -> GlobalVarDecl {cons("GlobalVarDecl")} %% not allowed, global vars need an initializer, still parsed to give clear error message from analysis
    "var" Id ":" Sort ":=" Exp -> GlobalVarDecl {cons("GlobalVarDeclInit")}
    "var" Id ":=" Exp          -> GlobalVarDecl {cons("GlobalVarDeclInitInferred")}
    "var" Id ":" Sort ";" 	       -> GlobalVarDecl {cons("GlobalVarDecl"),deprecated("remove ';' from global variable declaration")}
    "var" Id ":" Sort ":=" Exp ";" -> GlobalVarDecl {cons("GlobalVarDeclInit"),deprecated("remove ';' from global variable declaration")}
    "var" Id ":=" Exp ";"          -> GlobalVarDecl {cons("GlobalVarDeclInitInferred"),deprecated("remove ';' from global variable declaration")}

    "request" GlobalVarDecl    -> Definition {cons("RequestScope")}
    GlobalVarDecl              -> GlobalsDef
    Function                   -> GlobalsDef
    GlobalsDef                 -> Definition
    InitAction                 -> Definition

exports

  sorts Property Annotation

  context-free syntax

    Id PropKind Sort OptPropAnnos          -> Property {cons("Property")}
    Id PropKind Sort OptPropAnnos ":=" Exp -> Property {cons("DerivedProperty")}

    "(" {Annotation ","}* ")" -> OptPropAnnos {ast("<1>")}
                              -> OptPropAnnos {ast("[]")}

    "::" -> PropKind {cons("Simple")}
    "->" -> PropKind {cons("Ref")}
    "<>" -> PropKind {cons("Comp")}
    ":"  -> PropKind {cons("AnyProp")}

  sorts Sort

  context-free syntax

%% explicit syntax makes the annotations highlighted as keyword in the editor
%% removed generic SingleParamAnno due to http://yellowgrass.org/issue/StrategoXT/825

    Id                           -> Annotation {cons("SimpleAnno")}
    "inverse" "=" Id "." Id      -> Annotation {cons("InverseAnno")}
    %%fallback for code completion:
    "inverse" "=" Id             -> Annotation {cons("IncompleteInverseAnno")}
    "inverseSlave" "=" Id "." Id -> Annotation {cons("InverseSlaveAnno")}
    "inverse-reference-only"      -> Annotation {cons("InverseReferenceOnlyAnno")} %% only allowed on Set property with inverse
    "inline" "(" {Id ","}* ")"   -> Annotation {cons("InlineAnno")}
    "select" "=" Id              -> Annotation {cons("SelectAnno")}
    "not null"                   -> Annotation {cons("NotNullAnno")}
    "not empty"                  -> Annotation {cons("NotEmptyAnno")}
    "allowed" "=" Exp            -> Annotation {cons("AllowedAnno")}
    "default" "=" Exp            -> Annotation {cons("DefaultAnno")}
    "length" "=" Int             -> Annotation {cons("LengthAnno")}
    "format" "=" String          -> Annotation {cons("FormatAnno")}
    "index" "(" ")"              -> Annotation {cons("IndexAnno")}
    "index" "(" Int ")"          -> Annotation {cons("IndexAnno")}
    "collation" "(" Id ")"       -> Annotation {cons("CollationAnno")}
    "iderror" "=" String         -> Annotation {cons("IdErrorAnno")}
    "idemptyerror" "=" String    -> Annotation {cons("IdEmptyErrorAnno")}

module HQL

hiddens
  context-free start-symbols QueryRule Statement
  
exports
  lexical syntax
    [a-zA-Z\_][a-zA-Z0-9\_]* -> Identifier
  lexical restrictions
    Identifier -/- [a-zA-Z0-9\_]
    "from" -/- [a-zA-Z0-9\_]
    "select" -/- [a-zA-Z0-9\_]
    
  context-free syntax
   
    "from" | "select" | "by" | "order" -> Identifier {reject}
    
exports

  sorts Statement UpdateStatement DeleteStatement SelectStatement InsertStatement
  
  context-free syntax

    "delete" FromClause WhereClause? -> DeleteStatement {cons("DeleteStatement")}
    
    SelectStatement -> Statement

    QueryRule -> SelectStatement

    QueryRule "union" QueryRule -> Union {cons("QueryUnion")}

    SelectFrom WhereClause? GroupByClause? OrderByClause? -> QueryRule {cons("QueryRule")}
    
    SelectClause? FromClause -> SelectFrom {cons("SelectFrom")}
    
    "select" Distinct? Selection -> SelectClause {cons("Select")}

    "distinct"                   -> Distinct {cons("Distinct")}
    
    SelectedPropertiesList -> Selection
    NewExpression          -> Selection
    SelectObject           -> Selection

    QueryRule              -> Expression {avoid}
    
  "new" Path "(" SelectedPropertiesList ")" -> NewExpression {cons("NewExpression")}
  
  "object" "(" Identifier ")" -> SelectObject {cons("SelectObject")}
  
    "from" {FromRangeJoin ","}+ -> FromClause {cons("FromClause")}
    
    FromRange FromJoin* -> FromRangeJoin {cons("FromRangeJoin")}
    
    "left"          -> JoinType {cons("LeftJoin")}
    "right"         -> JoinType {cons("RightJoin")}
    "left"  "outer" -> JoinType {cons("LeftOuterJoin")}
    "right" "outer" -> JoinType {cons("RightOuterJoin")}
    "full"          -> JoinType {cons("FullJoin")}
    "inner"         -> JoinType {cons("InnerJoin")}
    
    JoinType? "join" Fetch? Path AsAlias? PropertyFetch? WithClause? -> FromJoin {cons("FromJoin")}
    
    "fetch" -> Fetch {cons("Fetch")}
        
  "with" Expression -> WithClause {cons("WithClause")}
  
    FromClassOrOuterQueryPath       -> FromRange
    InClassDeclaration              -> FromRange
    InCollectionDeclaration         -> FromRange
    InCollectionElementsDeclaration -> FromRange
    
    Path AsAlias? PropertyFetch? -> FromClassOrOuterQueryPath {cons("FromClass")}
    
    Alias "in" "class" Path -> InClassDeclaration {cons("InClassDeclaration")}
    
    "in" "(" Path ")" Alias -> InCollectionDeclaration {cons("InCollection")}
    
    Alias "in" "elements" "(" Path ")" -> InCollectionElementsDeclaration {cons("InCollectionElements")}

    "as" Alias -> AsAlias {cons("AsAlias")}
  
    Identifier -> Alias {cons("Alias")}
  
  
    "fetch" "all" "properties" -> PropertyFetch {cons("PropertyFetch")}
    
    "group" "by" {Expression ","}+ HavingClause? -> GroupByClause {cons("GroupBy")}
    
    "order" "by" {OrderElement ","}+ -> OrderByClause {cons("OrderByClause")}
    
    Expression AscendingOrDescending? -> OrderElement {cons("OrderElement")}
    
   "asc"       -> AscendingOrDescending {cons("Ascending")}
   "ascending" -> AscendingOrDescending {cons("Ascending")}
   
   "desc"      -> AscendingOrDescending {cons("Descending")}
   "descending" -> AscendingOrDescending {cons("Descending")}
   
    "having" Expression -> HavingClause {cons("HavingClause")}
    
    "where" Expression -> WhereClause {cons("WhereClause")}
    
    { AliasedExpression ","}+ -> SelectedPropertiesList {cons("SelectedPropertiesList")}
    
    %%QuotedAliasedExpression -> OptionallyQuotedAliasedExpression
    %%AliasedExpression       -> OptionallyQuotedAliasedExpression
    
    "'" Expression AsAlias? "'" -> QuotedAliasedExpression {cons("QuotedAliasedExpression")}
    Expression AsAlias? -> AliasedExpression {cons("AliasedExpression")}
    
   Expression "or" Expression -> Expression {cons("QueryOr")}
   
    Expression "and" Expression -> Expression {cons("QueryAnd")}
    
    "not" Expression -> Expression {cons("QueryNot")}
    
    Expression "=" Expression -> Expression {cons("EQ")}
    Expression "is" Expression -> Expression {cons("IS")}
    Expression "!=" Expression -> Expression {cons("NE")}
    Expression "<>" Expression -> Expression {cons("SQLNE")}
    Expression "like" Expression -> Expression {cons("LIKE")}
    Expression "not" "like" Expression -> Expression {cons("NOTLIKE")}

    Expression "<" Expression -> Expression {cons("LT")}
    Expression "<=" Expression -> Expression {cons("LE")}
    Expression ">" Expression -> Expression {cons("GT")}
    Expression ">=" Expression -> Expression {cons("GE")}
    
    Expression "in" Expression -> Expression {cons("In")}
    Expression "not" "in" Expression -> Expression {cons("NotIn")}
    
    Expression "member" "of" Expression -> Expression {cons("MemberOf")}
    Expression "not" "member" "of" Expression -> Expression {cons("NotMemberOf")}
  
    Expression "||" Expression -> Expression {cons("Concat")}
    
    Expression "+" Expression -> Expression {cons("Plus")}
    Expression "-" Expression -> Expression {cons("Minus")}

    Expression "*" Expression -> Expression {cons("Multiply")}
    Expression "/" Expression -> Expression {cons("Divide")}
    Expression "%" Expression -> Expression {cons("Modulo")}
    
    "-" Expression -> Expression {cons("UMinus")}
    
    %% current_date(), current_time(), and current_timestamp()
    "current_date" "(" ")" -> Expression {cons("HQLFunCurDate")}
    "current_time" "(" ")" -> Expression {cons("HQLFunCurTime")}
    "current_timestamp" "(" ")" -> Expression {cons("HQLFunCurTimestamp")}
    %% second(...), minute(...), hour(...), day(...), month(...), and year(...)
    "second" "(" Expression ")" -> Expression {cons("HQLFunSecond")} 
    "minute" "(" Expression ")" -> Expression {cons("HQLFunMinute")} 
    "hour" "(" Expression ")" -> Expression {cons("HQLFunHour")} 
    "day" "(" Expression ")" -> Expression {cons("HQLFunDay")} 
    "month" "(" Expression ")" -> Expression {cons("HQLFunMonth")} 
    "year" "(" Expression ")" -> Expression {cons("HQLFunYear")} 
    
   lexical syntax 
     ":" Identifier -> IdParameter 
     "?" NumInt     -> NumParameter
   context-free syntax
     IdParameter -> Expression {cons("IdParam")}
     NumParameter -> Expression {cons("NumParam")}
   
    "avg" "(" Expression ")" -> Expression {cons("Avg")}
    "sum" "(" Expression ")" -> Expression {cons("Sum")}
    "min" "(" Expression ")" -> Expression {cons("Min")}
    "max" "(" Expression ")" -> Expression {cons("Max")}
    "count" "(" "*" ")" -> Expression {cons("CountStar")}
    "count" "(" Expression ")" -> Expression {cons("Count")}
    "size" "(" Expression ")" -> Expression {cons("Size")}
    "substring" "(" Expression "," Expression "," Expression ")" -> Expression {cons("SubString")}
    
     "elements" "(" Path ")" -> Expression {cons("Elements")}
     "indices" "(" Path ")" -> Expression {cons("Indices")}
                     
     Path                      -> Expression
     "(" {Expression ","}+ ")" -> Expression {cons("Paren")}
     "(" QueryRule ")"         -> Expression {cons("Paren"), prefer}
     
    Constant -> Expression
    
    "true" -> Constant {cons("True")}
    "false" -> Constant {cons("False")}
    "empty" -> Constant {cons("Empty")}
    "null" -> Constant {cons("Null")}

    "true" -> Identifier {reject}
    "false" -> Identifier {reject}
    "empty" -> Identifier {reject}
    "null"  -> Identifier {reject}
    
    {Identifier "."}+ -> Path {cons("Path")} 
    
  context-free syntax
    QuotedString -> Constant {cons("HqlString")}
    
  lexical syntax
    "'" (~[\'] | "\\'")* "'" -> QuotedString
     
  lexical syntax
    [0-9]+ -> NumInt
  context-free syntax
    NumInt -> Constant
  
context-free priorities
  {
    {Identifier "."}+ -> Path
    "(" {Expression ","}+ ")" -> Expression
    "avg" "(" Expression ")" -> Expression
    "sum" "(" Expression ")" -> Expression
    "min" "(" Expression ")" -> Expression
    "max" "(" Expression ")" -> Expression
    "count" "(" "*" ")" -> Expression
    "count" "(" Expression ")" -> Expression
    "size" "(" Expression ")" -> Expression
    "elements" "(" Path ")" -> Expression
    "indices" "(" Path ")" -> Expression
    "-" Expression -> Expression
  }
  > {left:
    Expression "*" Expression -> Expression
    Expression "/" Expression -> Expression
    Expression "%" Expression -> Expression
    Expression "||" Expression -> Expression
  }
  > {left:
    Expression "+" Expression -> Expression
    Expression "-" Expression -> Expression
  }
  > {left:
    Expression "<" Expression -> Expression
    Expression "<=" Expression -> Expression
    Expression ">" Expression -> Expression
    Expression ">=" Expression -> Expression
    Expression "like" Expression -> Expression 
    Expression "not" "like" Expression -> Expression
    Expression "in" Expression -> Expression
    Expression "not" "in" Expression -> Expression
    Expression "member" "of" Expression -> Expression
    Expression "not" "member" "of" Expression -> Expression
    }
  > {left:
    Expression "=" Expression -> Expression
    Expression "is" Expression -> Expression
    Expression "!=" Expression -> Expression
    Expression "<>" Expression -> Expression
    }
  > "not" Expression -> Expression
  > {left: Expression "and" Expression -> Expression}
  > {left: Expression "or" Expression -> Expression }

module MixHQL[Ctx0]
imports 
        HQL
          [ Constant                        => Constant[[Ctx0]]
            AliasedExpression               => AliasedExpression[[Ctx0]]
            QuotedAliasedExpression         => QuotedAliasedExpression[[Ctx0]]
            SelectedPropertiesList          => SelectedPropertiesList[[Ctx0]]
            WhereClause                     => WhereClause[[Ctx0]]
            HavingClause                    => HavingClause[[Ctx0]]
            AscendingOrDescending           => AscendingOrDescending[[Ctx0]]
            OrderElement                    => OrderElement[[Ctx0]]
            OrderByClause                   => OrderByClause[[Ctx0]]
            GroupByClause                   => GroupByClause[[Ctx0]]
            PropertyFetch                   => PropertyFetch[[Ctx0]]
            Alias                           => Alias[[Ctx0]]
            AsAlias                         => AsAlias[[Ctx0]]
            InCollectionElementsDeclaration => InCollectionElementsDeclaration[[Ctx0]]
            InCollectionDeclaration         => InCollectionDeclaration[[Ctx0]]
            InClassDeclaration              => InClassDeclaration[[Ctx0]]
            FromClassOrOuterQueryPath       => FromClassOrOuterQueryPath[[Ctx0]]
            FromRange                       => FromRange[[Ctx0]]
            WithClause                      => WithClause[[Ctx0]]
            Fetch                           => Fetch[[Ctx0]]
            FromJoin                        => FromJoin[[Ctx0]]
            JoinType                        => JoinType[[Ctx0]]
            FromRangeJoin                   => FromRangeJoin[[Ctx0]]
            FromClause                      => FromClause[[Ctx0]]
            SelectObject                    => SelectObject[[Ctx0]]
            NewExpression                   => NewExpression[[Ctx0]]
            Selection                       => Selection[[Ctx0]]
            Distinct                        => Distinct[[Ctx0]]
            SelectClause                    => SelectClause[[Ctx0]]
            SelectFrom                      => SelectFrom[[Ctx0]]
            QueryRule                       => QueryRule[[Ctx0]]
            Union                           => Union[[Ctx0]]
            SelectStatement                 => SelectStatement[[Ctx0]]
            Statement                       => Statement[[Ctx0]]
            DeleteStatement                 => DeleteStatement[[Ctx0]]
            NumInt                          => NumInt[[Ctx0]]
            QuotedString                    => QuotedString[[Ctx0]]
            NumParameter                    => NumParameter[[Ctx0]]
            IdParameter                     => IdParameter[[Ctx0]]
            Identifier                      => Identifier[[Ctx0]]
            Path                            => Path[[Ctx0]]
            Expression                      => Expression[[Ctx0]] ]


module WebDSL-Action

imports
  WebDSL-Lexical
  MixHQL[HQL]

exports

  context-free syntax %% Functions

    "function" Id OptFormalArgs FunctionReturn Block -> Function {cons("Function")}

    -> FunctionReturn {ast("SimpleSort(\"Void\")")}
    ":" Sort -> FunctionReturn {ast("<1>")}

    "cached" Function -> EntityBodyDeclaration {cons("CachedFunction")}
    "cached" Function -> GlobalsDef {cons("CachedGlobalFunction")}

    "extend" Function -> ExtendFunction {cons("ExtendFunction")}
    ExtendFunction -> EntityBodyDeclaration
    ExtendFunction -> GlobalsDef

  %% static entity function

    "static" "function" Id OptFormalArgs ReturnType Block -> StaticEntityFunction {cons("StaticEntityFunction")}

    ":" Sort -> ReturnType{cons("ReturnType")}
    -> ReturnType {ast("ReturnType(SimpleSort(\"Void\"))")}

  context-free syntax %% inline anonymous functions/closures

    FunctionExp -> Exp
    "function" OptFormalArgs FunctionReturn Block -> FunctionExp {cons("FunctionExp")}

    %% reference to a function, something to help desugar lifted function exp
    FunctionRef -> Exp
    "function." Id "(" {Sort ","}* ")" FunctionReturn -> FunctionRef {cons("FunctionRef")}


    FunctionRef "(" {Exp ","}* ")" -> Exp {cons("FunctionRefCall")}
    FunctionRef "(" "*" "," {Exp ","}* ")" -> Exp {cons("FunctionRefCallPartial")}

  context-free syntax
    "{" Statements "}" 		-> Block {cons("Block")}
    Block              		-> Statement
    %%Assignment ";"	   	-> Statement {cons("Assign")}
    Exp ";"		       		-> Statement {cons("Stat")}

    "return" Exp ";"     	-> Statement {cons("Return")}

    "return" ";"         	-> Statement {cons("ReturnEmpty")}

    "goto" PageCall ";"       	-> Statement {cons("GoTo"),prefer}
    "goto" "(" PageCall ")" ";"         -> Statement {cons("GoTo"),prefer}

    "schedule" Exp "for" Exp ";" -> Statement {cons("Schedule")}
    "schedule" Exp ";"           -> Statement {cons("ScheduleNoFor")}

  context-free syntax

    "var" Id ":" Sort ";" 	       -> VarDeclStat {cons("VarDecl")}
    "var" Id ":" Sort ":=" Exp ";" -> VarDeclStat {cons("VarDeclInit")}
    "var" Id ":=" Exp ";"          -> VarDeclStat {cons("VarDeclInitInferred")}
    VarDeclStat -> Statement

  context-free syntax

    "if" "(" Exp ")" Block "else" Block  -> Statement {cons("If")}
    "if" "(" Exp ")" Block               -> Statement {cons("IfNoElse")}
    "if" "(" Exp ")" Block ElseIfStatement+ OptElse  -> Statement {cons("IfWithElseIf")}
    "else" "if" "(" Exp ")" Block  -> ElseIfStatement {cons("ElseIf")}
    "else" Block                   -> OptElse {ast("<1>")}
                                   -> OptElse {ast("Block([])")}

    "case" "(" {Exp ","}+ ")" "{" Case* "}"  -> Statement {cons("CaseStmt")}
    {Exp ","}+ Block                         -> Case {cons("CaseStmtAlt")}
    "default" Block                          -> Case {cons("CaseStmtDefault"), prefer}

    "typecase" "(" TypeCaseExp OptTypeCaseAlias ")" "{" TypeCaseAlt* "}" -> Statement {cons("TypeCaseStmt")}
    -> OptTypeCaseAlias {ast("None()")}
    "as" Id -> OptTypeCaseAlias {ast("<1>")}
    
    %% 'x as y' is ambiguous, but a Cast expression does not make sense in typecase, reject it
    Exp -> TypeCaseExp
    Exp "as" Sort -> TypeCaseExp {reject}

    Sort Block                                          -> TypeCaseAlt {cons("TypeCaseStmtAlt")}
    "default" Block                                     -> TypeCaseAlt {cons("TypeCaseStmtDefault"), prefer}

  context-free syntax %% if in expression:  if(e) e1 else e2

    "if" "(" Exp ")" Exp "else" Exp -> Exp {cons("IfExp")}

  context-free syntax

    "for" "(" Id ":" Sort "in" Exp OptFilter ")"
      Block 				-> Statement {cons("ForStmt")}

    "for" "(" Id "in" Exp OptFilter ")"
      Block 				-> Statement {cons("ForStmtInferred")}

    "for" "(" Id ":" Sort OptFilter ")"
      Block 				-> Statement {cons("ForAllStmt")}

    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" Block -> Statement {cons("ForCountStmt")}
    "for" "(" Id "from" Exp "to" Exp ")" Block -> Statement {cons("ForCountStmt")}

    "while" "(" Exp ")" Block -> Statement {cons("WhileStmt")}

exports %% Expression language

  sorts ConstValue Exp

  context-free syntax
    Int                    -> ConstValue {cons("Int")}
    Long                   -> ConstValue {cons("Long")}
    Float                  -> ConstValue {cons("Float")}
    String                 -> ConstValue

    ConstValue                  -> Exp

    VarId -> Exp {cons("Var")}
    Id    -> VarId

  %% highlight principal as keyword, and make it a shorthand for securityContext.principal
  context-free syntax
    "principal" -> PrincipalId {cons("PrincipalId")}
    PrincipalId -> Exp
    PrincipalId -> SimpleVar  %% allows string interpolation "~principal"
    "principal" -> VarId {reject}
  context-free restrictions
    PrincipalId -/- [a-zA-Z0-9\_]
  context-free syntax

    "in"                   -> Exp {reject}

    "global" "." Id -> Exp {cons("GlobalVar"), prefer}
    "session" "." Id -> Exp {cons("SessionVar"),prefer}

    Exp "." Id             -> Exp {cons("FieldAccess")}

    CollectionExp "[" Exp "]" -> Exp {cons("CollectionIndex")}
    %% CollectionExp is a workaround for a priorities issue in SDF2 related to Exp "[" Exp "]"
    VarId -> CollectionVar {cons("Var")}
    CollectionVar -> CollectionExp
    CollectionCreation -> CollectionExp
    CollectionExp "." Id -> CollectionExp {cons("FieldAccess")}
    Id "(" {Exp ","}* ")" -> CollectionExp {cons("ThisCall")}
    CollectionExp "." Id "(" {Exp ","}* ")" -> CollectionExp {cons("Call")}
    CollectionExp "[" Exp "]" -> CollectionExp {cons("CollectionIndex")}
    ForExp -> CollectionExp
    InvokeTemplate -> CollectionExp
    "(" Exp ")" -> CollectionExp {bracket}

    Sort "{" ObjectPropertyAssignment* "}"         -> ObjectCreation {cons("ObjectCreation")}
    Sort "{" { ObjectPropertyAssignment "," }* "}" -> ObjectCreation {cons("ObjectCreation"), prefer}
    ObjectCreation -> Exp

    Id ":=" Exp           -> ObjectPropertyAssignment {cons("ObjectPropertyAssignment")}
    %% fallback for code completion:
    Id -> ObjectPropertyAssignment {cons("IncompleteObjectPropertyAssignment")}

    Exp ":=" Exp             -> Assignment {cons("Assignment")}
    Assignment				-> Exp

    CollectionCreation -> Exp

    "[" Mapping* "]"       -> CollectionCreation {cons("MapCreation"), avoid} %%avoid to prevent ambiguity between with empty untyped list creation and empty map creation
    Exp "->" Exp           -> Mapping {cons("Mapping")}

    "[" {ExpListCreation ","}* "]" -> CollectionCreation {cons("ListCreation")}
    "{" {ExpListCreation ","}+ "}" -> CollectionCreation {cons("SetCreation")}

    "List" "<" Sort ">" "(" {ExpListCreation ","}* ")" -> CollectionCreation {cons("TypedListCreation"), prefer}
    "Set"  "<" Sort ">" "(" {ExpListCreation ","}* ")" -> CollectionCreation {cons("TypedSetCreation"), prefer}

    Exp -> ExpListCreation

    "for" "(" Id ":" Sort "in" Exp OptFilter ")" "{" {Exp ","}* "}"
    -> ExpListCreation {cons("ExpVarArgFor")}

    "for" "(" Id "in" Exp OptFilter ")" "{" {Exp ","}* "}"
    -> ExpListCreation {cons("ExpVarArgForInferred")}

    "for" "(" Id ":" Sort OptFilter ")" "{" {Exp ","}* "}"
    -> ExpListCreation {cons("ExpVarArgForAll")}

    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" "{" {Exp ","}* "}"
    -> ExpListCreation {cons("ExpVarArgForCount")}
    "for" "(" Id "from" Exp "to" Exp ")" "{" {Exp ","}* "}"
    -> ExpListCreation {cons("ExpVarArgForCount")}

  context-free syntax  %% tuples

    "(" {Exp ","}+ ")"  -> Exp  {cons("TupleCreation"), avoid}
    "(" {Sort ","}+ ")" -> Sort {cons("TupleSort")}
    "[" {Sort ","}+ "]" -> Sort {ast("GenericSort(\"List\",[TupleSort(<1>)])"), avoid}

  lexical syntax
    Id -> GlobalFunCallId  %% hook for reject rules on global function call names
  context-free syntax
    GlobalFunCallId "(" {Exp ","}* ")" -> Exp {cons("ThisCall")}
    "replace"  -> KeywordGlobalFunName {ast("\"replace\"")}
    "rollback" -> KeywordGlobalFunName {ast("\"rollback\"")}
    "cancel"   -> KeywordGlobalFunName {ast("\"cancel\"")}
    KeywordGlobalFunName "(" {Exp ","}* ")" -> Exp {ast("ThisCall(<1>, <2>)")}
    KeywordGlobalFunName -> GlobalFunCallId {reject}
    Keyword -> GlobalFunCallId {reject}

    "!" "(" {Exp ","}* ")"  -> Exp {reject}

    Exp "." Id "(" {Exp ","}* ")"  -> Exp {cons("Call")}

    Exp "is" "a" Sort      -> Exp {cons("IsA")}
    Exp "as" Sort          -> Exp {cons("Cast"), avoid} %% avoid, to give hql query AsAlias more priority, 'from Page as p' should make the 'as p' part of the query

  context-free syntax
    Exp "in" Exp           -> Exp {non-assoc, cons("InColl")}
  context-free restrictions
    "in" -/- [a-zA-Z0-9\_] %% there must be whitespace after the 'in' keyword for collection test

  context-free syntax
    Exp "==" Exp           -> Exp {cons("Eq"), left}
    Exp "!=" Exp           -> Exp {cons("NotEq"), left}
    Exp ">" Exp           -> Exp {cons("LargerThan"), left}
    Exp ">=" Exp           -> Exp {cons("LargerThanOrEqual"), left}
    Exp "<" Exp           -> Exp {cons("SmallerThan"), left}
    Exp "<=" Exp           -> Exp {cons("SmallerThanOrEqual"), left}

    "true"                 -> Exp {prefer,cons("True")}
    "false"                -> Exp {prefer,cons("False")}

    "null"                 -> Exp {prefer,cons("Null")}

    Exp "&&" Exp          -> Exp {cons("And"), assoc}
    Exp "||" Exp           -> Exp {cons("Or"), assoc}
    "!" Exp              -> Exp {cons("Not")}

    "(" Exp ")"            -> Exp {bracket}


    "[" Exp "|" Id OptSort "in" Exp OptFilter OptGroupBy "]"  -> ForExp {cons("ForExp")}
    "[" Id OptSort "in" Exp OptFilter OptGroupBy "]"          -> ForExp {ast("ForExp(Var(<1>),<1>,<2>,<3>,<4>,<5>)")}
    ForExp          -> Exp
    "group by" Exp  -> OptGroupBy {cons("GroupBy")}
                    -> OptGroupBy {cons("None")}


    "And" ForExp  -> Exp {cons("AndForExp")}
    "Or"  ForExp  -> Exp {cons("OrForExp")}


    Exp "*" Exp  -> Exp {cons("Mul"),assoc}
    Exp "/" Exp  -> Exp {cons("Div"),assoc}
    Exp "%" Exp  -> Exp {cons("Mod"),assoc}
    Exp "+" Exp  -> Exp {cons("Add"),assoc}
    Exp "-" Exp  -> Exp {cons("Sub"),assoc}

context-free priorities
  {left:
    Exp "." Id "(" {Exp ","}* ")"  -> Exp
    Exp "." Id  -> Exp
    %%Exp "[" Exp "]"  -> Exp  %% this gives syntax error on 'list[x+y]' in SDF2, using workaround with CollectionExp
    "session" "." Id -> Exp
  }
  > {non-assoc:
       Exp "is" "a" Sort -> Exp
       Exp "as" Sort     -> Exp
    }
  > "!" Exp -> Exp
  > {left:
       Exp "*" Exp -> Exp
       Exp "%" Exp -> Exp
       Exp "/" Exp -> Exp }
  > {left:
       Exp "+" Exp -> Exp
       Exp "-" Exp -> Exp }
  > Exp "in" Exp -> Exp
  > {left:
       Exp "==" Exp -> Exp
       Exp "!=" Exp -> Exp
       Exp ">" Exp -> Exp
       Exp ">=" Exp -> Exp
       Exp "<" Exp -> Exp
       Exp "<=" Exp -> Exp }
  > {left:
       Exp "&&" Exp -> Exp }
  > {left:
       Exp "||" Exp -> Exp }
  > Assignment -> Exp
  > HqlExp -> Exp
  > "if" "(" Exp ")" Exp "else" Exp -> Exp


exports

  context-free syntax

    QueryRule[[HQL]]                     -> HqlExp {cons("HqlQuery")}
    QueryRule[[HQL]] "limit" LimitValueExp         -> HqlExp {cons("HqlQueryLimit")}
    QueryRule[[HQL]] "limit" LimitValueExp "," LimitValueExp -> HqlExp {cons("HqlQueryLimitOffset")}

    %%although limit is not part of HQL, it has been added in WebDSL so it should support the ~var style of injecting values into HQL
    Exp -> LimitValueExp
    DslExp -> LimitValueExp

    DslExp -> Expression[[HQL]]
    "~" Exp -> DslExp {cons("DslExp")}

    DeleteStatement[[HQL]] ";" -> Statement {cons("HqlStatement")}

  context-free syntax

    QueryRule[[HQL]] "." Id -> Exp {reject}

context-free syntax %% email functions

  Id "(" {Exp ","}* ")" -> EmailCall {cons("EmailCall")}

  "renderemail" "(" EmailCall ")" -> InvokeTemplate {cons("RenderEmailFunctionCall"),prefer}
  "email" "(" EmailCall ")" -> Exp {cons("EmailFunctionCall"),prefer}
  "email" EmailCall -> Exp {cons("EmailFunctionCall"),prefer}
  "sendemail" "(" EmailCall ")" -> Exp {cons("SendEmailFunctionCall"),prefer}

context-free syntax %% function to execute a particular template phase

  InvokeTemplate -> Exp
  "rendertemplate" "(" TemplateCall ")" -> InvokeTemplate {cons("RenderTemplateFunctionCall"),prefer}
  "validatetemplate" "(" TemplateCall ")" -> InvokeTemplate {cons("ValidateTemplateFunctionCall"),prefer}

context-free syntax %% template elements passed as template argument

  "{" TemplateElement* "}" -> Exp {cons("TemplateElementsArgument"), avoid}

module WebDSL-Ajax

exports

  sorts Statement Exp InlineTemplate AjaxStatement
  context-free syntax

%% support dropped -> http://yellowgrass.org/issue/WebDSL/713
%%     "event" "(" Id "," "[" { EventArg "," }* "]" ")" -> Exp {cons("EventCall")}
%%     "event" "(" Id "," "[" { EventArg "," }* "]" ")" -> TemplateElement {cons("EventCallElement")}
%%
%%     Id ":=" Exp -> EventArg {cons("EventArg")}

%%  	replace <element_id> << <templatecall>(<argumenten>);
%%	append  <element_id> << <templatecall>(<argumenten>);
%%	visibility <element_id> << < "show" | "hide" | "toggle">;
%%	relocate this << <pagecall>(<argumenten>);
%%	restyle <element_id> << "<css classname>";
%%	clear <element_id> << "<niet terzake doende string>"

  AjaxStatement ";" -> Statement {cons("AjaxStatement"), prefer}
    "replace" "(" Exp "," TemplateCall ")" -> AjaxStatement {cons("AjaxReplace")}

    "append" "(" Exp "," TemplateCall ")" -> AjaxStatement {cons("AjaxAppend")}

    "visibility" "(" Exp "," AjaxVisibility ")" -> AjaxStatement {cons("AjaxVisibility")}
    "show" -> AjaxVisibility{cons("Show")}
    "toggle" -> AjaxVisibility{cons("Toggle")}
    "hide" -> AjaxVisibility{cons("Hide")}

    "relocate" "(" PageCall ")" -> AjaxStatement { cons("AjaxRelocate") }

    "restyle" "(" Exp "," Exp ")" -> AjaxStatement { cons("AjaxRestyle") }

    "clear" "(" Exp ")" -> AjaxStatement{cons("AjaxClear")}

    "refresh" "(" ")" -> AjaxStatement{cons("AjaxRefresh")}

    "runscript" "(" Exp ")" -> AjaxStatement { cons("AjaxRunScript"), prefer }

%%    Id Id "<<" Id  ";" 	 -> Statement {cons("AjaxActionIdParam"),prefer}
%%    Id Id "<<" ";"		-> Statement {cons("AjaxActionNoParam")}
%%    Id "<<" Exp ";"	 	-> Statement {cons("AjaxActionNoTarget")}
%%    Id Id "<<" Exp ";"   	-> Statement {cons("AjaxAction")}

    Placeholder -> TemplateElement
    PlaceholderKeyword "<" Id ">" Id "{" TemplateElement* "}" -> Placeholder{ast("Placeholder(<2>,<3>,<4>)"), prefer}
    PlaceholderKeyword "<" Id ">" Exp "{" TemplateElement* "}"-> Placeholder{ast("Placeholder(<2>,<3>,<4>)")}
    PlaceholderKeyword "<" Id ">" Id TemplateCall -> Placeholder{ast("PlaceholderWithAjaxCall(<2>,<3>,<4>)"), prefer}
    PlaceholderKeyword "<" Id ">" PHExp TemplateCall -> Placeholder{ast("PlaceholderWithAjaxCall(<2>,<3>,<4>)")}
    
    PlaceholderKeyword Id "{" TemplateElement* "}" -> Placeholder{ast("Placeholder(<2>,<3>)"), prefer}
    PlaceholderKeyword Exp "{" TemplateElement* "}"-> Placeholder{ast("Placeholder(<2>,<3>)")}
    PlaceholderKeyword Id TemplateCall -> Placeholder{ast("PlaceholderWithAjaxCall(<2>,<3>)"), prefer}
    PlaceholderKeyword PHExp TemplateCall -> Placeholder{ast("PlaceholderWithAjaxCall(<2>,<3>)")}
    
    %% node for describing a placeholder var declaration without body
    %% making it explicit in the syntax is convenient for desugaring, testing and debugging
    PlaceholderVar -> TemplateElement
    PlaceholderVarKeyword Id -> PlaceholderVar{ast("PlaceholderVar(<2>)"), prefer}

  context-free syntax
    "placeholder" -> PlaceholderKeyword
    "placeholdervar" -> PlaceholderVarKeyword
  context-free restrictions
    PlaceholderKeyword
    PlaceholderVarKeyword
    -/- [a-zA-Z0-9\_]

  context-free syntax

    %% issue http://yellowgrass.org/issue/Spoofax/331
    %% workaround:
    Id "(" {Exp ","}* ")"  -> PHExp {cons("ThisCall")}
    Exp "." Id "(" {Exp ","}* ")"  -> PHExp {cons("Call")}
    Exp "." Id             -> PHExp {cons("FieldAccess"),prefer}
    Exp "[" Exp "]"        -> PHExp {cons("CollectionIndex"),prefer}
    Exp "+" Exp  -> PHExp {cons("Add")}
    ConstValue -> PHExp
    %%
    %% more general implementation, currently broken in java back-end:
    %% "placeholder" Exp TemplateCall -> TemplateElement{cons("PlaceholderWithAjaxCall")}
    %% reject ambiguous placeholder target{} next{} where target{} is parsed as object creation,
    %% which is never the case since the expression must produce a String
    %% "placeholder" ObjectCreation TemplateCall   -> TemplateElement {reject}


module WebDSL-UI

imports
  WebDSL-Action
  WebDSL-Lexical

exports

  sorts TemplateDefinition Modifier Exp

  context-free syntax

    TemplateDefinition -> Definition

    "define" Modifier*
       Id OptFormalArgs
       TemplateArgs
       "{" TemplateElement* "}"             -> TemplateDefinition {cons("Define")}

    "requires" {TemplateArg "," }*            -> TemplateArgs{cons("TemplateArgs"), prefer}
    Id "(" {Sort ","}* ")"                  -> TemplateArg {cons("TemplateArg")}

      -> TemplateArgs{cons("None")}

    "define" Modifier* Id "(" {FormalArg ","}* ")" "=" Id OptLocalRedefineArgs -> TemplateDefinition {cons("LocalRedefine")}
    -> OptLocalRedefineArgs {cons("None")}
    "(" "*" "," {LocalRedefineArg ","}+ ")" -> OptLocalRedefineArgs {cons("LocalRedefineArgs")}
    Id -> LocalRedefineArg{cons("Var")}

    %% new page syntax
    Modifier*
    "page"
    PageId
    OptFormalArgs
    TemplateArgs
    "{" TemplateElement* "}"  -> TemplateDefinition {cons("DefinePage")}

    %% new template syntax
    Modifier*
    "template"
    Id
    OptFormalArgs
    TemplateArgs
    "{" TemplateElement* "}"  -> TemplateDefinition {cons("DefineTemplate")}

    Modifier*
    "email"
    Id
    OptFormalArgs
    TemplateArgs
    "{" TemplateElement* "}"  -> TemplateDefinition {ast("Define([Email()], <2>, <3>, <4>, <5>)")}

    "(" {FormalArg ","}* ")" -> OptFormalArgs {ast("<1>")}
                             -> OptFormalArgs {ast("[]")}

    %%"define" Modifier*
    %%   Id UNDEFINED*
    %%   "{" TemplateElement* "}"             -> TemplateDefinition {cons("Define")}

    "page"                                  -> Modifier {cons("Page")}
    "email"                                 -> Modifier {cons("Email")}
    "ajax"                                  -> Modifier {cons("AjaxTemplate")}
    "template"                              -> Modifier {cons("Template")}
    "feed"                                  -> Modifier {cons("Feed")}
    "local"                                 -> Modifier {cons("Local")}
    "no-span"                               -> Modifier {cons("NoSpan")}
    "span"                                  -> Modifier {cons("TemplateModSpan")}
    "inline"                                -> Modifier {cons("TemplateModInline")}
    "override"                              -> Modifier {cons("TemplateModOverride")}
    "deprecated"                            -> Modifier {cons("TemplateDeprecated")}
    "expire-cache"                          -> Modifier {cons("ExpireCache")}
    "read-only"                             -> Modifier {cons("ReadOnlyPage")}
    "service"                               -> Modifier {cons("WebService")}

    InitAction                              -> TemplateElement
    Action                                  -> TemplateElement

    "var" Id ":" Sort                       -> VarDecl {cons("TemplateVarDecl")}
    "var" Id ":" Sort ":=" Exp              -> VarDecl {cons("TemplateVarDeclInit")}
    "var" Id ":=" Exp                       -> VarDecl {cons("TemplateVarDeclInitInferred")}
    VarDecl                                 -> TemplateElement
    %% still allow ";" behind page var for backwards comp.
    "var" Id ":" Sort ";" 	       -> VarDecl {cons("TemplateVarDecl"), deprecated ("remove ';'")}
    "var" Id ":" Sort ":=" Exp ";" -> VarDecl {cons("TemplateVarDeclInit"), deprecated ("remove ';'")}
    "var" Id ":=" Exp ";"          -> VarDecl {cons("TemplateVarDeclInitInferred"), deprecated ("remove ';'")}
    "request" VarDecl                       -> TemplateElement {cons("RequestScopeTemplate")}
    "local" VarDecl                         -> TemplateElement {cons("LocalScopeTemplate")}

    TemplateDefinition                      -> TemplateElement
    TemplateCall                            -> TemplateElement {avoid}


    "where" Exp                                    -> Filter {cons("FilterNoOrderByNoLimit")}
    "order" "by" {OrderExp ","}+                   -> Filter {cons("FilterNoWhereNoLimit")}
    "where" Exp "order" "by" {OrderExp ","}+       -> Filter {cons("FilterNoLimit")}
    "where" Exp Limit                              -> Filter {cons("FilterNoOrderBy")}
    "order" "by" {OrderExp ","}+ Limit             -> Filter {cons("FilterNoWhere")}
    Limit                                          -> Filter {cons("FilterNoWhereNoOrderBy")}
    "where" Exp "order" "by" {OrderExp ","}+ Limit -> Filter {cons("Filter")}
    Exp                      -> OrderExp {cons("OrderNonSpecific")}
    Exp "asc"                -> OrderExp {cons("OrderAscending")}
    Exp "desc"               -> OrderExp {cons("OrderDescending")}
    "limit" Exp "offset" Exp -> Limit {cons("Limit")}
    "limit" Exp              -> Limit {cons("LimitNoOffset")}
    "offset" Exp             -> Limit {cons("LimitNoLimit")}


    "for" "(" Id ":" Sort "in" Exp OptFilter ")"
       "{" TemplateElement* "}" ForSeparator       -> TemplateElement {cons("For")}

    Filter -> OptFilter
    -> OptFilter {cons("None")}

    ":" Sort -> OptSort {ast("<1>")}
    -> OptSort {cons("None")}

    "for" "(" Id "in" Exp OptFilter ")"
       "{" TemplateElement* "}" ForSeparator       -> TemplateElement {cons("ForInferred")}

    "for" "(" Id ":" Sort OptFilter ")"
       "{" TemplateElement* "}" ForSeparator       -> TemplateElement {cons("ForAll")}

    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")"
      "{" TemplateElement* "}" ForSeparator        -> TemplateElement {cons("ForCount")}
    "for" "(" Id "from" Exp "to" Exp ")"
      "{" TemplateElement* "}" ForSeparator        -> TemplateElement {cons("ForCount")}

    "separated-by" "{" TemplateElement* "}" -> ForSeparator{cons("ForSeparator")}
    -> ForSeparator{cons("None")}


    "if" "(" Exp ")" "{" TemplateElement* "}" ElseIfTempl* ElseTempl? -> TemplateElement {cons("IfElseIfTempl"),prefer}
    "else" "if" "(" Exp ")" "{" TemplateElement* "}"                  -> ElseIfTempl {cons("ElseIfTempl"),prefer}
    "else" "{" TemplateElement* "}"                                   -> ElseTempl  {cons("ElseTempl"),prefer}


    "case" "(" {Exp ","}+ ")" "{" TemplateCaseAlt* "}"  -> TemplateElement {cons("TemplateCase")}
    {Exp ","}+ "{" TemplateElement* "}"                 -> TemplateCaseAlt {cons("TemplateCaseAlt")}
    "default" "{" TemplateElement* "}"                  -> TemplateCaseAlt {cons("TemplateCaseAltDefault"), prefer}

    "typecase" "(" TypeCaseExp OptTypeCaseAlias ")" "{" TemplateTypeCaseAlt* "}" -> TemplateElement {cons("TemplateTypeCase")}
    Sort "{" TemplateElement* "}"                               -> TemplateTypeCaseAlt {cons("TemplateTypeCaseAlt")}
    "default" "{" TemplateElement* "}"                          -> TemplateTypeCaseAlt {cons("TemplateTypeCaseDefault"), prefer}

  %%
    TemplateCallId OptTCallArgs OptTCallPropAssigns TemplateBody -> TemplateCall {cons("TemplateCall")}

    "(" {TemplateArgExp ","}* ")" -> OptTCallArgs {ast("<1>")}
                                  -> OptTCallArgs {ast("[]")}

    Exp -> TemplateArgExp

    "[" {PropertyAssignment ","}* "]" -> OptTCallPropAssigns {ast("<1>")}
                                      -> OptTCallPropAssigns {ast("[]")}

    "{" TemplateElement* "}" -> TemplateBody {cons("TemplateBody")}
                             -> TemplateBody {ast("TemplateBody([])")}

    "with" "{" ArgDefine* "}" -> TemplateBody {cons("TemplateWith")}

    TemplateCallId "(" {FormalArg ","}* ")" "{" TemplateElement* "}" -> ArgDefine {cons("ArgDefine")}

    "with" "{" TemplateElement* "}" -> TemplateCall {reject}



    "navigate" "(" PageCall ")" OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("NavigateCall"), deprecated("Use 'navigate pagecall() { elements }'")}

    "navigate" PageCall OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("NavigateCall")}

    PageId OptExpArgs  -> PageCall {cons("PageCall")}

    "(" {Exp ","}* ")" -> OptExpArgs {ast("<1>")}
                       -> OptExpArgs {ast("[]")}



    "action"     "(" Exp "," ActionCallOrInline ")" OptTCallPropAssigns -> TemplateElement {cons("Submit"), deprecated("Use 'submit action { elements }'")}
    "actionLink" "(" Exp "," ActionCallOrInline ")" OptTCallPropAssigns -> TemplateElement {cons("SubmitLink"), deprecated("Use 'submitlink action { elements }'")}

    "submit"     "(" Exp "," ActionCallOrInline ")" OptTCallPropAssigns -> TemplateElement {cons("Submit"), deprecated("Use 'submit action { elements }'")}
    "submitlink" "(" Exp "," ActionCallOrInline ")" OptTCallPropAssigns -> TemplateElement {cons("SubmitLink"), deprecated("Use 'submitlink action { elements }'")}

    "submit"     ActionCallOrInline OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("SubmitElem")}
    "submitlink" ActionCallOrInline OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("SubmitLinkElem")}

    "downloadlink" ActionCallOrInline OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("DownloadLink")}
    "outputimage"  ActionCallOrInline OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("OutputImage")}

    ActionCall   -> ActionCallOrInline
    InlineAction -> ActionCallOrInline
                 -> ActionCallOrInline {ast("InlineAction(Block([])")}
    ReplaceAction -> ActionCallOrInline

    "replace" "(" {Exp ","}+ ")" -> ReplaceAction {cons("ReplaceAction")}

    ActionCallId OptExpArgs -> ActionCall {cons("ActionCall")}

  lexical syntax
    Id -> ActionCallId  %% hook for reject rules on action names
    "replace" -> ActionCallId {reject}

  context-free restrictions
    "submit" -/- [l]  %% avoid ambiguity 'submitlink{}' (submitlink with action omitted / submit with 'link' action)

  context-free syntax

    "action" Block -> InlineAction {cons("InlineAction")}
    %% reject ambiguous ObjectCreation(SimpleSort("action"), [])
    "action" -> Sort {reject}
    %%"template" "{" TemplateElement* "}" -> InlineTemplate {cons("InlineTemplateCall")}
    %% "template"               -> Id {reject}

    %% Template call without braces must be disambiguated in some cases
    "action" -> TemplateCall {reject}  %%this is an action definiton, not a templatecall without params
    "action" -> Exp {reject}           %%this is an inline action, not a variable
    "action" -> PropertyValue {reject} %%this is an inline action, not an id



    SubmitProp ":"  ActionCallOrInline -> PropertyAssignment {cons("PropertySubmit"),deprecated("Use '=' instead"),prefer}
    SubmitProp ":=" ActionCallOrInline -> PropertyAssignment {cons("PropertySubmit"),deprecated("Use '=' instead"),prefer}
    SubmitProp "="  ActionCallOrInline -> PropertyAssignment {cons("PropertySubmit"),prefer}
    ExtendedId ":"  PropertyValue      -> PropertyAssignment {cons("PropertyAssignment"),deprecated("Use '=' instead")}
    ExtendedId ":=" PropertyValue      -> PropertyAssignment {cons("PropertyAssignment"),deprecated("Use '=' instead")}
    ExtendedId "="  PropertyValue      -> PropertyAssignment {cons("PropertyAssignment")}

    Exp -> PropertyValue

    "ajax"                -> PropertyAssignment {cons("TemplateCallPropertyAjax")}
    "no loading feedback" -> PropertyAssignment {cons("TemplateCallPropertyNoLoadingFeedback")}
    "ignore-validation"   -> PropertyAssignment {cons("TemplateCallPropertyIgnoreValidation")}
    "not null"            -> PropertyAssignment {cons("TemplateCallPropertyNotNull")}

    CommonAttribute -> PropertyAssignment

    %% multiple action calls, e.g. trigger an onkeyup action and also execute the onkeyup passed in attributes
    SubmitProp "=" {ActionCallOrInlineOrExp ";"}+ -> PropertyAssignment {cons("PropertySubmitMultiple"), avoid}
    ActionCallOrInline -> ActionCallOrInlineOrExp {prefer}
    PropertyValue      -> ActionCallOrInlineOrExp

  lexical syntax
    "onabort" -> SubmitProp
    "onblur"  -> SubmitProp
    "onchange"  -> SubmitProp
    "onclick"  -> SubmitProp
    "ondblclick" -> SubmitProp

    "onerror"  -> SubmitProp
    "onfocus"  -> SubmitProp
    "onkeydown"  -> SubmitProp
    "onkeypress" -> SubmitProp
    "onkeyup" -> SubmitProp

    "onload" -> SubmitProp
    "onmousedown" -> SubmitProp
    "onmousemove" -> SubmitProp
    "onmouseout" -> SubmitProp
    "onmouseover" -> SubmitProp
    "onmouseenter" -> SubmitProp
    "onmouseleave" -> SubmitProp
    "onmouseup" -> SubmitProp

    "onreset" -> SubmitProp
    "onresize" -> SubmitProp
    "onselect" -> SubmitProp
    "onsubmit" -> SubmitProp

    "onunload" -> SubmitProp
    "oninput" -> SubmitProp

  context-free syntax
  %%

    %% "if" "(" Exp ")" "{" TemplateElement* "}"      -> TemplateCall {reject}
    %% "else" "{" TemplateElement* "}"                -> TemplateCall {reject}
    "separated-by" "{" TemplateElement* "}"        -> TemplateCall {reject}

    "init" Block       -> InitAction {cons("InitAction"),prefer}
    "databind" Block   -> TemplateElement {cons("DataBindAction"),prefer}
    "render" Block     -> TemplateElement {cons("RenderAction"),prefer}
    "allphases" Block  -> TemplateElement {cons("AllPhasesAction"),prefer}
    "validate" Block   -> TemplateElement {cons("ValidateAction"),prefer}

    "action" ActionModifier* Id OptFormalArgs Block -> Action {cons("Action")}
    "ignore-validation" -> ActionModifier{cons("ActionModifierIgnoreValidation")}

  context-free syntax

    Id ".elements" -> TemplateCallId {cons("QualifiedElementsCall"),prefer}

  context-free syntax  %% template var args

    "[" {FormalVarArg ","}+ "]"             -> Sort {cons("TemplateVarArgSort")}
    Id ":" Sort                             -> FormalVarArg {cons("FormalVarArg")}
    Id "." TemplateCall                     -> TemplateCall {cons("MemberTemplateCall"), avoid}

    "[" {ExpVarArg ","}+ "]"                -> TemplateArgExp {cons("TemplateVarArgExp"), prefer}
    "(" {Exp ","}* ")"                      -> ExpVarArg {cons("ExpVarArg")}

    "for" "(" Id ":" Sort "in" Exp OptFilter ")" "{" {ExpVarArg ","}* "}"
    -> ExpVarArg {cons("ExpVarArgFor")}

    "for" "(" Id "in" Exp OptFilter ")" "{" {ExpVarArg ","}* "}"
    -> ExpVarArg {cons("ExpVarArgForInferred")}

    "for" "(" Id ":" Sort OptFilter ")" "{" {ExpVarArg ","}* "}"
    -> ExpVarArg {cons("ExpVarArgForAll")}

    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" "{" {ExpVarArg ","}* "}"
    -> ExpVarArg {cons("ExpVarArgForCount")}
    "for" "(" Id "from" Exp "to" Exp ")" "{" {ExpVarArg ","}* "}"
    -> ExpVarArg {cons("ExpVarArgForCount")}

  context-free syntax %% htmlwrapper shorthand

    "htmlwrapper" Id OptFormalArgs Id HTMLWrapperAssigns -> HTMLWrapper {cons("HTMLWrapper")}

    "[" {Attribute ","}*"]"                -> HTMLWrapperAssigns{cons("HTMLWrapperAssigns")}
    "[" Attribute* "]"                     -> HTMLWrapperAssigns{cons("HTMLWrapperAssigns"), prefer}
                                           -> HTMLWrapperAssigns{ast("HTMLWrapperAssigns([])")}

    HTMLWrapper                            -> TemplateDefinition
    "htmlwrapper" "{" HTMLWrapperBody* "}" -> TemplateDefinition {cons("HTMLWrapperMultiple")}
    Id OptFormalArgs Id HTMLWrapperAssigns -> HTMLWrapperBody {cons("HTMLWrapperBody")}

  context-free syntax %% id -> getTemplate().getUniqueId()

    "id" -> TemplateId {cons("TemplateId")}
    TemplateId -> Exp
    TemplateId -> SimpleVar  %% allows string interpolation "~id"
    "id" -> VarId {reject}

  context-free restrictions

    TemplateId -/- [a-zA-Z0-9\_]

module WebDSL-Keywords

exports

  sorts
    Keyword

  context-free syntax

    Keyword -> Id {reject}  %% (not rejected in HQL as keyword)

  context-free syntax

    "function" -> Keyword
    "return"   -> Keyword
    "as"       -> Keyword
    "define"   -> Keyword
    "for"      -> Keyword

  context-free restrictions

    "as" -/- [a-zA-Z0-9\_]  %% prevent ambiguity between as and asc (used in for-filters)


  context-free syntax  %%  keywords specific to UI template context

    "define"   -> TemplateCallId {reject}
    "template" -> TemplateCallId {reject}
    "var"      -> TemplateCallId {reject}
    "for"      -> TemplateCallId {reject}
    "if"       -> TemplateCallId {reject}
    "else"     -> TemplateCallId {reject}
    "as"       -> TemplateCallId {reject}
    "is"       -> TemplateCallId {reject}
    "null"     -> TemplateCallId {reject}
    "and"      -> TemplateCallId {reject}
    "or"       -> TemplateCallId {reject}
    "order"    -> TemplateCallId {reject}
    "by"       -> TemplateCallId {reject}
    "where"    -> TemplateCallId {reject}
    "in"       -> TemplateCallId {reject}
    "navigate" -> TemplateCallId {reject}
    "action"   -> TemplateCallId {reject}
    "submit"   -> TemplateCallId {reject}
    "goto"     -> TemplateCallId {reject}
    "foreach"  -> TemplateCallId {reject}
    "request"  -> TemplateCallId {reject}
    "local"    -> TemplateCallId {reject}
    "init"     -> TemplateCallId {reject}
    "databind" -> TemplateCallId {reject}
    "derive"   -> TemplateCallId {reject}
    "ajax"     -> TemplateCallId {reject}
    "rules"    -> TemplateCallId {reject}  %% avoid amb: apply ac rules foo()
    "actionLink"   -> TemplateCallId {reject}
    "submitlink"   -> TemplateCallId {reject}
    "downloadlink" -> TemplateCallId {reject}
    "outputimage"  -> TemplateCallId {reject}
    "placeholder"  -> TemplateCallId {reject}
    "expand"       -> TemplateCallId {reject}
    PlaceholderKeyword    -> TemplateCallId {reject}
    PlaceholderVarKeyword -> TemplateCallId {reject}

module WebDSL-Lexical

exports

  lexical syntax
    Id -> TemplateCallId  %% hook for reject rules on templatecall names
    [a-zA-Z][a-zA-Z0-9\_]* -> Id
    [a-zA-Z][a-zA-Z0-9\_\-]* -> PageId
    [a-zA-Z0-9\-\_\.]+     -> ExtendedId
    {ExtendedId "/"}+      -> ModuleName
    ~[\n\r]*               -> SectionName

  lexical restrictions
    Id         -/- [a-zA-Z0-9\_]
    PageId     -/- [a-zA-Z0-9\_\-]
    ModuleName -/- [a-zA-Z0-9\/]

  lexical syntax
    "-"? [0-9]+            -> Int
    "-"? [0-9]+ "L"        -> Long

  lexical syntax
    "-"? FloatDigits
     ExponentPart? [fFdD]? -> Float
    [0-9]* "." [0-9]+      -> FloatDigits
    [0-9]+                 -> FloatDigits
    [eE] SignedInteger     -> ExponentPart
    [\+\-]? [0-9]+         -> SignedInteger

    "-"? [0-9]+            -> Float {reject}
    "."                    -> FloatDigits  {reject}

  lexical restrictions
    Int           -/- [0-9]
    Float         -/- [fFdD]
    FloatDigits   -/- [0-9]
    SignedInteger -/- [0-9]

  %% Kernel syntax is required here since we do not want LAYOUT to be parsed between
  %% the first QMLex and StringLex
  syntax
    %% string literal as expression
    <QMLex-LEX> <StringLex-LEX> <QMLex-LEX>  -> <String-CF>  {ast("String(<2>)")}
    <QMLex-LEX> StringPart* <QMLex-LEX>      -> <String-CF>  {ast("StringInterp(<2>)"), avoid}

    %% string literal as template element
    <QMLex-LEX> <StringLex-LEX> <QMLex-LEX> -> <TemplateElement-CF> {ast("Text(<2>)")}
    <QMLex-LEX> StringPart* <QMLex-LEX>     -> <TemplateElement-CF> {ast("TextInterp(<2>)"), avoid}

    SimpleStringPart       -> StringPart
    <StringLexInterp-LEX>  -> StringPart

    "~" <SimpleExp-CF>    -> SimpleStringPart {cons("InterpExp")}
    "~" "(" <Exp-CF> ")"  -> StringPart {cons("InterpExp")}

  restrictions
    SimpleStringPart -/- [\.\(]  %% make fieldaccess/call not part of string that follows
                                 %% use parentheses variant if a . is needed in the string

  context-free syntax
    %% ~SimpleExp and ~(Exp) shorthand for output template call
    "~" SimpleExp    -> OutputShorthand {cons("OutputShorthand")}
    "~" "(" Exp ")"  -> OutputShorthand {cons("OutputShorthand")}
    OutputShorthand  -> TemplateElement

  context-free syntax
  %% SimpleExp: specific commonly occuring expressions allowed directly after '~' inside string
  %% allowing all expressions directly after '~' causes too many ambiguities
  %% parentheses expression is used as delimiter for inserting any expression
  %% allowed after '~': var/fieldaccess/thiscall/call/brackets a, a.b, a(), a.b(), (exp)
  %% a '.' after a SimpleExp must be rejected as part of String to avoid amb, e.g. not allowed: "~a."
  %% in these cases, use '()' if a '.' is needed as part of the string,       e.g.     allowed: "~(a)."

   VarId             -> SimpleVar {cons("Var")}
   SimpleVar         -> SimpleExp
   SimpleExp "." Id  -> SimpleExp {cons("FieldAccess")}

   Id "(" {Exp ","}* ")"                -> SimpleExp {cons("ThisCall")}
   SimpleExp "." Id "(" {Exp ","}* ")"  -> SimpleExp {cons("Call")}

  lexical syntax
    "\""                         -> QMLex
    StringChar*                  -> StringLex
    StringChar+                  -> StringLexInterp
    ~[\"\n\~\\]                  -> StringChar
    %% Escape sequences adopted from Java, does not require transformation
    %% '~' is WebDSL-specific escape, needs to be unescaped when generating Java String
    "\\" [0-9btnfr\'\"\\\~]      -> StringChar
    [0-9a-fA-F]                  -> HexPart
    "\\u" HexPart HexPart HexPart HexPart  -> StringChar

  lexical restrictions
    StringLex
    StringLexInterp -/- ~[\"\n\~]

  lexical syntax
    [\ \t\n\r]                   -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | Eof) -> LAYOUT
    "/*" CommentChar* "*/"       -> LAYOUT
                                 -> Eof
    ~[\*]                        -> CommentChar
    Asterisk                     -> CommentChar
    [\*]                         -> Asterisk

  lexical restrictions
    Asterisk   -/- [\/]
    Eof        -/- ~[]

  context-free restrictions
    LAYOUT?     -/- [\ \t\n\r]
    LAYOUT?     -/- [\/].[\/]
    LAYOUT?     -/- [\/].[\*]
    SectionName -/- ~[\n\r]

  lexical syntax
    ~[\ \t\n\r\}]+ -> Word
  lexical restrictions
     Word -/- ~[\ \t\n\r\}]

  context-free restrictions
    "page" "local" "email" "feed" "template" "schedule" -/- [a-zA-Z0-9]

module WebDSL

imports
  WebDSL-Lexical
  WebDSL-Keywords
  WebDSL-UI
  WebDSL-Ajax
  WebDSL-Action
  WebDSL-DataModel
  WebDSL-DataValidation
  WebDSL-AccessControl
  WebDSL-XML
  WebDSL-JavaScript
  WebDSL-CSS
  WebDSL-Regex
  WebDSL-Enums
  WebDSL-Expand
  WebDSL-Native
  WebDSL-Exception
  WebDSL-Type
  WebDSL-Test
  WebDSL-TimeInterval
  WebDSL-Service
  WebDSL-Search
  WebDSL-Prefetch
  WebDSL-Routing
  WebDSL-Attributes
  WebDSL-EntityDerive

hiddens
  context-free start-symbols
    Unit

exports

  sorts
    Id QId Int ModuleName SectionHeader Float FloatDigits ExponentPart
    SignedInteger String UNDEFINED Eof


  context-free syntax
    Id         -> QId
    QId "." Id -> QId {cons("Qualified")}

  context-free syntax %% Types
    SimpleSort   -> Sort
    GenericSort  -> Sort
    RefSort      -> Sort
    ListSort     -> Sort
    SetSort      -> Sort
    FunctionSort -> Sort

    Id                     -> SimpleSort {cons("SimpleSort")}
    Id "<" {Sort ","}+ ">" -> GenericSort {cons("GenericSort")}
    "Ref" "<" Sort ">"     -> RefSort {cons("RefSort")}
    "ref" Sort             -> RefSort {cons("RefSort")}
    "Ref" "<" Sort ">"     -> GenericSort {reject}

    %% List type '[Type]' and Set type '{Type}' notation
    "[" Sort "]" -> ListSort {ast("GenericSort(\"List\",[<1>])")}
    "{" Sort "}" -> SetSort  {ast("GenericSort(\"Set\",[<1>])")}

    %% function type; optionally specify (named) args and return type
    "function" FunctionSortParams FunctionSortReturn -> FunctionSort {cons("FunctionSort")}
    -> FunctionSortParams {ast("[]")}
    "(" {FunctionSortParam ","}* ")" -> FunctionSortParams {ast("<1>")}
    Sort -> FunctionSortParam {cons("UnnamedArg")}
    Id ":" Sort -> FunctionSortParam {cons("Arg")}
    -> FunctionSortReturn {ast("SimpleSort(\"Void\")")}
    ":" Sort -> FunctionSortReturn {ast("<1>")}
     "function" -> SimpleSort {reject}


    Id ":" Sort            -> FormalArg {cons("Arg")}

exports

  sorts Application Module Unit

  syntax

    "section" <SectionName-CF> <LAYOUT?-CF> <Definition*-CF> -> <Section-CF> {cons("Section")}

  context-free syntax

    "application" QId Definition+ Section* -> Application {cons("ApplicationDefs")}
    "application" QId Section*      -> Application {cons("Application")}

    "description" "{" Word* "}"     -> Description {cons("Description")}

    "note" "{" Word* "}"            -> Description {cons("Note")}

    Description                   -> Definition
    %%Description                   -> Definition {prefer}

    "module" ModuleName Section*  -> Module {cons("Module")}
    "module" ModuleName Definition+ Section*  -> Module {cons("ModuleDefs")}

    "imports" ModuleName          -> Definition {cons("Imports")}

    Application                   -> Unit
    Module                        -> Unit

exports

  sorts Action Statements Statement Exp

  context-free syntax

    Action		       	        -> Definition
    Statement*		   	        -> Statements
    NativeClassDeclaration      -> Definition

