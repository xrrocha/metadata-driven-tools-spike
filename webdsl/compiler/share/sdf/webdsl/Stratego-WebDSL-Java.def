definition
module languages/java-15/expressions/Priorities
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/expressions/Main

exports
  context-free priorities
      Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr
    > {right:
        Expr "++" -> Expr
        Expr "--" -> Expr
      } 

  context-free priorities
      {right:
        Expr "++" -> Expr
        Expr "--" -> Expr
      }
    > { "(" PrimType ")" Expr -> Expr    
        "(" RefType  ")" Expr -> Expr
      }

  context-free priorities
      "(" PrimType ")" Expr -> Expr
    > {left:
        Expr "*" Expr -> Expr
        Expr "/" Expr -> Expr
        Expr "%" Expr -> Expr
      } 

  context-free priorities
      "(" RefType ")" Expr -> Expr 
    > {
        "++" Expr -> Expr
        "--" Expr -> Expr
        "+"  Expr -> Expr
        "-"  Expr -> Expr
      }

  context-free priorities
    {
      Expr ArraySubscript -> ArrayAccess
      Expr "." Id -> FieldAccess
      Expr "." TypeArgs? Id -> MethodSpec
    }
  > {right:
      Expr "++" -> Expr
      Expr "--" -> Expr
    }
  > {
      "++" Expr -> Expr
      "--" Expr -> Expr
      "+"  Expr -> Expr
      "-"  Expr -> Expr
      "~"  Expr -> Expr
      "!"  Expr -> Expr
    }
  > {left:
      Expr "*" Expr -> Expr
      Expr "/" Expr -> Expr
      Expr "%" Expr -> Expr
    } 
  > {left:
      Expr "+" Expr -> Expr
      Expr "-" Expr -> Expr
    }
  > {left:
      Expr "<<"  Expr -> Expr
      Expr ">>"  Expr -> Expr
      Expr ">>>" Expr -> Expr
    }
  > {left:
      Expr "instanceof" RefType -> Expr
      Expr "<"   Expr -> Expr
      Expr ">"   Expr -> Expr
      Expr "<="  Expr -> Expr
      Expr ">="  Expr -> Expr
    }
  > {left:
      Expr "=="  Expr -> Expr
      Expr "!="  Expr -> Expr
    }
  >   Expr "&"   Expr -> Expr
  >   Expr "^"   Expr -> Expr
  >   Expr "|"   Expr -> Expr
  >   Expr "&&"  Expr -> Expr
  >   Expr "||"  Expr -> Expr
  >   Expr CondMid Expr -> Expr
  > {right:
      LHS "="    Expr -> Expr
      LHS "*="   Expr -> Expr
      LHS "/="   Expr -> Expr
      LHS "%="   Expr -> Expr
      LHS "+="   Expr -> Expr
      LHS "-="   Expr -> Expr
      LHS "<<="  Expr -> Expr
      LHS ">>="  Expr -> Expr
      LHS ">>>=" Expr -> Expr
      LHS "&="   Expr -> Expr
      LHS "^="   Expr -> Expr
      LHS "|="   Expr -> Expr
    }

module languages/java-15/expressions/Restrictions
exports
  lexical restrictions
    "+" -/- [\+]
    "-" -/- [\-]
    "/" -/- [\/]

module languages/java-15/expressions/AssignmentOperators
imports
  languages/java-15/expressions/Main

exports
  sorts LHS
  context-free syntax
    LHS "="    Expr -> Expr {cons("Assign")}
    LHS "*="   Expr -> Expr {cons("AssignMul")}
    LHS "/="   Expr -> Expr {cons("AssignDiv")}
    LHS "%="   Expr -> Expr {cons("AssignRemain")}
    LHS "+="   Expr -> Expr {cons("AssignPlus")}
    LHS "-="   Expr -> Expr {cons("AssignMinus")}
    LHS "<<="  Expr -> Expr {cons("AssignLeftShift")}
    LHS ">>="  Expr -> Expr {cons("AssignRightShift")}
    LHS ">>>=" Expr -> Expr {cons("AssignURightShift")}
    LHS "&="   Expr -> Expr {cons("AssignAnd")}
    LHS "^="   Expr -> Expr {cons("AssignExcOr")}
    LHS "|="   Expr -> Expr {cons("AssignOr")}

    ExprName    -> LHS
    FieldAccess -> LHS
    ArrayAccess -> LHS


module languages/java-15/expressions/BinaryOperators
imports
  languages/java-15/expressions/Main
  languages/java-15/types/Main

exports
  sorts CondMid
  context-free syntax
    Expr "instanceof" RefType -> Expr {cons("InstanceOf")}

    Expr "*"   Expr -> Expr  {left, cons("Mul")}
    Expr "/"   Expr -> Expr  {left, cons("Div")}
    Expr "%"   Expr -> Expr  {left, cons("Remain")}

    Expr "+"   Expr -> Expr  {left, cons("Plus")}
    Expr "-"   Expr -> Expr  {left, cons("Minus")}

    Expr "<<"  Expr -> Expr  {left, cons("LeftShift")}
    Expr ">>"  Expr -> Expr  {left, cons("RightShift")}
    Expr ">>>" Expr -> Expr  {left, cons("URightShift")}

    Expr "<"   Expr -> Expr  {left, cons("Lt")}
    Expr ">"   Expr -> Expr  {left, cons("Gt")}
    Expr "<="  Expr -> Expr  {left, cons("LtEq")}
    Expr ">="  Expr -> Expr  {left, cons("GtEq")}
    Expr "=="  Expr -> Expr  {left, cons("Eq")}
    Expr "!="  Expr -> Expr  {left, cons("NotEq")}

    Expr "&&"  Expr -> Expr  {left, cons("LazyAnd")}
    Expr "||"  Expr -> Expr  {left, cons("LazyOr")}

    Expr "&" Expr -> Expr {left, cons("And")}
    Expr "^" Expr -> Expr {left, cons("ExcOr")}
    Expr "|" Expr -> Expr {left, cons("Or")}

    %% todo JFR-30
    Expr CondMid Expr -> Expr {right, cons("Cond")}
    "?" Expr ":" -> CondMid {bracket}

module languages/java-15/expressions/UnaryOperators
imports 
  languages/java-15/expressions/Main
exports
  context-free syntax
    "+" Expr -> Expr {cons("Plus")}
    "-" Expr -> Expr {cons("Minus")}

    "++" Expr -> Expr {cons("PreIncr")}
    "--" Expr -> Expr {cons("PreDecr")}

    "~" Expr -> Expr {cons("Complement")}
    "!" Expr -> Expr {cons("Not")}

    "(" PrimType ")" Expr -> Expr {cons("CastPrim")}
    "(" RefType  ")" Expr -> Expr {cons("CastRef")}

module languages/java-15/expressions/Postfix
imports 
  languages/java-15/expressions/Main

exports
  context-free syntax
    ExprName  -> Expr
    Expr "++" -> Expr {cons("PostIncr")}
    Expr "--" -> Expr {cons("PostDecr")}

module languages/java-15/expressions/MethodInvocation
imports
  languages/java-15/expressions/Main

exports
  sorts MethodSpec
  context-free syntax
    MethodSpec "(" {Expr ","}* ")" -> Expr {cons("Invoke")}

                               MethodName -> MethodSpec {cons("Method")}
                    Expr "." TypeArgs? Id -> MethodSpec {cons("Method")}
                 "super" "." TypeArgs? Id -> MethodSpec {cons("SuperMethod")}
    TypeName "." "super" "." TypeArgs? Id -> MethodSpec {cons("QSuperMethod")}
                 AmbName "." TypeArgs  Id -> MethodSpec {cons("GenericMethod")}

  %% This priority forbids a Expr "." MethodSpec if the expression is a plain ExprName.
  %% This solves an ambiguity with the MethodName and AmbName . TypeArgs MethodSpecs.
  %% foo.bar.fred() results in a MethodName MethodSpec.
  %% (foo.bar).fred() results in the Expr. MethodSpec
  %% foo.bar.<T>fred() results in a GenericMethod
  context-free priorities
      Expr "." TypeArgs? Id -> MethodSpec
    > ExprName  -> Expr


module languages/java-15/expressions/ArrayAccess
imports
  languages/java-15/expressions/Main
exports
  sorts
    ArrayAccess
    ArraySubscript

  context-free syntax
    ArrayAccess -> Expr

    %% todo: JFR-29
    Expr ArraySubscript -> ArrayAccess {cons("ArrayAccess")}
    "[" Expr "]" -> ArraySubscript {bracket}

    ArrayCreationExpr ArraySubscript -> ArrayAccess {reject}

module languages/java-15/expressions/FieldAccess
imports
  languages/java-15/expressions/Main

exports
  sorts FieldAccess
  context-free syntax
    FieldAccess -> Expr

  context-free syntax

                    Expr "." Id -> FieldAccess {cons("Field")}
                ExprName "." Id -> FieldAccess {reject}
                 "super" "." Id -> FieldAccess {cons("SuperField")}
    TypeName "." "super" "." Id -> FieldAccess {cons("QSuperField")}

module languages/java-15/expressions/ArrayCreation
imports
  languages/java-15/expressions/Main

exports
  sorts
    ArrayCreationExpr
    ArrayBaseType
    Dim
    DimExpr

  context-free syntax
    ArrayCreationExpr     -> Expr

    "new" ArrayBaseType DimExpr+ Dim*  -> ArrayCreationExpr {cons("NewArray")}
    "new" ArrayBaseType Dim+ ArrayInit -> ArrayCreationExpr {cons("NewArray")}

    PrimType -> ArrayBaseType
    TypeName -> ArrayBaseType
    TypeName "<" "?" ">" -> ArrayBaseType {cons("UnboundWld")}

    "[" Expr "]" -> DimExpr {cons("Dim")}
    "[" "]"      -> Dim     {cons("Dim")}

module languages/java-15/expressions/ClassInstanceCreation
imports
  languages/java-15/expressions/Main
  languages/java-15/classes/ClassDeclarations

exports
  context-free syntax

             "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")" ClassBody? -> Expr {cons("NewInstance")}
    Expr "." "new" TypeArgs? Id         TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr {cons("QNewInstance")}

module languages/java-15/expressions/Primary
imports
  languages/java-15/lexical/literals/Main
  languages/java-15/names/Main
  languages/java-15/expressions/Main

exports
  %%%
   %% Section 15.8.1: Lexical Literals
   %%%
  sorts Literal
  context-free syntax
    Literal -> Expr {cons("Lit")}

    IntLiteral    -> Literal
    FloatLiteral  -> Literal
    BoolLiteral   -> Literal 
    CharLiteral   -> Literal
    StringLiteral -> Literal
    NullLiteral   -> Literal

  %%%
   %% Section 15.8.2: Class Literals
   %%%
  sorts ClassLiteral
  context-free syntax
    ClassLiteral -> Literal
    Type   "." "class" -> ClassLiteral {cons("Class")}
    "void" "." "class" -> ClassLiteral {cons("VoidClass")}

  %%%
   %% Section 15.8.3/4: (Qualified this)
   %%%
  context-free syntax
                 "this" -> Expr {cons("This")}
    TypeName "." "this" -> Expr {cons("QThis")}

  %%%
   %% Section 15.8.5: Parenthesized Expression
   %%%
  context-free syntax
    "(" Expr ")"          -> Expr {bracket}

module languages/java-15/expressions/Main
imports
  languages/java-15/expressions/Primary
  languages/java-15/expressions/ClassInstanceCreation
  languages/java-15/expressions/ArrayCreation
  languages/java-15/expressions/FieldAccess
  languages/java-15/expressions/ArrayAccess
  languages/java-15/expressions/MethodInvocation
  languages/java-15/expressions/Postfix
  languages/java-15/expressions/UnaryOperators
  languages/java-15/expressions/BinaryOperators
  languages/java-15/expressions/AssignmentOperators
  languages/java-15/expressions/Restrictions
  languages/java-15/expressions/Priorities

exports
  sorts
    Expr

module languages/java-15/statements/Main
imports
  languages/java-15/statements/Blocks
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Statements


module languages/java-15/arrays/Main
imports
  languages/java-15/arrays/ArrayInitializers


module languages/java-15/interfaces/Main
imports
  languages/java-15/interfaces/InterfaceDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/AnnotationTypes
  languages/java-15/interfaces/Annotations


module languages/java-15/classes/Main
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/EnumDeclarations


module languages/java-15/packages/PackageDeclarations
imports
  languages/java-15/names/Main
  languages/java-15/interfaces/Annotations

exports
  sorts
    PackageDec

  context-free syntax
    Anno* "package" PackageName ";" -> PackageDec {cons("PackageDec")}

module languages/java-15/packages/ImportDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main

exports
  sorts
    ImportDec

  context-free syntax
    "import" TypeName                  ";"  -> ImportDec {cons("TypeImportDec")}
    "import" PackageName       "." "*" ";"  -> ImportDec {cons("TypeImportOnDemandDec")}
    "import" "static" TypeName "." Id  ";"  -> ImportDec {cons("StaticImportDec")}
    "import" "static" TypeName "." "*" ";"  -> ImportDec {cons("StaticImportOnDemandDec")}

module languages/java-15/interfaces/AnnotationTypes
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/EnumDeclarations
  languages/java-15/interfaces/InterfaceDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/ConstantDeclarations
  languages/java-15/interfaces/Annotations

exports
  sorts
    AnnoDec
    AnnoDecHead

  context-free syntax
    AnnoDecHead "{" AnnoElemDec* "}" -> AnnoDec {cons("AnnoDec")}
    (Anno | InterfaceMod)* "@" "interface" Id -> AnnoDecHead {cons("AnnoDecHead")}

  sorts
    AnnoElemDec
    DefaultVal

  context-free syntax
    AbstractMethodMod* Type Id "(" ")" DefaultVal? ";" -> AnnoElemDec {cons("AnnoMethodDec")}

    ConstantDec  -> AnnoElemDec
    ClassDec     -> AnnoElemDec
    InterfaceDec -> AnnoElemDec
    EnumDec      -> AnnoElemDec
    AnnoDec      -> AnnoElemDec
    ";"          -> AnnoElemDec {cons("Semicolon")}

    "default" ElemVal -> DefaultVal {cons("DefaultVal")}

module languages/java-15/interfaces/AbstractMethodDeclarations
imports
  languages/java-15/lexical/Modifiers
  languages/java-15/names/Main
  languages/java-15/types/Main
  languages/java-15/classes/MethodDeclarations

exports
  sorts
    AbstractMethodDec
    AbstractMethodMod

  context-free syntax
    (Anno | AbstractMethodMod)* TypeParams? ResultType
      Id "(" {FormalParam ","}* ")" Throws? ";" -> AbstractMethodDec {cons("AbstractMethodDec")}

    (Anno | AbstractMethodMod)* TypeParams? ResultType
      Id "(" {FormalParam ","}* ")" Dim+ Throws? ";" -> AbstractMethodDec {cons("DeprAbstractMethodDec")}

    Public   -> AbstractMethodMod
    Abstract -> AbstractMethodMod



module languages/java-15/interfaces/ConstantDeclarations
imports
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/classes/MethodDeclarations
  languages/java-15/interfaces/Annotations

exports
  sorts
    ConstantDec
    ConstantMod

  context-free syntax
    (Anno | ConstantMod)* Type {VarDec ","}+ ";" -> ConstantDec {cons("ConstantDec")}

    Public -> ConstantMod
    Static -> ConstantMod
    Final  -> ConstantMod


module languages/java-15/interfaces/InterfaceDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/names/Main
  languages/java-15/types/Main
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/MethodDeclarations
  languages/java-15/interfaces/ConstantDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/AnnotationTypes
  languages/java-15/interfaces/Annotations

exports
  sorts
    InterfaceDec
    InterfaceDecHead
    ExtendsInterfaces
    InterfaceMemberDec
    InterfaceMod

  context-free syntax
    AnnoDec -> InterfaceDec

    InterfaceDecHead "{" InterfaceMemberDec* "}" -> InterfaceDec {cons("InterfaceDec")}

    (Anno | InterfaceMod)* "interface" Id TypeParams? ExtendsInterfaces? -> InterfaceDecHead {cons("InterfaceDecHead")}
    "extends" {InterfaceType ","}+ -> ExtendsInterfaces {cons("ExtendsInterfaces")}

  context-free syntax
    ConstantDec       -> InterfaceMemberDec
    AbstractMethodDec -> InterfaceMemberDec
    ClassDec          -> InterfaceMemberDec
    InterfaceDec      -> InterfaceMemberDec
    ";"               -> InterfaceMemberDec {cons("Semicolon")}

  context-free syntax
    Public         -> InterfaceMod
    Protected      -> InterfaceMod
    Private        -> InterfaceMod
    Abstract       -> InterfaceMod
    Static         -> InterfaceMod
    StrictFP       -> InterfaceMod


module languages/java-15/classes/EnumDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/classes/ClassDeclarations

exports
  sorts
    EnumDec
    EnumDecHead
    EnumBody
    EnumConst
    EnumConstArgs
    EnumBodyDecs

  context-free syntax
    EnumDecHead EnumBody -> EnumDec {cons("EnumDec")}

    (Anno | ClassMod)* "enum" Id Interfaces? -> EnumDecHead {cons("EnumDecHead")}

    "{" {EnumConst ","}*     EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}
    "{" {EnumConst ","}* "," EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}

    Id EnumConstArgs? ClassBody?  -> EnumConst {cons("EnumConst")}
    "(" {Expr ","}* ")"  -> EnumConstArgs {bracket}

    ";" ClassBodyDec* -> EnumBodyDecs {cons("EnumBodyDecs")}

module languages/java-15/classes/ConstructorDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/interfaces/Annotations
  languages/java-15/statements/Main
  languages/java-15/expressions/Main

exports
  sorts
    ConstrDec
    ConstrBody
    ConstrHead
    ConstrInv

  context-free syntax
    ConstrHead ConstrBody ->  ConstrDec {cons("ConstrDec")}
    (Anno | ConstrMod)* TypeParams? Id "(" {FormalParam ","}* ")" Throws? -> ConstrHead {cons("ConstrDecHead")}


    "{" ConstrInv? BlockStm* "}" -> ConstrBody {cons("ConstrBody")}

             TypeArgs? "this"  "(" {Expr ","}* ")" ";" -> ConstrInv {cons("AltConstrInv")}
             TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("SuperConstrInv")}
    Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("QSuperConstrInv")}

  sorts ConstrMod
  context-free syntax  
    Public    -> ConstrMod
    Protected -> ConstrMod
    Private   -> ConstrMod


module languages/java-15/classes/StaticInitializers
imports
  languages/java-15/statements/Blocks

exports
  sorts
    StaticInit

  context-free syntax
    "static" Block -> StaticInit   {cons("StaticInit")}

module languages/java-15/classes/InstanceInitializers
imports
  languages/java-15/statements/Blocks

exports
  sorts
    InstanceInit

  context-free syntax
    Block -> InstanceInit {cons("InstanceInit")}

module languages/java-15/statements/Statements
imports
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Blocks
  languages/java-15/expressions/Main

exports
  sorts
    Stm

  context-free syntax
    Block      -> Stm

  %%%
   %% Section 14.6: The Empty Statement
   %%%
  context-free syntax
    ";"        -> Stm {cons("Empty")}

  %%%
   %% Section 14.7: Labeled Statements
   %%%
  context-free syntax
    Id ":" Stm -> Stm {cons("Labeled")}

  %%%
   %% Section 14.8: Expressions Statements
   %%%
  context-free syntax
    Expr ";"   -> Stm {cons("ExprStm")}

  %%%
   %% Section 14.9: The If Statement
   %%%
  context-free syntax
    "if" "(" Expr ")" Stm             -> Stm {prefer, cons("If")}
    "if" "(" Expr ")" Stm  "else" Stm -> Stm {cons("If")}

  %%%
   %% Section 14.10: The Assert Statement
   %%%
  context-free syntax
    "assert" Expr          ";" -> Stm  {cons("AssertStm")}
    "assert" Expr ":" Expr ";" -> Stm  {cons("AssertStm")}


  %%%
   %% Section 14.11: The Switch Statement
   %%%
  sorts SwitchBlock SwitchGroup SwitchLabel
  context-free syntax
    "switch" "(" Expr ")" SwitchBlock -> Stm {cons("Switch")}
    "{" SwitchGroup* SwitchLabel* "}" -> SwitchBlock {cons("SwitchBlock")}
    SwitchLabel+ BlockStm+ -> SwitchGroup  {cons("SwitchGroup")}

    "case" Expr ":" -> SwitchLabel {cons("Case")}
    "default"   ":" -> SwitchLabel {cons("Default")}

  %%%
   %% Section 14.12: The While Statement
   %%%
  context-free syntax
    "while" "(" Expr ")" Stm -> Stm {cons("While")}

  %%%
   %% Section 14.13: The Do Statement
   %%%
  context-free syntax
  "do" Stm "while" "(" Expr ")" ";" -> Stm {cons("DoWhile")}


  %%%
   %% Section 14.14: The For Statement
   %%%
  context-free syntax
    "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
    "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}

    "for" "(" FormalParam ":" Expr ")" Stm -> Stm {cons("ForEach")}

  %%%
   %% Section 14.15: The Break Statement
   %%%
  context-free syntax
    "break"    Id? ";"   -> Stm {cons("Break")}

  %%%
   %% Section 14.16: The Continue Statement
   %%%
  context-free syntax
    "continue" Id? ";"   -> Stm {cons("Continue")}

  %%%
   %% Section 14.17: The Return Statement
   %%%
  context-free syntax
    "return"   Expr? ";" -> Stm {cons("Return")}

  %%%
   %% Section 14.18: The Throw Statement
   %%%
  context-free syntax
    "throw"    Expr  ";" -> Stm {cons("Throw")}

  %%%
   %% Section 14.19: The Synchronized Statement
   %%%
  context-free syntax
    "synchronized" "(" Expr ")" Block -> Stm {cons("Synchronized")}

  %%%
   %% Section 14.20: The Try Statement
   %%%
  sorts CatchClause
  context-free syntax
    "try" Block CatchClause+ -> Stm {cons("Try")}
    "try" Block CatchClause* "finally" Block -> Stm {cons("Try")}
    "catch" "(" FormalParam ")" Block -> CatchClause {cons("Catch")}

module languages/java-15/statements/LocalVariableDeclarations
imports
  languages/java-15/classes/MethodDeclarations
  languages/java-15/classes/FieldDeclarations

exports
  sorts
    LocalVarDecStm
    LocalVarDec

  context-free syntax
    LocalVarDec ";" -> LocalVarDecStm {prefer, cons("LocalVarDecStm")}
    (Anno | VarMod)* Type {VarDec ","}+ -> LocalVarDec {prefer, cons("LocalVarDec")}

module languages/java-15/statements/Blocks
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Statements

exports
  sorts
    BlockStm
    Block

  context-free syntax
    "{" BlockStm* "}" -> Block {cons("Block")}

    LocalVarDecStm  -> BlockStm 
    ClassDec        -> BlockStm {cons("ClassDecStm")}
    Stm             -> BlockStm


module languages/java-15/classes/MethodDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/classes/FieldDeclarations
  languages/java-15/interfaces/Annotations
  languages/java-15/statements/Blocks

exports
  sorts
    MethodDec
    MethodDecHead
    ResultType

  context-free syntax
    MethodDecHead MethodBody -> MethodDec {cons("MethodDec")}

    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws?      -> MethodDecHead {cons("MethodDecHead")}
    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? -> MethodDecHead {cons("DeprMethodDecHead")}

    Type   -> ResultType
    "void" -> ResultType {cons("Void")}

  sorts FormalParam
  context-free syntax
    (Anno | VarMod)* Type       VarDecId -> FormalParam {cons("Param")}
    (Anno | VarMod)* Type "..." VarDecId -> FormalParam {cons("VarArityParam")}

  sorts VarMod
  context-free syntax
    Final -> VarMod

  sorts MethodMod
  context-free syntax
    Public         -> MethodMod
    Protected      -> MethodMod
    Private        -> MethodMod

    Abstract       -> MethodMod
    Static         -> MethodMod
    Final          -> MethodMod
    Synchronized   -> MethodMod
    Native         -> MethodMod
    StrictFP       -> MethodMod

  %%%
   %% Section 8.4.6: Method Throws
   %%%
  sorts
    Throws
    ExceptionType

  context-free syntax
    "throws" {ExceptionType ","}+ -> Throws {cons("ThrowsDec")}
    ClassType -> ExceptionType
    %% TypeVar -> ExceptionType

  %%%
   %% Section 8.4.7: Method Body
   %%% 
  sorts MethodBody
  context-free syntax
    Block -> MethodBody
    ";"   -> MethodBody {cons("NoMethodBody")}

module languages/java-15/arrays/ArrayInitializers
imports
  languages/java-15/classes/FieldDeclarations

exports
  sorts ArrayInit
  context-free syntax
    "{" {VarInit ","}*     "}" -> ArrayInit {cons("ArrayInit")}
    "{" {VarInit ","}* "," "}" -> ArrayInit {cons("ArrayInit")}

module languages/java-15/interfaces/Annotations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main
  languages/java-15/expressions/Main

exports
  sorts
    Anno
    ElemVal
    ElemValPair

  context-free syntax
    "@" TypeName "(" {ElemValPair ","}* ")" -> Anno {cons("Anno")}
    "@" TypeName "(" ElemVal ")"            -> Anno {cons("SingleElemAnno")}
    "@" TypeName                            -> Anno {cons("MarkerAnno")}

  context-free syntax  
    Id "=" ElemVal -> ElemValPair {cons("ElemValPair")}

    Expr -> ElemVal
    Anno -> ElemVal

    "{" {ElemVal ","}*     "}" -> ElemVal {cons("ElemValArrayInit")}
    "{" {ElemVal ","}* "," "}" -> ElemVal {cons("ElemValArrayInit")}

    %% Assignments are not allowed as element values.
    LHS "=" Expr -> ElemVal {reject}

module languages/java-15/classes/FieldDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/interfaces/Annotations
  languages/java-15/arrays/ArrayInitializers
  languages/java-15/expressions/Main

exports
  sorts
    FieldDec
    VarDec
    VarDecId
    Dim
    VarInit

  context-free syntax
    (Anno | FieldMod)* Type { VarDec ","}+ ";" -> FieldDec {cons("FieldDec")}

    VarDecId             -> VarDec {cons("VarDec")}
    VarDecId "=" VarInit -> VarDec {cons("VarDec")}

    Id      -> VarDecId
    Id Dim+ -> VarDecId {cons("ArrayVarDecId")}

    "[" "]" -> Dim {cons("Dim")}

    Expr      -> VarInit
    ArrayInit -> VarInit

  sorts FieldMod
  context-free syntax
    Public    -> FieldMod
    Protected -> FieldMod
    Private   -> FieldMod

    Static    -> FieldMod
    Final     -> FieldMod
    Transient -> FieldMod
    Volatile  -> FieldMod


module languages/java-15/classes/ClassDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/ReferenceTypes
  languages/java-15/types/TypeVariables
  languages/java-15/classes/FieldDeclarations
  languages/java-15/classes/MethodDeclarations
  languages/java-15/classes/InstanceInitializers
  languages/java-15/classes/StaticInitializers
  languages/java-15/classes/ConstructorDeclarations
  languages/java-15/classes/EnumDeclarations
  languages/java-15/interfaces/InterfaceDeclarations

exports
  sorts
    ClassDec
    ClassBody
    ClassDecHead

  context-free syntax
    EnumDec -> ClassDec

    ClassDecHead ClassBody -> ClassDec {cons("ClassDec")}
    "{" ClassBodyDec* "}" -> ClassBody {cons("ClassBody")}

    (Anno | ClassMod)* "class" Id  TypeParams? Super? Interfaces? -> ClassDecHead {cons("ClassDecHead")}

  %% 8.1.1: Class Modifiers
  sorts ClassMod
  context-free syntax
    Abstract  -> ClassMod
    Public    -> ClassMod
    Protected -> ClassMod
    Private   -> ClassMod
    Static    -> ClassMod
    Final     -> ClassMod
    StrictFP  -> ClassMod

  %% 8.1.4: Superclasses and Subclasses
  sorts Super
  context-free syntax

    "extends" ClassType -> Super {cons("SuperDec")}

  %% 8.1.5: Superinterfaces
  sorts Interfaces
  context-free syntax
    "implements" {InterfaceType ","}+ -> Interfaces {cons("ImplementsDec")}


  %% 8.1.6: Class Body and Member Declarations
  sorts
    ClassBodyDec
    ClassMemberDec

  context-free syntax
    ClassMemberDec -> ClassBodyDec
    InstanceInit   -> ClassBodyDec
    StaticInit     -> ClassBodyDec
    ConstrDec      -> ClassBodyDec

  context-free syntax
    FieldDec     -> ClassMemberDec
    MethodDec    -> ClassMemberDec
    ClassDec     -> ClassMemberDec
    InterfaceDec -> ClassMemberDec
    ";"          -> ClassMemberDec {cons("Semicolon")}

module languages/java-15/packages/TypeDeclarations
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/interfaces/InterfaceDeclarations

exports
  sorts
    TypeDec

  context-free syntax
    ClassDec      -> TypeDec
    InterfaceDec  -> TypeDec
    ";"           -> TypeDec {cons("Semicolon")}

module languages/java-15/packages/CompilationUnits
imports
  languages/java-15/packages/PackageDeclarations
  languages/java-15/packages/ImportDeclarations
  languages/java-15/packages/TypeDeclarations

exports
  sorts
    CompilationUnit

  context-free syntax
    PackageDec? ImportDec* TypeDec+ -> CompilationUnit   {cons("CompilationUnit")}

module languages/java-15/packages/Main
imports
  languages/java-15/packages/CompilationUnits
  languages/java-15/packages/ImportDeclarations
  languages/java-15/packages/PackageDeclarations


module languages/java-15/names/Main
imports
  languages/java-15/lexical/Identifiers
exports
  sorts PackageName
  context-free syntax
    {Id "."}+ -> PackageName {cons("PackageName")}

  sorts
    TypeName
    ExprName
    MethodName
    PackageOrTypeName
    AmbName

  context-free syntax
    Id             -> AmbName {cons("AmbName")}
    AmbName "." Id -> AmbName {cons("AmbName")}

    Id                       -> TypeName {cons("TypeName")}
    PackageOrTypeName "." Id -> TypeName {cons("TypeName")}

    Id             -> ExprName {cons("ExprName")}
    AmbName "." Id -> ExprName {cons("ExprName")}

    Id             -> MethodName  {cons("MethodName")}
    AmbName "." Id -> MethodName  {cons("MethodName")}

    Id                       -> PackageOrTypeName {cons("PackageOrTypeName")}
    PackageOrTypeName "." Id -> PackageOrTypeName {cons("PackageOrTypeName")}

module languages/java-15/types/ParameterizedTypes
imports
  languages/java-15/types/ReferenceTypes

exports
  sorts
    TypeArgs
    ActualTypeArg
    WildcardBound
    
  context-free syntax
    "<" {ActualTypeArg ","}+ ">" -> TypeArgs {cons("TypeArgs")}

    Type               -> ActualTypeArg
    "?" WildcardBound? -> ActualTypeArg {cons("Wildcard")}

    "extends" RefType -> WildcardBound {cons("WildcardUpperBound")}
    "super"   RefType -> WildcardBound {cons("WildcardLowerBound")}

module languages/java-15/types/TypeVariables
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/types/ReferenceTypes

exports
  sorts
    TypeParams
    TypeParam
    TypeBound
    TypeVarId
  
  context-free syntax
    TypeVarId TypeBound? -> TypeParam {cons("TypeParam")}
    
    "extends" {ClassOrInterfaceType "&"}+ -> TypeBound {cons("TypeBound")}
    "<" {TypeParam ","}+ ">" -> TypeParams {cons("TypeParams")}

    Id -> TypeVarId
    

module languages/java-15/types/ReferenceTypes
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main
  languages/java-15/types/Main  
  languages/java-15/types/ParameterizedTypes
  languages/java-15/types/TypeVariables


exports
  sorts
    RefType
    ClassOrInterfaceType
    ClassType
    InterfaceType
    TypeDecSpec
    ArrayType
    TypeVar

  context-free syntax
    ClassOrInterfaceType -> RefType
    ArrayType            -> RefType
    
    %% This production rule is highly ambiguous, since every
    %% TypeVar can be a ClassOrInterfaceType. A later disambiguation
    %% phase has to find out if a ClassOrInterfaceType is in fact
    %% a TypeVar.
    
    %% TypeVar -> RefType {avoid}

  context-free syntax
  
    %% ClassType and InterfaceType are ambiguous. We modify the
    %% production of ClassOrInterfaceType to make this ambiguity explicit.
    
    TypeDecSpec TypeArgs? -> ClassOrInterfaceType {cons("ClassOrInterfaceType")}
    TypeDecSpec TypeArgs? -> ClassType {cons("ClassType")}
    TypeDecSpec TypeArgs? -> InterfaceType {cons("InterfaceType")}

    TypeName -> TypeDecSpec
    TypeDecSpec TypeArgs "." Id -> TypeDecSpec {cons("Member")}
    
  context-free syntax    
    TypeVarId -> TypeVar {cons("TypeVar")}

  context-free syntax
    Type "[" "]" -> ArrayType  {cons("ArrayType")}

module languages/java-15/types/PrimitiveTypes
exports
  sorts
    PrimType
    NumType
    IntType  
    FloatType

  context-free syntax
    NumType   -> PrimType
    "boolean" -> PrimType {cons("Boolean")}

    IntType   -> NumType
    FloatType -> NumType

    "byte"   -> IntType   {cons("Byte")}
    "short"  -> IntType   {cons("Short")}
    "int"    -> IntType   {cons("Int")}
    "long"   -> IntType   {cons("Long")}
    "char"   -> IntType   {cons("Char")}
    "float"  -> FloatType {cons("Float")}
    "double" -> FloatType {cons("Double")}

module languages/java-15/types/Main
imports
  languages/java-15/types/PrimitiveTypes
  languages/java-15/types/ReferenceTypes
  languages/java-15/types/TypeVariables
  languages/java-15/types/ParameterizedTypes

exports
  sorts
    Type

  context-free syntax
    PrimType -> Type
    RefType  -> Type


module languages/java-15/lexical/literals/NullLiteral
exports
  sorts NullLiteral
  context-free syntax
    "null"  -> NullLiteral {cons("Null")}

module languages/java-15/lexical/literals/StringLiterals
imports
  languages/java-15/lexical/literals/EscapeSequences
  languages/java-15/lexical/UnicodeEscapes

exports
  sorts
    StringLiteral
    StringPart
    StringChars
    FooStringChars

  syntax
    StringLiteral -> <StringLiteral-CF>
    
    "\"" StringPart* "\"" -> StringLiteral {cons("String")}
    StringChars    -> StringPart {cons("Chars")}
    UnicodeEscape  -> StringPart
    EscapeSeq      -> StringPart

    <FooStringChars-LEX> -> StringChars
    ~[\"\\\n\13]+  -> <FooStringChars-LEX>

  restrictions
    StringChars -/- ~[\"\\\n\13]

module languages/java-15/lexical/literals/EscapeSequences
imports

exports
  sorts
    EscapeSeq
    NamedEscape
    OctaEscape
    LastOcta

  syntax
    OctaEscape  -> EscapeSeq
    NamedEscape -> EscapeSeq

    "\\" [btnfr\"\'\\]     -> NamedEscape {cons("NamedEscape")}
    "\\" LastOcta          -> OctaEscape  {cons("OctaEscape1")}
    "\\" [0-3] LastOcta    -> OctaEscape  {cons("OctaEscape2")}
    "\\" [4-7] [0-7]       -> OctaEscape  {cons("OctaEscape2")}
    "\\" [0-3] [0-7] [0-7] -> OctaEscape  {cons("OctaEscape3")}

    [0-7] -> LastOcta

  restrictions
    LastOcta -/- [0-7]

module languages/java-15/lexical/literals/CharacterLiterals
imports
  languages/java-15/lexical/literals/EscapeSequences
  languages/java-15/lexical/UnicodeEscapes

exports
  sorts
    CharLiteral
    CharContent
    SingleChar

  syntax
    CharLiteral   -> <CharLiteral-CF>

    "'" CharContent "'" -> CharLiteral {cons("Char")}
    SingleChar    -> CharContent {cons("Single")}
    UnicodeEscape -> CharContent
    EscapeSeq     -> CharContent

    ~[\r\n\'\\] -> SingleChar


module languages/java-15/lexical/literals/BooleanLiterals
exports
  sorts
    Bool
    BoolLiteral

  context-free syntax
    Bool -> BoolLiteral {cons("Bool")}
    "true"  -> Bool {cons("True")}
    "false" -> Bool {cons("False")}

module languages/java-15/lexical/literals/FloatingPointLiterals
exports
  sorts
    FloatLiteral
    DeciFloatLiteral
    HexaFloatLiteral      
  
  context-free syntax
    DeciFloatLiteral -> FloatLiteral {cons("Float")}
    HexaFloatLiteral -> FloatLiteral {cons("Float")}

  lexical syntax
    DeciFloatNumeral [fFdD]? -> DeciFloatLiteral
    HexaFloatNumeral [fFdD]? -> HexaFloatLiteral
    
    %% Reject plain integer literals as decimal float literals.
    %% A similar rejection for hexadecimal float literals is not
    %% required, since these always contain an exponent part.
    [0-9]+ -> DeciFloatLiteral {reject}

  lexical restrictions
    DeciFloatLiteral -/- [fFdD]
    HexaFloatLiteral -/- [fFdD]

  %%%
   %% Decimal Floating Point Numerals
   %%%
  sorts
    DeciFloatNumeral
    DeciFloatDigits
    DeciFloatExponentPart

  lexical syntax
    DeciFloatDigits DeciFloatExponentPart? -> DeciFloatNumeral

    [0-9]* "." [0-9]* -> DeciFloatDigits
           "."        -> DeciFloatDigits {reject}
    [0-9]+            -> DeciFloatDigits

    [eE] SignedInteger -> DeciFloatExponentPart
    
    [\+\-]? [0-9]+ -> SignedInteger    

  lexical restrictions
    DeciFloatDigits  -/- [0-9]
    DeciFloatExponentPart -/- [0-9]

  %%%
   %% Hexadecimal Floating Point Literals
   %%%
  sorts
    HexaFloatNumeral
    HexaSignificand
    BinaryExponent
    SignedInteger
    
  lexical syntax
    HexaSignificand BinaryExponent -> HexaFloatNumeral

    [0][xX] [0-9a-fA-F]+                  -> HexaSignificand
    [0][xX] [0-9a-fA-F]* "." [0-9a-fA-F]* -> HexaSignificand
    [0][xX]              "."              -> HexaSignificand {reject}

    [pP] SignedInteger -> BinaryExponent
  lexical restrictions
    HexaSignificand -/- [0-9a-fA-F]
    SignedInteger   -/- [0-9]

module languages/java-15/lexical/literals/IntegerLiterals
exports
  sorts
    IntLiteral
    DeciLiteral
    HexaLiteral
    OctaLiteral
    DeciNumeral
    HexaNumeral
    OctaNumeral

  context-free syntax
    DeciLiteral -> IntLiteral {cons("Deci")}
    HexaLiteral -> IntLiteral {cons("Hexa")}
    OctaLiteral -> IntLiteral {cons("Octa")}

  lexical syntax
    DeciNumeral [lL]? -> DeciLiteral
    HexaNumeral [lL]? -> HexaLiteral
    OctaNumeral [lL]? -> OctaLiteral

    "0" -> DeciNumeral
    [1-9][0-9]*  -> DeciNumeral
    [0][xX] [0-9a-fA-F]+ -> HexaNumeral
    [0]     [0-7]+       -> OctaNumeral

  lexical restrictions
    DeciNumeral -/- [0-9\.fFdD]
    HexaNumeral -/- [0-9a-fA-F]
    OctaNumeral -/- [0-7]

    DeciLiteral -/- [lL]
    HexaLiteral -/- [lL]
    OctaLiteral -/- [lL]

module languages/java-15/lexical/literals/Main
imports
  languages/java-15/lexical/literals/IntegerLiterals
  languages/java-15/lexical/literals/FloatingPointLiterals
  languages/java-15/lexical/literals/BooleanLiterals  
  languages/java-15/lexical/literals/CharacterLiterals  
  languages/java-15/lexical/literals/StringLiterals
  languages/java-15/lexical/literals/NullLiteral


module languages/java-15/lexical/Modifiers
exports
  sorts
    Public
    Private
    Protected
    Abstract
    Final
    Static
    Native
    Transient
    Volatile
    Synchronized
    StrictFP
    Modifier

  context-free syntax
    "public"       -> Public       {cons("Public")}
    "private"      -> Private      {cons("Private")}
    "protected"    -> Protected    {cons("Protected")}

    "abstract"     -> Abstract     {cons("Abstract")}
    "final"        -> Final        {cons("Final")}
    "static"       -> Static       {cons("Static")}
    "native"       -> Native       {cons("Native")}
    "transient"    -> Transient    {cons("Transient")}
    "volatile"     -> Volatile     {cons("Volatile")}
    "synchronized" -> Synchronized {cons("Synchronized")}
    "strictfp"     -> StrictFP     {cons("StrictFP")}

    Public       -> Modifier
    Private      -> Modifier
    Protected    -> Modifier
    Abstract     -> Modifier
    Final        -> Modifier
    Static       -> Modifier
    Native       -> Modifier
    Transient    -> Modifier
    Volatile     -> Modifier
    Synchronized -> Modifier
    StrictFP     -> Modifier


module languages/java-15/lexical/Keywords
exports
  sorts Keyword
  lexical syntax
    "abstract"      -> Keyword
    "assert"        -> Keyword
    "boolean"       -> Keyword
    "break"         -> Keyword
    "byte"          -> Keyword
    "case"          -> Keyword
    "catch"         -> Keyword
    "char"          -> Keyword
    "class"         -> Keyword
    "const"         -> Keyword
    "continue"      -> Keyword
    "default"       -> Keyword
    "do"            -> Keyword
    "double"        -> Keyword
    "else"          -> Keyword
    "enum"          -> Keyword
    "extends"       -> Keyword
    "final"         -> Keyword
    "finally"       -> Keyword
    "float"         -> Keyword
    "for"           -> Keyword
    "goto"          -> Keyword
    "if"            -> Keyword
    "implements"    -> Keyword
    "import"        -> Keyword
    "instanceof"    -> Keyword
    "int"           -> Keyword
    "interface"     -> Keyword
    "long"          -> Keyword
    "native"        -> Keyword
    "new"           -> Keyword
    "package"       -> Keyword
    "private"       -> Keyword
    "protected"     -> Keyword
    "public"        -> Keyword
    "return"        -> Keyword
    "short"         -> Keyword
    "static"        -> Keyword
    "strictfp"      -> Keyword
    "super"         -> Keyword
    "switch"        -> Keyword
    "synchronized"  -> Keyword
    "this"          -> Keyword
    "throw"         -> Keyword
    "throws"        -> Keyword
    "transient"     -> Keyword
    "try"           -> Keyword
    "void"          -> Keyword
    "volatile"      -> Keyword
    "while"         -> Keyword

  lexical restrictions

    "abstract"
    "assert"
    "boolean" 
    "break"   
    "byte"    
    "case"    
    "catch"   
    "char"     
    "class"
    "const"    
    "continue" 
    "default"  
    "do"       
    "double"   
    "else"     
    "enum"
    "extends"  
    "final"     
    "finally"   
    "float"     
    "for"       
    "goto"       
    "if"         
    "implements" 
    "import"     
    "instanceof" 
    "int"        
    "interface"  
    "long"       
    "native"     
    "new"        
    "package"    
    "private"    
    "protected"   
    "public"       
    "return"       
    "short"        
    "static"     
    "strictfp"
    "super"        
    "switch"       
    "synchronized" 
    "this"         
    "throw"        
    "throws"       
    "transient"    
    "try"          
    "void"         
    "volatile"     
    "while"       -/- [A-Za-z0-9\_\$]

module languages/java-15/lexical/Identifiers
imports
  languages/java-15/lexical/Keywords
exports
  sorts
    Id
    ID

  context-free syntax
    ID -> Id {cons("Id")}

  lexical syntax
    [A-Za-z\_\$][A-Za-z0-9\_\$]* -> ID
    
    Keyword -> ID {reject}
    "true"  -> ID {reject}
    "false" -> ID {reject}
    "null"  -> ID {reject}

  lexical restrictions
    ID -/- [a-zA-Z0-9\_\$]

module languages/java-15/lexical/Comments
imports
  languages/java-15/lexical/LineTerminators
exports
  sorts
    Comment
    EOLCommentChars
    CommentPart
    UnicodeEscape
    BlockCommentChars
    Asterisk
    EscEscChar
    EscChar

  lexical syntax
    Comment -> LAYOUT

    "//" EOLCommentChars LineTerminator -> Comment
    ~[\n\r]* -> EOLCommentChars

    "/*"  CommentPart* "*/" -> Comment
    "/**" CommentPart* "*/" -> Comment
    "/**/"                  -> Comment %% Strange javadoc comment

    BlockCommentChars -> CommentPart
    EscChar           -> CommentPart
    EscEscChar        -> CommentPart
    Asterisk          -> CommentPart
    UnicodeEscape     -> CommentPart

    ~[\*\\]+ -> BlockCommentChars

    "*"    -> Asterisk
    "\\\\" -> EscEscChar
    "\\"   -> EscChar

    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape

  lexical restrictions
    "/**"    -/- [\/]
    "/*"     -/- [\*]
    Asterisk -/- [\/]
    EscChar  -/- [\\u]

    BlockCommentChars -/- ~[\*\\]
    EOLCommentChars   -/- ~[\n\13]

  context-free restrictions
    LAYOUT?  -/- [\/].[\*]
    LAYOUT?  -/- [\/].[\/]

module languages/java-15/lexical/WhiteSpace
exports
  lexical syntax
    [\ \t\12\r\n] -> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\12\n\r]

module languages/java-15/lexical/LineTerminators
exports
  sorts
    LineTerminator CarriageReturn EndOfFile

  lexical syntax
    [\n]           -> LineTerminator
    [\r][\n]       -> LineTerminator
    CarriageReturn -> LineTerminator
    EndOfFile      -> LineTerminator

    [\r] -> CarriageReturn

  lexical restrictions
    CarriageReturn -/- [\n]

  %% End of file is empty.
  lexical syntax    
    -> EndOfFile

  lexical restrictions
    EndOfFile -/- ~[]

module languages/java-15/lexical/UnicodeEscapes
exports
  sorts
    UnicodeEscape

  syntax
    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape {cons("UnicodeEscape")}

module languages/java-15/lexical/Main
imports
  languages/java-15/lexical/UnicodeEscapes
  languages/java-15/lexical/LineTerminators
  languages/java-15/lexical/WhiteSpace
  languages/java-15/lexical/Comments
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Keywords
  languages/java-15/lexical/Modifiers
  languages/java-15/lexical/literals/Main

module languages/java-15/Main
imports
  languages/java-15/lexical/Main
  languages/java-15/types/Main
  languages/java-15/names/Main
  languages/java-15/packages/Main
  languages/java-15/classes/Main
  languages/java-15/interfaces/Main
  languages/java-15/arrays/Main
  languages/java-15/statements/Main
  languages/java-15/expressions/Main


module languages/java/EmbeddedJava[E]
imports
  languages/java-15/Main

exports
  variables
    [ij]  [0-9\']*            -> DeciLiteral {prefer}
    [ij]  [\_] [a-zA-Z0-9\']* -> DeciLiteral {prefer}
    [xyz] [0-9\']*            -> ID          {prefer}
    [xyz] [\_] [a-zA-Z0-9\']* -> ID          {prefer}

  context-free restrictions
    ID -/- [\_a-zA-Z0-9\']

%%%
 %% Expressions
 %%%
exports

  %%%
   %% Variables for Expressions
   %%%
  variables
    "e"    [0-9\']*         -> Expr           {prefer}
    "e_" [a-zA-Z0-9\']*     -> Expr           {prefer}
    "e"    [0-9\']* "*"     -> {VarInit ","}* {prefer}
    "e_" [a-zA-Z0-9\']* "*" -> {VarInit ","}* {prefer}
    "e"    [0-9\']* "*"     -> {Expr ","}*    {prefer}
    "e_" [a-zA-Z0-9\']* "*" -> {Expr ","}*    {prefer}

  lexical syntax
    "e" [0-9\']*            -> ID {reject}
    "e_" [a-zA-Z0-9\']*     -> ID {reject}

  %%%
   %% Quotations for Expressions
   %%%
  context-free syntax
            "e" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
         "expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java"      "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
                "|[" Expr "]|"   -> E {cons("ToMetaExpr")}

    "var-init" "|[" VarInit "]|" -> E {cons("ToMetaExpr")}

%%%
 %% Statements
 %%%
exports

  %%%
   %% Variables for Statements
   %%%
  variables
    "stm"  [0-9\']*             -> Stm         {prefer}
    "stm_" [a-zA-Z0-9\']*       -> Stm         {prefer}
    "bstm" [0-9\']*             -> BlockStm    {prefer}
    "bstm_" [a-zA-Z0-9\']*      -> BlockStm    {prefer}
    "bstm" [0-9\']* "*"         -> BlockStm*   {prefer}    
    "bstm_" [a-zA-Z0-9\']* "*"  -> BlockStm*   {prefer}

  %%%
   %% Quotations for Statements
   %%%
  context-free syntax
    "java:bstm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
         "bstm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
    "java"       "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
                 "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}

    "java:bstm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
         "bstm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}

    "java:block-stm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
         "block-stm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
    "java"            "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
                      "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}

    "java:block-stm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
         "block-stm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}


    "java:stm"  "|[" Stm "]|" -> E {cons("ToMetaExpr")}
         "stm"  "|[" Stm "]|" -> E {cons("ToMetaExpr")}
         
         "switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}         
    "java:switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}
    
  %%%
   %% Anti Quotations for Statements
   %%%
  context-free syntax
    "~"       E  -> BlockStm  {cons("FromMetaExpr")}
    "~bstm:"  E  -> BlockStm  {cons("FromMetaExpr")}
    "~*"      E  -> BlockStm* {cons("FromMetaExpr")}
    "~bstm*:" E  -> BlockStm* {cons("FromMetaExpr")}

    "~stm:"   E  -> Stm {cons("FromMetaExpr"), prefer}
    "~"       E  -> Stm {cons("FromMetaExpr")}

    "~*"              E -> SwitchGroup* {cons("FromMetaExpr")}    
    "~switch-group*:" E -> SwitchGroup* {cons("FromMetaExpr")}    

    "~"               E -> SwitchGroup {cons("FromMetaExpr")}
    "~switch-group:"  E -> SwitchGroup {cons("FromMetaExpr")}

%%%
 %% Variable Declarations
 %%%

  %%%
   %% Variables for Variable Declarations
   %%%
  variables
    "lvdec" [0-9]*            -> LocalVarDec    {prefer}
    "lvdec_" [a-zA-Z0-9]*     -> LocalVarDec    {prefer}
     "vdec" [0-9]*            -> VarDec         {prefer}
     "vdec_" [a-zA-Z0-9]*     -> VarDec         {prefer}
     "vdec"  [0-9]* "*"       -> {VarDec ","}+  {prefer}
     "vdec_" [a-zA-Z0-9]* "*" -> {VarDec ","}+  {prefer}

  lexical syntax
    "lvdec"               -> ID {reject}
    "lvdec_" [a-zA-Z0-9]* -> ID {reject}
     "vdec"               -> ID {reject}
     "vdec_" [a-zA-Z0-9]* -> ID {reject}

  %%%
   %% Quotations for Local Variable Declarations
   %%%
  context-free syntax
    "java:lvdec"  "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}
         "lvdec"  "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}

    "java:vdec" "|[" VarDec "]|" -> E {cons("ToMetaExpr")}
         "vdec" "|[" VarDec "]|" -> E {cons("ToMetaExpr")}

  %%%
   %% Anti Quotations for Local Variable Declarations
   %%%
  context-free syntax

%%%
 %% LeftHandSide of Assignment
 %%%
exports

  %%%
   %% Variables for LeftHandSide of Assignment
   %%%
  variables
    "lhs" [0-9\']* -> LHS {prefer}
    "e"   [0-9\']* -> LHS {prefer}

  lexical syntax
    "lhs" [0-9\']* -> ID {reject}

%%%
 %% Types
 %%%
exports

  %%%
   %% Variables for Types
   %%%
  variables
    MetaTypeVar     -> Type     {prefer}
    MetaPrimTypeVar -> PrimType {prefer}
    MetaRefTypeVar  -> RefType  {prefer}

  lexical syntax
    "t"  [0-9\']*        -> MetaTypeVar
    "t_" [a-zA-Z0-9\']*  -> MetaTypeVar
    "ty" [0-9]*          -> MetaTypeVar
    "ty_" [a-zA-Z0-9\']* -> MetaTypeVar

    "primt"  [0-9]*        -> MetaPrimTypeVar
    "primt_" [a-zA-Z0-9]*  -> MetaPrimTypeVar
    "primty" [0-9]*        -> MetaPrimTypeVar
    "primty_" [a-zA-Z0-9]* -> MetaPrimTypeVar
    "reft"   [0-9]*        -> MetaRefTypeVar
    "reft_" [a-zA-Z0-9]*   -> MetaRefTypeVar
    "refty"  [0-9]*        -> MetaRefTypeVar
    "refty_" [a-zA-Z0-9]*  -> MetaRefTypeVar

    "t"  [0-9\']*          -> ID {reject}
    "t_" [a-zA-Z0-9]*      -> ID {reject}
    "ty" [0-9]*            -> ID {reject}
    "ty_" [a-zA-Z0-9]*     -> ID {reject}
    "primt"  [0-9]*        -> ID {reject}
    "primt_" [a-zA-Z0-9]*  -> ID  {reject}
    "primty" [0-9]*        -> ID {reject}
    "primty_" [a-zA-Z0-9]* -> ID {reject}
    "reft"   [0-9]*        -> ID {reject}
    "reft_" [a-zA-Z0-9]*   -> ID {reject}    
    "refty"  [0-9]*        -> ID {reject}
    "refty_" [a-zA-Z0-9]*  -> ID {reject}

  lexical restrictions
    MetaTypeVar -/- [a-zA-Z0-9\_\$\']

  %%%
   %% Quotation for Types
   %%%
  context-free syntax
            "t" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
           "ty" "|[" Type "]|"   -> E {cons("ToMetaExpr")}

    "java:type" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
         "type" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
    "java"      "|[" Type "]|"   -> E {cons("ToMetaExpr")}
                "|[" Type "]|"   -> E {cons("ToMetaExpr")}

  %%%
   %% Anti-Quotation for Types
   %%%
  context-free syntax
    "~"       E -> Type {cons("FromMetaExpr")}
    "~type:"  E -> Type {cons("FromMetaExpr")}

%%%
 %% Names
 %%%
exports

  %%%
   %% Variables for Names
   %%%
  variables
    "ambname"  [0-9]*        -> AmbName    {prefer}
    "ambname_" [a-zA-Z0-9]*  -> AmbName    {prefer}
    "ename"    [0-9]*        -> ExprName   {prefer}
    "ename_" [a-zA-Z0-9]*    -> ExprName   {prefer}
    "fname"    [0-9]*        -> MethodName {prefer}
    "fname_" [a-zA-Z0-9]*    -> MethodName {prefer}
    "tname"    [0-9]*        -> TypeName   {prefer}
    "tname_" [a-zA-Z0-9]*    -> TypeName   {prefer}
    "pkgtname" [0-9]*        -> PackageOrTypeName  {prefer}
    "pkgtname_" [a-zA-Z0-9]* -> PackageOrTypeName  {prefer}
    "pkgname" [0-9]*         -> PackageName  {prefer}
    "pkgname_" [a-zA-Z0-9]*  -> PackageName  {prefer}

  %%%
   %% Quotations for Names
   %%%
  context-free syntax
    "ambname"  "|[" AmbName    "]|" -> E {cons("ToMetaExpr")}
    "ename"    "|[" ExprName   "]|" -> E {cons("ToMetaExpr")}
    "fname"    "|[" MethodName "]|" -> E {cons("ToMetaExpr")}
    "tname"    "|[" TypeName   "]|" -> E {cons("ToMetaExpr")}
    "pkgtname" "|[" PackageOrTypeName "]|" -> E {cons("ToMetaExpr")}

%%%
 %% Modifiers
 %%%
exports

  %%%
   %% Variables for Modifiers
   %%%
  variables
     "mod" [0-9]*            -> MethodMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> MethodMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | MethodMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | MethodMod)* {prefer}
     
     "mod" [0-9]*            -> ClassMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> ClassMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | ClassMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | ClassMod)* {prefer}
     
     "mod" [0-9]*            -> ConstrMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> ConstrMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | ConstrMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | ConstrMod)* {prefer}
     
     "mod" [0-9]*            -> VarMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> VarMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | VarMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | VarMod)* {prefer}

     "mod" [0-9]*            -> FieldMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> FieldMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | FieldMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | FieldMod)* {prefer}

  %%%
   %% Quotations for Modifiers
   %%%
  context-free syntax
           "|[" Modifier "]|" -> E {cons("ToMetaExpr")}
    "mod"  "|[" Modifier "]|" -> E {cons("ToMetaExpr")}

    "anno" "|[" Anno "]|" -> E {cons("ToMetaExpr")}


%%%
 %% Formal Parameters
 %%%
exports

  %%%
   %% Variables for Formal Parameters
   %%%
  variables
     "param" [0-9]*            -> FormalParam  {prefer}
     "param_" [a-zA-Z0-9]*     -> FormalParam  {prefer}
     "param" [0-9]* "*"        -> {FormalParam ","}*  {prefer}
     "param_" [a-zA-Z0-9]* "*" -> {FormalParam ","}* {prefer}

  %%%
   %% Quotations for Formal Parameters
   %%%
  context-free syntax

         "param"  "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
    "java:param"  "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}

         "param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
    "java:param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}

    "java:formal-param" "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
         "formal-param" "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
    "java"              "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
                        "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}

    "java:formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
         "formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
    "java"               "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
                         "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}

  %%%
   %% Anti Quotations for Formal Parameters
   %%%
  context-free syntax
    "~"  E  ->  FormalParam       {cons("FromMetaExpr")}
    "~*" E  -> {FormalParam ","}* {cons("FromMetaExpr")}

%%%
 %% Package Declarations
 %%%
exports

  %%%
   %% Quotations
   %%%
  context-free syntax
    "java:package-dec" "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
         "package-dec" "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
                       "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}

    "java:package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}
         "package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}

  %%%
   %% Anti Quotations
   %%%
  context-free syntax
    "~package-dec:"  E -> PackageDec {cons("FromMetaExpr")}
    "~package-dec?:" E -> PackageDec? {cons("FromMetaExpr")}

%%%
 %% Import Declarations
 %%%
exports

  %%%
   %% Quotations for Import Declarations
   %%%
  context-free syntax

    "java:import-dec"  "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
         "import-dec"  "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
                       "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}

    "java:import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}
         "import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}

  %%%
   %% Anti Quotations for Import Declarations
   %%%
  context-free syntax

    "~import-dec:"  E  -> ImportDec  {cons("FromMetaExpr")}
    "~import-dec*:" E  -> ImportDec* {cons("FromMetaExpr")}

%%%
 %% Must be cleaned up
 %%%
exports
  context-free syntax
            "e" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
         "expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java"      "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
                "|[" Expr "]|"   -> E {cons("ToMetaExpr")}

    "java:compilation-unit" "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
         "compilation-unit" "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
    "java"                  "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
                            "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}

    "java:importdecl" "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
         "importdecl" "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
    "java"            "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}

    "java:type-dec" "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
         "type-dec" "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
    "java"          "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
                    "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}

    "java:class-body-dec" "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
         "class-body-dec" "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
    "java"                "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
                          "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}

    "java:interface-member-dec" "|[" InterfaceMemberDec  "]|" -> E {cons("ToMetaExpr")}
         "interface-member-dec" "|[" InterfaceMemberDec  "]|" -> E {cons("ToMetaExpr")}

    "java:constant-dec" "|[" ConstantDec  "]|" -> E {cons("ToMetaExpr")}
         "constant-dec" "|[" ConstantDec  "]|" -> E {cons("ToMetaExpr")}

    "java:class-body-dec*" "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
         "class-body-dec*" "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
    "java"                 "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
                           "|[" ClassBodyDec* "]|" -> E {cons("ToMetaListExpr")}

    "java:stm" "|["  Stm "]|" -> E {cons("ToMetaExpr")}
         "stm" "|["  Stm "]|" -> E {cons("ToMetaExpr")}

    "java:imember-dec" "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
         "imember-dec" "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
    "java"             "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
                       "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}

    "java:imember-dec*" "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
         "imember-dec*" "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
    "java"              "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
                        "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}

  %% Anti-quotation
  context-free syntax

    "~"      E -> Name {cons("FromMetaExpr")}
    "~name:" E -> Name {cons("FromMetaExpr")}
    "~*:"    E -> Name {cons("FromMetaExpr")}

    "~"     E     -> Id   {cons("FromMetaExpr")}
    "~id:"  E     -> Id   {cons("FromMetaExpr")}
    "~idd:" E ":" -> Id   {cons("FromMetaExpr")}

    "~x:" E -> ID {cons("FromMetaExpr")}

    "~"  E -> TypeParam        {cons("FromMetaExpr")}
    "~*" E -> {TypeParam ","}+ {cons("FromMetaExpr")}

    "~*" E -> {ExceptionType ","}* {cons("FromMetaExpr")}

    "~"      E  ->  Expr {cons("FromMetaExpr")}
    "~e:"    E  ->  Expr {prefer, cons("FromMetaExpr")}
    "~expr:" E  ->  Expr {prefer, cons("FromMetaExpr")}

    "~*" E      -> {Expr ","}*    {cons("FromMetaExpr")}
    "~*" E      -> {VarInit ","}* {cons("FromMetaExpr")}

    "~"  E  -> TypeDec  {cons("FromMetaExpr")}
    "~*" E  -> TypeDec* {cons("FromMetaExpr")}

    "~"  E  -> ClassBodyDec  {cons("FromMetaExpr")}
    "~*" E  -> ClassBodyDec* {cons("FromMetaExpr")}

    "~"  E  -> InterfaceMemberDec  {cons("FromMetaExpr")}
    "~*" E  -> InterfaceMemberDec* {cons("FromMetaExpr")}

    "~i:"      E -> DeciLiteral   {cons("FromMetaExpr")}
    "~deci:"   E -> DeciLiteral   {cons("FromMetaExpr")}
    "~hexa:"   E -> HexaLiteral   {cons("FromMetaExpr")}
    "~octa:"   E -> OctaLiteral   {cons("FromMetaExpr")}
    "~float:"  E -> FloatLiteral  {cons("FromMetaExpr")}
    "~string:" E -> StringLiteral {cons("FromMetaExpr")}
    "~char:"   E -> CharLiteral   {cons("FromMetaExpr")}

  syntax
    "~" <E-CF> -> StringChars {cons("FromMetaExpr"), prefer}
    "~" <E-CF> <LAYOUT?-CF> -> SingleChar  {cons("FromMetaExpr"), prefer}

module languages/java/EmbeddedJavaMix[Ctx0 E]
imports languages/java/EmbeddedJava[E]
          [ Name                  => Name[[Ctx0]]
            MetaRefTypeVar        => MetaRefTypeVar[[Ctx0]]
            MetaPrimTypeVar       => MetaPrimTypeVar[[Ctx0]]
            MetaTypeVar           => MetaTypeVar[[Ctx0]]
            CompilationUnit       => CompilationUnit[[Ctx0]]
            TypeDec               => TypeDec[[Ctx0]]
            ImportDec             => ImportDec[[Ctx0]]
            PackageDec            => PackageDec[[Ctx0]]
            ElemVal               => ElemVal[[Ctx0]]
            ElemValPair           => ElemValPair[[Ctx0]]
            Anno                  => Anno[[Ctx0]]
            LHS                   => LHS[[Ctx0]]
            CondMid               => CondMid[[Ctx0]]
            ArraySubscript        => ArraySubscript[[Ctx0]]
            DimExpr               => DimExpr[[Ctx0]]
            ArrayBaseType         => ArrayBaseType[[Ctx0]]
            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
            ClassMemberDec        => ClassMemberDec[[Ctx0]]
            ClassBodyDec          => ClassBodyDec[[Ctx0]]
            Interfaces            => Interfaces[[Ctx0]]
            Super                 => Super[[Ctx0]]
            ClassMod              => ClassMod[[Ctx0]]
            ClassDecHead          => ClassDecHead[[Ctx0]]
            ClassBody             => ClassBody[[Ctx0]]
            ClassDec              => ClassDec[[Ctx0]]
            InterfaceMod          => InterfaceMod[[Ctx0]]
            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
            InterfaceDec          => InterfaceDec[[Ctx0]]
            DefaultVal            => DefaultVal[[Ctx0]]
            AnnoElemDec           => AnnoElemDec[[Ctx0]]
            AnnoDecHead           => AnnoDecHead[[Ctx0]]
            AnnoDec               => AnnoDec[[Ctx0]]
            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
            ConstantMod           => ConstantMod[[Ctx0]]
            ConstantDec           => ConstantDec[[Ctx0]]
            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
            EnumConstArgs         => EnumConstArgs[[Ctx0]]
            EnumConst             => EnumConst[[Ctx0]]
            EnumBody              => EnumBody[[Ctx0]]
            EnumDecHead           => EnumDecHead[[Ctx0]]
            EnumDec               => EnumDec[[Ctx0]]
            ConstrMod             => ConstrMod[[Ctx0]]
            ConstrInv             => ConstrInv[[Ctx0]]
            ConstrBody            => ConstrBody[[Ctx0]]
            ConstrHead            => ConstrHead[[Ctx0]]
            ConstrDec             => ConstrDec[[Ctx0]]
            StaticInit            => StaticInit[[Ctx0]]
            InstanceInit          => InstanceInit[[Ctx0]]
            MethodBody            => MethodBody[[Ctx0]]
            ExceptionType         => ExceptionType[[Ctx0]]
            Throws                => Throws[[Ctx0]]
            MethodMod             => MethodMod[[Ctx0]]
            VarMod                => VarMod[[Ctx0]]
            FormalParam           => FormalParam[[Ctx0]]
            ResultType            => ResultType[[Ctx0]]
            MethodDecHead         => MethodDecHead[[Ctx0]]
            MethodDec             => MethodDec[[Ctx0]]
            BlockStm              => BlockStm[[Ctx0]]
            Block                 => Block[[Ctx0]]
            CatchClause           => CatchClause[[Ctx0]]
            SwitchLabel           => SwitchLabel[[Ctx0]]
            SwitchGroup           => SwitchGroup[[Ctx0]]
            SwitchBlock           => SwitchBlock[[Ctx0]]
            Stm                   => Stm[[Ctx0]]
            LocalVarDec           => LocalVarDec[[Ctx0]]
            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
            FieldMod              => FieldMod[[Ctx0]]
            VarInit               => VarInit[[Ctx0]]
            Dim                   => Dim[[Ctx0]]
            VarDecId              => VarDecId[[Ctx0]]
            VarDec                => VarDec[[Ctx0]]
            FieldDec              => FieldDec[[Ctx0]]
            ArrayInit             => ArrayInit[[Ctx0]]
            ClassLiteral          => ClassLiteral[[Ctx0]]
            Literal               => Literal[[Ctx0]]
            Type                  => Type[[Ctx0]]
            ArrayType             => ArrayType[[Ctx0]]
            TypeVar               => TypeVar[[Ctx0]]
            TypeDecSpec           => TypeDecSpec[[Ctx0]]
            InterfaceType         => InterfaceType[[Ctx0]]
            ClassType             => ClassType[[Ctx0]]
            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
            RefType               => RefType[[Ctx0]]
            TypeVarId             => TypeVarId[[Ctx0]]
            TypeParams            => TypeParams[[Ctx0]]
            TypeBound             => TypeBound[[Ctx0]]
            TypeParam             => TypeParam[[Ctx0]]
            WildcardBound         => WildcardBound[[Ctx0]]
            ActualTypeArg         => ActualTypeArg[[Ctx0]]
            TypeArgs              => TypeArgs[[Ctx0]]
            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
            MethodName            => MethodName[[Ctx0]]
            ExprName              => ExprName[[Ctx0]]
            TypeName              => TypeName[[Ctx0]]
            AmbName               => AmbName[[Ctx0]]
            PackageName           => PackageName[[Ctx0]]
            FloatType             => FloatType[[Ctx0]]
            IntType               => IntType[[Ctx0]]
            NumType               => NumType[[Ctx0]]
            PrimType              => PrimType[[Ctx0]]
            NullLiteral           => NullLiteral[[Ctx0]]
            FooStringChars        => FooStringChars[[Ctx0]]
            StringChars           => StringChars[[Ctx0]]
            StringPart            => StringPart[[Ctx0]]
            StringLiteral         => StringLiteral[[Ctx0]]
            SingleChar            => SingleChar[[Ctx0]]
            CharContent           => CharContent[[Ctx0]]
            CharLiteral           => CharLiteral[[Ctx0]]
            LastOcta              => LastOcta[[Ctx0]]
            OctaEscape            => OctaEscape[[Ctx0]]
            NamedEscape           => NamedEscape[[Ctx0]]
            EscapeSeq             => EscapeSeq[[Ctx0]]
            Bool                  => Bool[[Ctx0]]
            BoolLiteral           => BoolLiteral[[Ctx0]]
            BinaryExponent        => BinaryExponent[[Ctx0]]
            HexaSignificand       => HexaSignificand[[Ctx0]]
            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
            SignedInteger         => SignedInteger[[Ctx0]]
            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
            FloatLiteral          => FloatLiteral[[Ctx0]]
            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
            IntLiteral            => IntLiteral[[Ctx0]]
            OctaNumeral           => OctaNumeral[[Ctx0]]
            HexaNumeral           => HexaNumeral[[Ctx0]]
            DeciNumeral           => DeciNumeral[[Ctx0]]
            OctaLiteral           => OctaLiteral[[Ctx0]]
            HexaLiteral           => HexaLiteral[[Ctx0]]
            DeciLiteral           => DeciLiteral[[Ctx0]]
            Modifier              => Modifier[[Ctx0]]
            StrictFP              => StrictFP[[Ctx0]]
            Synchronized          => Synchronized[[Ctx0]]
            Volatile              => Volatile[[Ctx0]]
            Transient             => Transient[[Ctx0]]
            Native                => Native[[Ctx0]]
            Static                => Static[[Ctx0]]
            Final                 => Final[[Ctx0]]
            Abstract              => Abstract[[Ctx0]]
            Protected             => Protected[[Ctx0]]
            Private               => Private[[Ctx0]]
            Public                => Public[[Ctx0]]
            Id                    => Id[[Ctx0]]
            ID                    => ID[[Ctx0]]
            Keyword               => Keyword[[Ctx0]]
            ArrayAccess           => ArrayAccess[[Ctx0]]
            FieldAccess           => FieldAccess[[Ctx0]]
            MethodSpec            => MethodSpec[[Ctx0]]
            Expr                  => Expr[[Ctx0]] ]


module DeriveMix

imports
  WebDSL-Expand

exports

  context-free syntax
    "derivebodyelem" "|[" DeriveBodyElement "]|" -> E {cons("ToMetaExpr")}
             
  variables
    "bodyelem" [0-9]*           -> DeriveBodyElement {prefer}
    "bodyelem_"[A-Za-z0-9]+     -> DeriveBodyElement {prefer}
    "bodyelem" [0-9]* "*"       -> DeriveBodyElement* {prefer}
    "bodyelem_"[A-Za-z0-9]+ "*" -> DeriveBodyElement* {prefer}

module AccessControlMix

imports
  WebDSL-AccessControl

exports

  context-free syntax
    "acrule" "|[" AccessControlRule "]|" -> E {cons("ToMetaExpr")}
             "|[" AccessControlRule "]|" -> E {cons("ToMetaExpr")}
    "acdef"  "|[" AccessControlDefinition "]|" -> E {cons("ToMetaExpr")}
             "|[" AccessControlDefinition "]|" -> E {cons("ToMetaExpr")}


  variables
    "acrule" [0-9]*     -> AccessControlRule  {prefer}
    "acrule" [0-9]* "*" -> AccessControlRule* {prefer}
    "acdef"  [0-9]*     -> AccessControlDefinition  {prefer}
    "acdef"  [0-9]* "*" -> AccessControlDefinition* {prefer}
       
  context-free syntax
    "margs" "|[" MatchArgs "]|" -> E {cons("ToMetaExpr")}
            "|[" MatchArgs "]|" -> E {cons("ToMetaExpr")}
             
  variables
    "margs" [0-9]*  -> MatchArgs {prefer}
    
  context-free syntax
    "pexp"  "|[" PolicyExp "]|" -> E {cons("ToMetaExpr")}
            "|[" PolicyExp "]|" -> E {cons("ToMetaExpr")}        
             
  variables
    "pexp" [0-9]*  -> PolicyExp {prefer}
    
  variables
    "mid"[0-9]* -> MatchId {prefer}
    [xyz]"_"[A-Za-z0-9]+ -> MatchId {prefer}

module WebDSL-EntityDerive

imports
  WebDSL-Lexical
  WebDSL-Action

exports

  context-free syntax

    Exp "with" ExpEntityDeriveProp* -> TemplateArgExp {cons("ExpEntityDerive"), avoid}
    Id "(" {Exp ","}* ")" -> ExpEntityDeriveProp {cons("ExpEntityDeriveProp")}
    Id UNDEFINED* -> ExpEntityDeriveProp {cons("ExpEntityDeriveProp")}

    Id "with" ArgEntityDeriveProp -> Sort{cons("ArgEntityDerive")}
    Id "(" {ArgEntityDerivePropArg ","}* ")" -> ArgEntityDeriveProp{cons("ArgEntityDeriveProp")}
    Id UNDEFINED* -> ArgEntityDeriveProp{cons("ArgEntityDeriveProp")}
    Id ":" Sort -> ArgEntityDerivePropArg{cons("ArgEntityDerivePropArg")}

    "foreach" Id "{" TemplateElement* "}" -> TemplateElement{cons("ForeachElementEntityDerive")}
    "foreach" Id "{" Statement* "}"       -> Statement{cons("ForeachStatementEntityDerive")}

module WebDSL-Attributes

imports
  WebDSL-Lexical
  WebDSL-Action

exports

  sorts AttributeAssign AttributeSelection
  
context-free syntax

  AttributeCollectionOverride "attributes" Id "{" AttributeElem* "}" -> Definition {cons("AttributeCollection")}
  
  AttributeId "=" Exp -> AttributeElem {cons("AttributeAssign")}
  
  AttributeId "attributes" AttributeIncludeIgnore -> AttributeElem {cons("AttributeInclude")}

  -> AttributeIncludeIgnore{cons("None")}
  "ignore" AttributeId+ -> AttributeIncludeIgnore {cons("AttributeIncludeIgnore")}

  -> AttributeCollectionOverride{cons("None")}
  "override" -> AttributeCollectionOverride {cons("AttributeCollectionOverride")}

  "ignore" AttributeId "attributes" -> AttributeElem {cons("AttributeIgnore")}

context-free syntax
	
  Id -> AttributeId
  "all" -> AttributeId {reject}
  "attributes" -> AttributeId {reject}

context-free syntax

  AttributeId "attributes" -> AttributeSelection {cons("AttributeSelection")}
  "ignore" "default" AttributeId -> AttributeSelection {cons("AttributeIgnoreDefault")}
  
  AttributeSelection -> PropertyAssignment
  AttributeSelection -> Attribute

module WebDSL-Routing

exports

  context-free syntax

    "routing" "{" RoutingElement* "}" -> Definition {cons("Routing")}
    
    "receive" OptRoutingArgs Block -> RoutingElement{cons("RoutingReceive")}
    
    "construct" OptRoutingArgs Block -> RoutingElement{cons("RoutingConstruct")}
    
    "(" {FormalArg ","}* ")" -> OptRoutingArgs {cons("RoutingArgs")}
    -> OptRoutingArgs {cons("None")}

module WebDSL-Prefetch

imports
  WebDSL-Lexical
  WebDSL-Action
  WebDSL-UI

exports

  sorts TemplateElement Statement PrefetchFor PrefetchChildren PrefetchNode PrefetchTemplateArgs PrefetchTemplateArg PrefetchNodeMod PrefetchCondition PrefetchCondVal PrefetchCond PrefetchWhere PrefetchWhereMod

  context-free syntax

    "prefetch-for" PrefetchForVar
                   PrefetchTemplateArgs
                   PrefetchWhere
                   PrefetchChildren                               -> PrefetchFor       {cons("PrefetchFor")}
    "{" PrefetchNode* "}"                                         -> PrefetchChildren  {cons("PrefetchChildren")}
                                                                  -> PrefetchChildrenOpt {cons("None")}
    PrefetchChildren                                              -> PrefetchChildrenOpt
    PrefetchFor                                                   -> TemplateElement
    PrefetchFor                                                   -> Statement

    PrefetchOwnerCast?  %% The SimpleSort to cast to before accessing the property
    Id                  %% The name of the property
    PrefetchNodeMod*
    PrefetchTemplateArgs   %% A list of templates that should have its default implementation (not dynamically redefined)
    PrefetchCondition   %% A condition under which the property is accessed (can only contain simple conditions)
    PrefetchWhere       %% A condition for the elements of a collection
    PrefetchChildrenOpt %% A list of child nodes
                                                                  -> PrefetchNode      {cons("PrefetchNode")}
                                                                  -> PrefetchIfDefault {cons("None")}
    Id                                                            -> PrefetchForVar    {cons("Var")}
    "no-empty-batch"                                              -> PrefetchNodeMod   {cons("NoEmptyBatch")}
    "fetch-early"                                                 -> PrefetchNodeMod   {cons("FetchEarly")}
    Id "(" {SortOrThis ","}* ")"                                  -> TemplateArgOrThis {cons("TemplateArgOrThis")}
    Sort                                                          -> SortOrThis
    PrefetchThis                                                  -> SortOrThis {prefer}
    PrefetchThis "as" Sort                                        -> SortOrThis {cons("PrefetchThisCast")}
    "this"                                                        -> PrefetchThis {cons("PrefetchThis")}
    %%"default" "[" {TemplateArg "," }+ "]"                         -> PrefetchTemplateArgs {cons("PrefetchIfDefault")}
                                                                  -> PrefetchTemplateArgs {cons("None")}
    "templates" "[" {TemplateArgOrThis "," }+ "]"                 -> PrefetchTemplateArgs {cons("PrefetchTemplateArgs")}
                                                                  -> PrefetchCondition {cons("None")}
    "if" "(" PrefetchCondOrTrue ")"                               -> PrefetchCondition {cons("PrefetchCondition")}
                                                                  -> PrefetchWhere     {cons("None")}
    "where" PrefetchWhereMod* "("  PrefetchCondOrTrue ")"         -> PrefetchWhere     {cons("PrefetchWhere")}
    "hint"                                                        -> PrefetchWhereMod  {cons("Hint")}

                                                                  -> NoneCons          {cons("None")}
    SimpleSort "."                                                -> PrefetchOwnerCast {ast("<1>")}

    PrefetchCond                                                  -> PrefetchCondOrTrue
    "true"                                                        -> PrefetchCondVal {cons("True")}

    %% Intentionally matches Exp
    "true"                                                        -> PrefetchCondVal {prefer,cons("True")}
    "false"                                                       -> PrefetchCondVal {prefer,cons("False")}
    "null"                                                        -> PrefetchCondVal {prefer,cons("Null")}
    ConstValue                                                    -> PrefetchCondVal {prefer}
    Id                                                            -> PrefetchCondVal {cons("Var")}
    NoneCons "." Id                                               -> PrefetchCondVal {cons("RelativeFieldAccess")}
    SimpleSort "." Id                                             -> PrefetchCondVal {cons("RelativeFieldAccess")}
    PrefetchCondVal "*" PrefetchCondVal                           -> PrefetchCondVal {cons("Mul"),assoc}
    PrefetchCondVal "/" PrefetchCondVal                           -> PrefetchCondVal {cons("Div"),assoc}
    PrefetchCondVal "%" PrefetchCondVal                           -> PrefetchCondVal {cons("Mod"),assoc}
    PrefetchCondVal "+" PrefetchCondVal                           -> PrefetchCondVal {cons("Add"),assoc}
    PrefetchCondVal "-" PrefetchCondVal                           -> PrefetchCondVal {cons("Sub"),assoc}


    PrefetchCondVal                                               -> PrefetchCond
    PrefetchCondVal "==" PrefetchCondVal                          -> PrefetchCond {cons("Eq")}
    PrefetchCondVal "!=" PrefetchCondVal                          -> PrefetchCond {cons("NotEq")}
    PrefetchCondVal ">"  PrefetchCondVal                          -> PrefetchCond {cons("LargerThan")}
    PrefetchCondVal ">=" PrefetchCondVal                          -> PrefetchCond {cons("LargerThanOrEqual")}
    PrefetchCondVal "<"  PrefetchCondVal                          -> PrefetchCond {cons("SmallerThan")}
    PrefetchCondVal "<=" PrefetchCondVal                          -> PrefetchCond {cons("SmallerThanOrEqual")}

    PrefetchCond "&&" PrefetchCond                                -> PrefetchCond {cons("And"), assoc}
    PrefetchCond "||" PrefetchCond                                -> PrefetchCond {cons("Or"), assoc}
    "!" PrefetchCond                                              -> PrefetchCond {cons("Not")}
    "(" PrefetchCond ")"                                          -> PrefetchCond {bracket}

context-free priorities
  {left:
       PrefetchCondVal "*" PrefetchCondVal -> PrefetchCondVal
       PrefetchCondVal "%" PrefetchCondVal -> PrefetchCondVal
       PrefetchCondVal "/" PrefetchCondVal -> PrefetchCondVal }
  > {left:
       PrefetchCondVal "+" PrefetchCondVal -> PrefetchCondVal
       PrefetchCondVal "-" PrefetchCondVal -> PrefetchCondVal }

context-free priorities
  "!" PrefetchCond -> PrefetchCond
  > {left:
       PrefetchCond "&&" PrefetchCond -> PrefetchCond }
  > {left:
       PrefetchCond "||" PrefetchCond -> PrefetchCond }

module WebDSL-Search

imports
    WebDSL-Lexical

exports
    sorts Definition Annotation Exp

    context-free syntax

    FullTextAnalyzer                                            -> Definition

    DEFAULT? "analyzer" Id "{" FullTextAnalyzerBody "}"         -> FullTextAnalyzer{cons("FullTextAnalyzer")}

    FullTextAnalyzerBodyDef                                     -> FullTextAnalyzerBody

    INDEXORQUERY "{" FullTextAnalyzerBodyDef "}"
    INDEXORQUERY "{" FullTextAnalyzerBodyDef "}"                -> FullTextAnalyzerBody{cons("DualFullTextAnalyzerBodyDef")}
    CharFilter* Tokenizer TokenFilter*                          -> FullTextAnalyzerBodyDef{cons("FullTextAnalyzerBodyDef")}

    "char filter" "=" CHARFILTERNAME "(" {Argument ","}* ")"     -> CharFilter{cons("CharFilter")}
    "char filter" "=" CHARFILTERNAME                             -> CharFilter{cons("CharFilterNoArgs")}

    "tokenizer" "=" TOKENIZERNAME "(" {Argument ","}* ")"       -> Tokenizer{cons("Tokenizer")}
    "tokenizer" "=" TOKENIZERNAME                               -> Tokenizer{cons("TokenizerNoArgs")}

    "token filter" "=" TOKENFILTERNAME "(" {Argument ","}* ")"   -> TokenFilter{cons("TokenFilter")}
    "token filter" "=" TOKENFILTERNAME                           -> TokenFilter{cons("TokenFilterNoArgs")}

    Id "=" String                                               -> Argument{cons("Argument")}

    Id    -> CHARFILTERNAME
    Id    -> TOKENIZERNAME
    Id    -> TOKENFILTERNAME

  context-free syntax

    %%searchable without params is left as SimpleAnno, but desugared to SearchableAnno,
    %%because "searchable" won't get rejected as Id (sdf strangeness).
    "searchable"                               -> SearchableAnno         {cons("SearchableAnno"), prefer}
    "searchable" "(" {SA-Argument ","}* ")"    -> SearchableAnno         {cons("SearchableAnno")}
    "search" "namespace"                       -> SearchNamespaceAnno    {cons("SearchNamespaceAnno"), prefer}
    SearchableAnno    "^" Float                -> Annotation             {cons("SearchableAnnoBoost")}
    SearchableAnno                             -> Annotation
    SearchNamespaceAnno                        -> Annotation

    SA-Key "=" SA-Value                        -> SA-Argument            {cons("SA-Argument")}
    "autocomplete"                             -> SA-Argument            {cons("Autocomplete-Argument")}
    "spellcheck"                               -> SA-Argument            {cons("Spellcheck-Argument")}
    "numeric"                                  -> SA-Argument            {cons("Numeric-Argument")}
    "default"                                  -> SA-Argument            {cons("DefaultSF-Argument")}

  context-free syntax
    SearchMapping                                    -> Definition
    SearchMappingEmbedded                            -> EntityBodyDeclaration
    "search" "mapping" "{" SearchMappingContent* "}"    -> SearchMappingEmbedded  {cons("SearchMappingEmbedded")}
    "search" "mapping" Id "{" SearchMappingContent* "}" -> SearchMapping          {cons("SearchMapping")}

    "namespace" "by" Id                              -> SearchMappingContent      {cons("SearchNamespaceMapping"), prefer}
    "namespace" "by" Id    ";"                       -> SearchMappingContent      {cons("SearchNamespaceMapping")}

    DEFAULTSF? KW MappingPart*    ";"                -> SearchMappingContent      {cons("SearchFieldMapping")}
    DEFAULTSF? "index" Id MappingPart*    ";"        -> SearchMappingContent      {cons("SearchFieldMapping")} %% more natural language
    DEFAULTSF? KW MappingPart*                       -> SearchMappingContent      {cons("SearchFieldMapping")}
    DEFAULTSF? "index" Id MappingPart*               -> SearchMappingContent      {cons("SearchFieldMapping")} %% more natural language

    "as" Id                                          -> MappingPart               {cons("FieldName")}
    "using" Id                                       -> MappingPart               {cons("AnalyzerName")}
    "boosted" "to" Float                             -> MappingPart               {cons("Boost")}
    "for" "subclass" Id                              -> MappingPart               {cons("TargetEntity")}
    "(" {SearchMappingAnnoKW ","}* ")"               -> MappingPart               {cons("SearchMappingAnno")}
    "depth" Int                                      -> MappingPart               {cons("EmbeddedDepth")}
    "with" "depth" Int                               -> MappingPart               {cons("EmbeddedDepth")} %% more natural language
    Boost                                            -> MappingPart

    "^" Float                                        -> Boost                     {cons("Boost")}

    Id           -> KW
    "as"         -> KW {reject}
    "using"      -> KW {reject}
    "boosted"    -> KW {reject}
    "by"         -> KW {reject}
    "with"       -> KW {reject}
    "index"      -> KW {reject}
    "depth"      -> KW {reject}
    "for"        -> KW {reject}

  lexical syntax
    "analyzer"                   -> SA-Key
    "name"                       -> SA-Key
    "boost"                      -> SA-Key
    "subclass"                   -> SA-Key
    "depth"                      -> SA-Key
    "default"                    -> DEFAULT
    "default_builtin_analyzer"   -> DEFAULT
    "+"                          -> DEFAULTSF
    Id                           -> SA-Value
    Float                        -> SA-Value
    Int                          -> SA-Value
    "spellcheck"                 -> SearchMappingAnnoKW
    "autocomplete"               -> SearchMappingAnnoKW
    "index"                      -> INDEXORQUERY
    "query"                      -> INDEXORQUERY

  context-free syntax

    SearcherDef                                      -> Exp

    "search" ENTITY SearcherPart*                    -> SearcherDef         {cons("SearcherInit")}
    "~" Exp SearcherPart+                            -> SearcherDef         {cons("SearcherRefMod")}

    ConstraintFilter    -> SearcherPart
    QueryDef            -> SearcherPart
    Offset              -> SearcherPart
    MaxResults          -> SearcherPart
    SortBy              -> SearcherPart
    FacetDef            -> SearcherPart
    SearchAttributes    -> SearcherPart
    NamespaceConstraint -> SearcherPart

    "matching" MatchGroup+                           -> QueryDef            {cons("QueryDef"),prefer}
    "offset"    Exp                                  -> Offset              {cons("Start")}
    "limit"    Exp                                   -> MaxResults          {cons("MaxResults")}
    "order" "by" {(SortExp) ","}+                    -> SortBy              {cons("SortBy")}
    "with" "filter" {(FilterConstraint) ","}+        -> ConstraintFilter    {cons("ConstraintFilter")}
    "with" "filters" {(FilterConstraint) ","}+       -> ConstraintFilter    {cons("ConstraintFilter")}
    "with" "facet" {FacetExp ","}+                   -> FacetDef            {cons("FacetDef")}
    "with" "facets" {FacetExp ","}+                  -> FacetDef            {cons("FacetDef")}
    "[" {SearchAttribute ","}+ "]"                   -> SearchAttributes    {cons("SearchAttributes")}
    "in" "namespace" Exp                             -> NamespaceConstraint {cons("NamespaceConstraint")}

    "no" "lucene"                                    -> SearchAttribute    {cons("NoLucene")}
    "lucene"                                         -> SearchAttribute    {cons("Lucene")}
    "strict" "matching"                              -> SearchAttribute    {cons("DefaultAnd")}
    "loose" "matching"                               -> SearchAttribute    {cons("DefaultOr")}

    SearchField "(" Exp ")"                          -> FacetExp           {cons("DiscreteFacetDef")}
    SearchField "(" {Range ","}+ ")"                 -> FacetExp           {cons("RangeFacetDef")}

    SearchField ":" Exp                              -> FilterConstraint   {cons("FieldFilterConstraint")}
    %% Exp                                              -> FilterConstraint   {cons("FacetFilterConstraint")}

    {QuerySearchField "," }+ ":"                     -> FieldsConstraint   {cons("FieldsConstraint")}
    SearchField QueryBoost?                          -> QuerySearchField   {cons("QuerySearchField")}
    {QueryExp ","}+                                  -> QueryConstraint    {cons("QueryConstraint"), avoid}
    "^" Exp                                          -> QueryBoost         {cons("QueryBoost")}

    BoolOp? "(" MatchGroup+ ")"                      -> MatchGroup         {cons("Clause"),avoid}
    FieldsConstraint? QueryConstraint                -> MatchGroup         {cons("Query"), avoid}
    "*" ":" "*"                                      -> MatchGroup         {cons("MatchAllQuery")}

    BoolOp? "(" QueryExp+ ")" Slop?                  -> QueryExp           {cons("GroupDef"), prefer}
    BoolOp? QueryTerm Slop?                          -> QueryExp           {cons("TermDef"), avoid}
    BoolOp? Range                                    -> QueryExp           {cons("RangeDef")}
    "~" Exp                                          -> Slop               {cons("Slop")}
    RangeOpen ExpOrWildCard "to"
              ExpOrWildCard RangeClose               -> Range              {cons("Range")}
    RangeOpen ExpOrWildCard "TO"
              ExpOrWildCard RangeClose               -> Range              {cons("Range")}

    Exp                                              -> ExpOrWildCard
    "*"                                              -> ExpOrWildCard      {cons("WildCard")}

    "{"                                              -> RangeOpen          {cons("ExcludingOpen")}
    "}"                                              -> RangeClose         {cons("ExcludingClose")}
    "["                                              -> RangeOpen          {cons("IncludingOpen")}
    "]"                                              -> RangeClose         {cons("IncludingClose")}

    "+"                                              -> BoolOp             {cons("Must")}
    "-"                                              -> BoolOp             {cons("MustNot")}

    Exp                                              -> QueryTerm
    SearcherDef                                      -> QueryTerm          {reject}

    SearchField Direction?                           -> SortExp            {cons("SortDef")}
    "asc"                                            -> Direction          {cons("Ascending")}
    "ascending"                                      -> Direction          {cons("Ascending")}
    "desc"                                           -> Direction          {cons("Descending")}
    "descending"                                     -> Direction          {cons("Descending")}

    "highlight"                                      -> Highlight          {cons("NormalHighlight")}
    "highlightHTML"                                  -> Highlight          {cons("HTMLHighlight")}

    Highlight SearchField ":" Exp "from" Exp         -> RetrievalExp       {cons("Highlight")}
    Highlight SearchField ":" Exp "from" Exp
        "with" "tags" "(" Exp "," Exp ")"            -> RetrievalExp       {cons("HighlightTags"), prefer}
    "results" "from"  Exp                            -> RetrievalExp       {cons("SearchResults")}
    SearchField "facets" "from" Exp                  -> RetrievalExp       {cons("FacetResults")}
    "count" "from" Exp                               -> RetrievalExp       {cons("SearchResultsSize")}
    "searchtime" "from" Exp                          -> RetrievalExp       {cons("SearchTimeString")}
    ENTITY SuggestType SuggestionPart+               -> RetrievalExp       {cons("Suggest")}
    "completions"                                    -> SuggestType        {cons("AutoComplete")}
    "corrections"                                    -> SuggestType        {cons("SpellCheck")}
    RetrievalExp                                     -> Exp

    "~" Exp                                          -> SearchField        {cons("SearchFieldExp")}
    PlainField                                       -> SearchField
    SearchFieldId                                    -> PlainField         {cons("SearchFieldPlain")}
    SearchFieldId "." PlainField                     -> PlainField         {cons("SearchFieldPlain")}


    "similarity" Exp                 -> SuggestionPart {cons("Similarity")}
    "matching" FieldsConstraint Exp  -> SuggestionPart {cons("SuggestTerm")}
    NamespaceConstraint              -> SuggestionPart
    MaxResults                       -> SuggestionPart

    %% disambiguate over Var("") terms allowed by QueryTerm and SearcherPart keywords, dont allow keywords to be used as varref
    SearcherKW             -> QueryTerm {reject}
    SearcherKW "(" Exp ")" -> QueryTerm {reject}
    "[" {Exp ","}* "]"     -> QueryTerm {reject}

  context-free restrictions
    %% Don't treat -200 as 'must not match 200', but as int '-200' instead
    BoolOp  -/- [0-9]
    %% 'matching tags.name: +tag.replace(" ","\\ ")' , interpret as method call, not as field/prop access followed by a new clause
    QueryTerm -/- [\(]

  context-free priorities
    %% search User matching credit: -(-200) //interpret as 'must not match -200'
    Exp -> QueryTerm
    >
    "(" Exp ")"  -> Exp

  context-free priorities
  %% search Movie matching +book.title  //Dont treat '.title' as method-call/property access for whole searcher exp, but restrict to inner exp 'book'.
  %% Movie completions similarity 5 / 11 != null // interpret as (Movie completions similarity 5/11) != (null)
    {QueryExp ","}+ -> QueryConstraint
  > {
      Exp "." Id "(" {Exp ","}* ")"  -> Exp
      Exp "." Id                     -> Exp
    }
  > "!" Exp -> Exp
  > {left:
       Exp "*" Exp -> Exp
       Exp "%" Exp -> Exp
       Exp "/" Exp -> Exp }
  > {left:
       Exp "+" Exp -> Exp
       Exp "-" Exp -> Exp }
  > {
      RetrievalExp -> Exp
      SearcherDef -> Exp
      "similarity" Exp                   -> SuggestionPart
      "matching" FieldsConstraint Exp    -> SuggestionPart
      NamespaceConstraint                -> SuggestionPart
      MaxResults                         -> SuggestionPart
    }
  > Exp "in" Exp -> Exp

  context-free priorities
    %% all category facets from mySearcher == [Facet{}] //interpret as (all category facets from mySearcher) == ([Facet{}])
    {
      Highlight Exp "for" Exp "on" SearchField
          "surround" "with" "(" Exp "," Exp ")"        -> RetrievalExp
      Highlight Exp "for" Exp "on" SearchField         -> RetrievalExp
      "results" "from"  Exp                            -> RetrievalExp
      SearchField "facets" "from" Exp                  -> RetrievalExp
      "count" "from" Exp                               -> RetrievalExp
      "searchtime" "from" Exp                          -> RetrievalExp
    }
  > Exp "in" Exp -> Exp

  context-free priorities
     %% search Movie matching +"hello" -"goodbye" //Dont treat this as sub
    {QueryExp ","}+ -> QueryConstraint
  > {
      Exp "+" Exp -> Exp
      Exp "-" Exp -> Exp
    }

  lexical syntax
    Id             -> SearchFieldId
    "_id"          -> SearchFieldId %%this field is added by hibernate search
    Id             -> ENTITY
    Id             -> SEARCHERREF
    "limit"            -> SearcherKW
    "offset"           -> SearcherKW
    "with"             -> SearcherKW
    "order"            -> SearcherKW
    "in"               -> SearcherKW
    "matching"         -> SearcherKW

 context-free restrictions
    "as" "asc" "ascending" "analyzer" "autocomplete" "boost" "boosted" "by"           -/- [a-zA-Z0-9]
    "desc" "descending" "default" "default_builtin_analyzer" "depth" "extend" "for"   -/- [a-zA-Z0-9]
    "facet" "facets" "from" "get" "highlight" "index" "limit"                         -/- [a-zA-Z0-9]
    "matching" "name" "namespace" "nolucene" "on" "query"                             -/- [a-zA-Z0-9]
    "results" "search" "sort" "spellcheck" "start" "subclass"                         -/- [a-zA-Z0-9]
    "using" "with" "where"                                                            -/- [a-zA-Z0-9]


%% DEPRECATED:
  context-free syntax
    "searchmapping" "{" SearchMappingContent* "}"               -> SearchMappingEmbedded{cons("SearchMappingEmbedded"), deprecated("keyword `searchmapping` is replaced with `search mapping`")}
    "searchmapping" Id "{" SearchMappingContent* "}"            -> SearchMapping{cons("SearchMapping"), deprecated("keyword `searchmapping` is replaced with `search mapping`")}
    "charfilter" "=" CHARFILTERNAME "(" {Argument ","}* ")"     -> CharFilter{cons("CharFilter"), deprecated("keyword `charfilter` is replaced with `char filter`")}
    "charfilter" "=" CHARFILTERNAME                             -> CharFilter{cons("CharFilterNoArgs"), deprecated("keyword `charfilter` is replaced with `char filter`")}
    "tokenfilter" "=" TOKENFILTERNAME "(" {Argument ","}* ")"   -> TokenFilter{cons("TokenFilter"), deprecated("keyword `tokenfilter` is replaced with `token filter`")}
    "tokenfilter" "=" TOKENFILTERNAME                           -> TokenFilter{cons("TokenFilterNoArgs"), deprecated("keyword `tokenfilter` is replaced with `token filter`")}
    "all" SearchField "facets" "from" Exp                       -> RetrievalExp{cons("AllFacetResults"), deprecated("the `all` keyword has been deprecated and has no effect on facet retrieval anymore")}
    "(" SearchField "," Exp ")"                                 -> FacetExp{cons("DiscreteFacetDef"), deprecated("the notation: (field,topN) has been replaced with field(topN) ")}
    "(" SearchField ":" {Range ","}+ ")"                        -> FacetExp{cons("RangeFacetDef"), deprecated("the notation: (field:[min to max], ...) has been replaced with field([min to max], ...) ")}

module WebDSL-Service

imports
    WebDSL-Lexical
    WebDSL

exports

  context-free syntax

     "service" Modifier* Id "(" {FormalArg ","}* ")" 
        Block                                                                  -> Definition {cons("ServiceFunction")}

	 "derive" "webservices" "for" Id "," "with" "nameproperty" Id			   -> Definition {cons("DeriveWebServices")}
	 
	  SyncConfigEmbedded                            	                       -> EntityBodyDeclaration
	 "synchronization" "configuration" "{" SyncOption* "}"                     -> SyncConfigEmbedded  {cons("SyncConfigEmbedded")}
	 
	 "toplevel" "name" "property" ":" Id			                           -> SyncOption {cons("SyncTopLevelNameProperty")}
	 
	 "restricted" "properties" ":" {Id ","}*			                       -> SyncOption {cons("SyncRestrictedProperties")}
	 
	 "access" "read" ":"  Exp			                       		           -> SyncOption {cons("SyncACRead")}
	 
	 "access" "write" ":"  Exp			                       	               -> SyncOption {cons("SyncACWrite")}
	 
	 "access" "create" ":"  Exp			                       		           -> SyncOption {cons("SyncACCreate")}

module WebDSL-TimeInterval

imports
  WebDSL-Lexical
  WebDSL-Action

exports

  context-free syntax
    Exp "weeks"        -> TimeIntervalPart {cons("Weeks")}
    Exp "days"         -> TimeIntervalPart {cons("Days")}
    Exp "hours"        -> TimeIntervalPart {cons("Hours")}
    Exp "minutes"      -> TimeIntervalPart {cons("Minutes")}
    Exp "seconds"      -> TimeIntervalPart {cons("Seconds")}
    Exp "milliseconds" -> TimeIntervalPart {cons("Milliseconds")}
    "every" TimeIntervalPart*  -> TimeInterval {cons("TimeInterval")}
    
    "on application start"    -> OnAppStart {cons("OnAppStart")}
    "on application stop"  -> OnAppStart {cons("OnAppStop")}

  context-free syntax
    "invoke" Exp TriggerExp -> Definition {cons("InvokeTimedTask")}
    TimeInterval -> TriggerExp
    OnAppStart   -> TriggerExp
    OnAppStop -> TriggerExp


module WebDSL-Test

exports

context-free syntax

  "test" Id Block -> Definition {cons("Test")}
  "test" Block -> Definition {ast("Test(\"\",<1>)")}

module WebDSL-Type

exports

  context-free syntax
  
    %%  Construct for creating custom value types, and altering the existing value types.
    %%
    %%  example: 
    %%    type String { validate(this.length() <= 255 , "input too long (max 255 characters)") }
    %%    type USDate : Date { format = "MM/dd/yyyy" }
    %% 
    %%  Will also need to cope with input/output decode/encode.
    %%

    "type" Id "{" TypeProperty* "}" -> Definition {cons("TypeDef")}
    
    Annotation -> TypeProperty {cons("TypeDefAnno")}
    
    NativeClassFunction -> TypeProperty
    %%solve ambiguities
    "static" -> TypeProperty {reject}
    
    QId "as" NativeClassFunction -> TypeProperty{cons("NativeClassFunctionFromStatic")}

module WebDSL-Exception

exports

  context-free syntax
  
    %%
    %%  Exceptions, for supporting data validation
    %%
    %%  example: 
    %%  entity ValidationException{message:String}
    %%  throw ValidationException{ message := "error" }
    %%  try{}catch(ve : ValidationException){}
    %%  throw ValidationException{ message := "error1" }, ValidationException{ message := "error2" }
    %%  try{}catch(l : List<ValidationException>)

    "throw" {Exp ","}+ ";" -> Statement {cons("ThrowStatement"), prefer}
    "throw" {Exp ","}+     -> TemplateCall {cons("ThrowTemplate"), prefer}
    
    "try" Block Catch+ -> Statement {cons("TryStatement"), prefer}
    "try" Block Catch+ -> TemplateCall {cons("TryTemplate"), prefer}
    
    "catch" "(" Id ":" Sort ")" Block -> Catch {cons("Catch")}

module WebDSL-Native

imports
  WebDSL-Lexical

exports

  sorts Derive DeriveType DeriveProperty

context-free syntax

  "native" "class" QId NativeClassAlias NativeClassSuper "{" NativeClassElement* "}" -> NativeClassDeclaration {cons("NativeClass")}

  "as" Id -> NativeClassAlias{cons("NativeClassAlias"),prefer}
  -> NativeClassAlias{cons("None")}

  ":" Id -> NativeClassSuper{cons("NativeClassSuper"),prefer}
  -> NativeClassSuper{cons("None")}

context-free syntax %%properties

  Id ":" NativeType -> NativeClassElement{cons("NativeClassProperty")}

context-free syntax %%functions

  NativeClassFunction -> NativeClassElement

  NativeClassFunctionStatic NativeFunId "(" {NativeType ","}* ")" NativeClassFunctionReturn -> NativeClassFunction{cons("NativeClassFunction")}
  "constructor" "(" {NativeType ","}* ")" NativeClassFunctionReturn -> NativeClassElement{reject}

  ":" NativeType ->  NativeClassFunctionReturn{cons("NativeClassFunctionReturn"),prefer}
  ->  NativeClassFunctionReturn{cons("None")}

  "static" ->  NativeClassFunctionStatic{cons("NativeClassFunctionStatic"),prefer}
  ->  NativeClassFunctionStatic{cons("None")}

  QId "as" NativeClassFunction -> NativeClassElement{cons("NativeClassFunctionFromStatic")}

  "constructor" "(" {NativeType ","}* ")" -> NativeClassElement{cons("NativeClassConstructor")}
  QId "as" "constructor" "(" {NativeType ","}* ")" -> NativeClassElement{cons("NativeClassConstructorFromStatic")}
  "constructor" -> NativeFunId{reject}

  Id "<" {NativeType ","}* ">" -> NativeType{cons("NativeGenericType")}
  "[" {NativeType ","}* "]" -> NativeType{ast("NativeGenericType(\"List\",<1>)")}
  "{" {NativeType ","}* "}" -> NativeType{ast("NativeGenericType(\"Set\",<1>)")}
  Id -> NativeType{cons("NativeSimpleType")}

  lexical syntax
    Id -> NativeFunId


module WebDSL-Expand

imports
  WebDSL-UI
  WebDSL-Lexical

exports

  sorts Derive DeriveType DeriveProperty

context-free syntax

  "derive" Id "from" Exp "for" "("
    {DeriveProperty ","}*
  ")"                               -> TemplateElement {cons("Derive"), prefer}
  "derive" Id "from" Exp            -> TemplateElement {cons("Derive"), prefer}
  %%"derive" Id                       -> TemplateElement {cons("Derive"), prefer}
  %% Disabled this one for now because it is causing ambiguities, have a look at this Ruben!

  "derive" Id "from" Exp "for" "("
    {DeriveProperty ","}*
  ")" DeriveBody                    -> TemplateElement {cons("Derive"), prefer}
  "derive" Id "from" Exp DeriveBody -> TemplateElement {cons("Derive"), prefer}
  "derive" Id DeriveBody            -> TemplateElement {cons("Derive"), prefer}

  Id                                -> DeriveProperty {cons("DeriveDefault")}
  Id "(" Id ")"                     -> DeriveProperty {cons("DeriveMode")}

  "{" DeriveBodyElement* "}"        -> DeriveBody {cons("DeriveBody")}

  Id "{" TemplateElement* "}"       -> DeriveBodyElement {cons("DeriveBodyElement")}

  "derive"                          -> TemplateCall {reject}

  "derive" "crud" Id -> Definition {cons("DeriveCrud"), prefer}
  "derive" "CRUD" Id -> Definition {cons("DeriveCrud"), prefer}


context-free syntax %% custom expand templates

  "expand" ExpandId+ "to" Id -> Definition {cons("ExpandTemplateCall")}

  "expandtemplate" Id "to" ExpandArgId+ "{" Definition* "}" -> Definition {cons("ExpandTemplateDefinition")}

  "expand" ExpandId+ "to" ExpandArgId+ "{" TemplateElement* "}" -> TemplateElement {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" EntityBodyDeclaration* "}" -> EntityBodyDeclaration {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" Statement* "}" -> Statement {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" ObjectPropertyAssignment* "}" -> ObjectPropertyAssignment {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" Definition* "}" -> Definition {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" Exp "}" -> Exp {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" Attribute "}" -> Attribute {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" PropertyAssignment "}" -> PropertyAssignment {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" FormalArg "}" -> FormalArg {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" Case "}" -> Case {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" TemplateCaseAlt "}" -> TemplateCaseAlt {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" TypeCaseAlt "}" -> TypeCaseAlt {cons("ExpandLocal"), prefer}
  "expand" ExpandId+ "to" ExpandArgId+ "{" TemplateTypeCaseAlt "}" -> TemplateTypeCaseAlt {cons("ExpandLocal"), prefer}

  "expandtemplate" -> ExpandId {reject}
  "template" -> ExpandId {reject}
  "expand" -> ExpandId {reject}
  "to" -> ExpandId {reject}

  "expandtemplate" -> ExpandArgId {reject}
  "template" -> ExpandArgId {reject}
  "expand" -> ExpandArgId {reject}
  "to" -> ExpandArgId {reject}

  lexical syntax
    [a-zA-Z0-9\_\-]+ -> ExpandId
    Id -> ExpandArgId

  lexical restrictions
    ExpandId -/- [a-zA-Z0-9\_\-]

module WebDSL-Enums

imports
  WebDSL-DataModel
  WebDSL-Lexical

exports
  sorts Defintion EnumValue

  context-free syntax

  "enum" Id "{" {EnumValue ","}* "}"                    -> Definition {cons("Enum")}

  Id "(" String ")"                               -> EnumValue {cons("EnumValue")}

module WebDSL-Regex


exports
%%d  context-free start-symbols
%%d    PatternDecl Pattern
  sorts Pattern PatternDecl Exp
  context-free syntax
    RegexExp "." Id "(" {Exp ","}* ")"  -> Exp {cons("Call")} %% always used with a call, regex directly as exp results in ambiguity with xml embedding

    "/" Pattern "/"            -> RegexExp { cons("RegexPattern") }
    Branche                    -> Pattern {cons("SingleBranch")}
    Pattern "|" Pattern        -> Pattern {cons("TupleBranch"), right, prefer}


  sorts Branche
  context-free syntax
    Piece+                     -> Branche {cons("Pieces")}

  sorts Piece
  context-free syntax
    Atom                       -> Piece {cons("SingleAtom")}
    Atom Quantifier            -> Piece {cons("QuantifiedAtom")}

  sorts Quantifier
  context-free syntax
   "{" Integer "}"              -> Quantifier {cons("GreedyExactBound")}
   "{" Integer "," "}"          -> Quantifier {cons("GreedyLowerBound")}
   "{" Integer "," Integer "}"  -> Quantifier {cons("GreedyLowerUpperBound")}
   "?"                          -> Quantifier {cons("GreedyOnceOrNot")}
   "*"                          -> Quantifier {cons("GreedyZeroOrMore")}
   "+"                          -> Quantifier {cons("GreedyOneOrMore")}
   "{" Integer "}?"             -> Quantifier {cons("ReluctantExactBound")}
   "{" Integer "," "}?"         -> Quantifier {cons("ReluctantLowerBound")}
   "{" Integer "," Integer "}?" -> Quantifier {cons("ReluctantLowerUpperBound")}
   "??"                         -> Quantifier {cons("ReluctantOnceOrNot")}
   "*?"                         -> Quantifier {cons("ReluctantZeroOrMore")}
   "+?"                         -> Quantifier {cons("ReluctantOneOrMore")}  
   "{" Integer "}+"             -> Quantifier {cons("PossessiveExactBound")}
   "{" Integer "," "}+"         -> Quantifier {cons("PossessiveLowerBound")}
   "{" Integer "," Integer "}+" -> Quantifier {cons("PossessiveLowerUpperBound")}
   "?+"                         -> Quantifier {cons("PossessiveOnceOrNot")}
   "*+"                         -> Quantifier {cons("PossessiveZeroOrMore")}
   "++"                         -> Quantifier {cons("PossessiveOneOrMore")}   

  sorts Atom
  context-free syntax
    "("   Pattern ")"          -> Atom {cons("Capture")}
    "(?:" Pattern ")"          -> Atom {cons("NonCapture")}
    "(?=" Pattern ")"          -> Atom {cons("PositiveLookahead")}
    "(?!" Pattern ")"          -> Atom {cons("NegativeLookahead")}
    "(?<=" Pattern ")"         -> Atom {cons("PositiveLookbehind")}
    "(?<!" Pattern ")"         -> Atom {cons("NegativeLookbehind")}
    "(?P<" RegexId ">" Pattern ")"  -> Atom {cons("PythonCapture")}
    "(" Pattern ")@{" RegexId "}"   -> Atom {cons("RegexCapture")}
    "()"                       -> Atom {cons("Empty")}
    "."                        -> Atom {cons("SingleCharacter")}
    "^"                        -> Atom {cons("LineStart")}
    "$"                        -> Atom {cons("LineEnd")}
    CharacterClass             -> Atom {cons("CharacterClass")}
    AtomLiteral                -> Atom {cons("AtomLiteral")}
    AtomCharacter              -> Atom {cons("AtomCharacter")}
    "\\Q" AllChars "\\E"       -> Atom {cons("QuotedAtom")}    
    
  sorts CharacterClass BracketItem
  context-free syntax
    "[" BracketItem+ "]"       -> CharacterClass {cons("BracketList")}
    "[^" BracketItem+ "]"      -> CharacterClass {cons("NegatedBracketList")}
%%d "\\p\{" ClassKeyword "\}"   -> CharacterClass {cons("PredefineClass")}
%%d "\\P\{" ClassKeyword "\}"   -> CharacterClass {cons("NegatedPredefineClass")}
   

    (BracketLiteral | BracketCharacter)
     "-" 
    (BracketLiteral | BracketCharacter)   -> BracketItem {cons("Range")}
    CharacterClass                        -> BracketItem {cons("Union")}
%%d "\&\&" CharacterClass                 -> BracketItem {cons("Intersection")}
    BracketLiteral                        -> BracketItem {cons("BracketLiteral")}
    BracketCharacter                      -> BracketItem {cons("BracketCharacter")}
   

%%
 %%   Defining characterclasses
  %% 
sorts ClassKeyword
  context-free syntax    
    "Lower"                    -> ClassKeyword {cons("LowerClass")}
    "Upper"                    -> ClassKeyword {cons("UpperClass")}
    "ASCII"                    -> ClassKeyword {cons("ASCIIClass")}
    "Alpha"                    -> ClassKeyword {cons("AlphaClass")}
    "Digit"                    -> ClassKeyword {cons("DigitClass")}
    "Alnum"                    -> ClassKeyword {cons("AlnumClass")}
    "Punct"                    -> ClassKeyword {cons("PunctClass")}
    "Graph"                    -> ClassKeyword {cons("GraphClass")}
    "Print"                    -> ClassKeyword {cons("PrintClass")}
    "Blank"                    -> ClassKeyword {cons("BlankClass")}
    "Cntrl"                    -> ClassKeyword {cons("CntrlClass")}
    "XDigit"                   -> ClassKeyword {cons("XDigitClass")}
    "Space"                    -> ClassKeyword {cons("WhiteSpace")}
    "javaLowerCase"            -> ClassKeyword {cons("JavaIsLowerCase")}
    "javaUpperCase"            -> ClassKeyword {cons("JavaIsLowerCase")}
    "javaWhitespace"           -> ClassKeyword {cons("JavaIsWhitespace")}
    "javaMirrored"             -> ClassKeyword {cons("JavaIsMirrored")}
    "InGreek"                  -> ClassKeyword {cons("GreekBlock")}
    "Lu"                       -> ClassKeyword {cons("UppercaseLetter")}
    "Sc"                       -> ClassKeyword {cons("CurrencySymbol")}

%%
 %%   Defining the Character -> Characters that appear as Atom and in Brackets  
  %%   

%%  ASCII characters:  
%%  $*+?.{}()                             %% OnlyBranchSpecial
%%  &]-                                   %% OnlyClassSpecial
%%  [^\                                   %% AlwaysSpecial
%%  !"#%',/:;<=>@_`~                      %% NeverSpecialCharacter
%%  ABCDEFGHIJKLMNOPQRSTUVWXYZ            %% Character
%%  abcdefghijklmnopqrstuvwxyz            %% Charater
%%  0123456789                            %% Charater
%%  <tab> <newline> <return> <form-feed>  %% SpecialEscapeCharacter


  sorts BracketLiteral AtomLiteral AllChars
  lexical syntax
    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\$\*\+\?\.\}\|]
                                                  -> BracketLiteral
    "/"                                           -> BracketLiteral 
    [\&\]\-]                                      -> BracketLiteral {reject}
    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\&\]\-]
                                                  -> AtomLiteral
    "/"                                           -> AtomLiteral
    [\}\)\|\[]                                    -> AtomLiteral {reject}
    
    [\\\|\$\*\+\?\.\{\}\(\)\&\]\-\[\^\!\#\%\'\,\:\;\<\=\>\@\_\`\~a-zA-Z0-9\t\n\r]*              
          -> AllChars
    "/"   -> AllChars
    "\""  -> AllChars {cons("DoubleQuote") }
    
   lexical restrictions                                                 
   AtomLiteral -/- [\n]
     
  sorts BracketCharacter AtomCharacter
  context-free syntax
%%d    "\{"                -> BracketCharacter {cons("CurlyBraceOpen") }
%%d    "\{"                -> AtomCharacter    {cons("CurlyBraceOpen"), avoid}
    "\""                -> BracketCharacter {cons("DoubleQuote") }
    "\""                -> AtomCharacter    {cons("DoubleQuote") }
%%d    "\)"                -> BracketCharacter {cons("BraceClose"), avoid }
%%d    "\)"                -> AtomCharacter    {cons("BraceClose") }


%%
 %%   Escaping with a '\' to express a special character
  %%
  context-free syntax
    "\\0" OctalValue       -> BracketCharacter {cons("OctalChar")}
    "\\x" TwoHexValue      -> BracketCharacter {cons("HexHexChar")}
    "\\u" FourHexValue     -> BracketCharacter {cons("DecHexChar")}
    "\\t"                  -> BracketCharacter {cons("Tab")}
    "\\n"                  -> BracketCharacter {cons("Newline")}
    "\\r"                  -> BracketCharacter {cons("Return")}
    "\\f"                  -> BracketCharacter {cons("Formfeed")}
    "\\a"                  -> BracketCharacter {cons("Alarm")}
    "\\e"                  -> BracketCharacter {cons("Escape")}
    "\\w"                  -> BracketCharacter {cons("WordChar")}
    "\\W"                  -> BracketCharacter {cons("NonWordChar")}
    "\\s"                  -> BracketCharacter {cons("WhiteSpaceChar")}
    "\\S"                  -> BracketCharacter {cons("NonWhiteSpaceChar")}
    "\\d"                  -> BracketCharacter {cons("DigitChar")}
    "\\D"                  -> BracketCharacter {cons("NonDigitChar")}
    "\\c" ControlValue     -> BracketCharacter {cons("ControlCharacter")}
    "\\b"                  -> BracketCharacter {cons("WordBoundry")}
    "\\B"                  -> BracketCharacter {cons("NonWordBoundry")}
    "\\A"                  -> BracketCharacter {cons("InputBeginBoundry")}
    "\\G"                  -> BracketCharacter {cons("PrevMatchEndBoundry")}
    "\\Z"                  -> BracketCharacter {cons("EndInputBoundry")}
    "\\z"                  -> BracketCharacter {cons("EndInputFinalBoundry")}
    "\\" BackReference     -> BracketCharacter {cons("BackReference")}
    "\\ "                  -> BracketCharacter {cons("Space")}
    "\\\t"                 -> BracketCharacter {cons("Tab")}
%%d    "\\\r"                 -> BracketCharacter {cons("Return")}
    "\\\n"                 -> BracketCharacter {cons("Newline")}
    
    "\\0" OctalValue       -> AtomCharacter {cons("OctalChar")}
    "\\x" TwoHexValue      -> AtomCharacter {cons("HexHexChar")}
    "\\u" FourHexValue     -> AtomCharacter {cons("DecHexChar")}
    "\\t"                  -> AtomCharacter {cons("Tab")}
    "\\n"                  -> AtomCharacter {cons("Newline")}
    "\\r"                  -> AtomCharacter {cons("Return")}
    "\\f"                  -> AtomCharacter {cons("Formfeed")}
    "\\a"                  -> AtomCharacter {cons("Alarm")}
    "\\e"                  -> AtomCharacter {cons("Escape")}
    "\\w"                  -> AtomCharacter {cons("WordChar")}
    "\\W"                  -> AtomCharacter {cons("NonWordChar")}
    "\\s"                  -> AtomCharacter {cons("WhiteSpaceChar")}
    "\\S"                  -> AtomCharacter {cons("NonWhiteSpaceChar")}
    "\\d"                  -> AtomCharacter {cons("DigitChar")}
    "\\D"                  -> AtomCharacter {cons("NonDigitChar")}
    "\\c" ControlValue     -> AtomCharacter {cons("ControlCharacter")}
    "\\b"                  -> AtomCharacter {cons("WordBoundry")}
    "\\B"                  -> AtomCharacter {cons("NonWordBoundry")}
    "\\A"                  -> AtomCharacter {cons("InputBeginBoundry")}
    "\\G"                  -> AtomCharacter {cons("PrevMatchEndBoundry")}
    "\\Z"                  -> AtomCharacter {cons("EndInputBoundry")}
    "\\z"                  -> AtomCharacter {cons("EndInputFinalBoundry")}
    "\\" BackReference     -> AtomCharacter {cons("BackReference")}
    "\\ "                  -> AtomCharacter {cons("Space")}
    "\\\t"                 -> AtomCharacter {cons("Tab")}
%%d    "\\\r"                 -> AtomCharacter {cons("Return")}
    "\\\n"                 -> AtomCharacter {cons("Newline")}
    
%%
 %%   Quoting of symbols is always allowed to express that symbol
  %%
  sorts QuotablePatternSymbol
  context-free syntax
    "\\" QuotablePatternSymbol            -> AtomCharacter {cons("Quoted")}
    "\\" QuotablePatternSymbol            -> BracketCharacter {cons("Quoted")}    
  lexical syntax
    [\|\$\*\+\?\.\{\}\(\)\&\]\[\-\^\\\!\#\%\'\,\:\;\<\=\>\@\_\`\~\/]
                                   -> QuotablePatternSymbol
  context-free syntax
    "\""                -> QuotablePatternSymbol {cons("DoubleQuote") }
    "\""                -> QuotablePatternSymbol {cons("DoubleQuote") }    
%%
 %%   Defining integers and number values
  %% 
  sorts Integer OctalValue TwoHexValue FourHexValue BackReference ControlValue
  lexical syntax      
    [0-9]+                                       -> Integer
    [1-9] [0-9]*                                 -> BackReference
    [0-7]                                        -> OctalValue
    [0-7][0-7]                                   -> OctalValue
    [0-3][0-7][0-7]                              -> OctalValue
    [0-9A-Fa-f][0-9A-Fa-f]                       -> TwoHexValue
    [0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f] -> FourHexValue
    [0-9]                                        -> ControlValue
    [0-9][0-9]                                   -> ControlValue

%%d  lexical restrictions
%%d    "/"  -/- [\]]
%%d    "\\" -/- [\ \t\12\n\r]   
    
    
exports
  sorts
    RegexId
    RegexID

  context-free syntax
    RegexID -> RegexId {cons("RegexId")}

  lexical syntax
    [A-Za-z\_\$][A-Za-z0-9\_\$]* -> RegexID
    
    "true"  -> RegexID {reject}
    "false" -> RegexID {reject}
    "null"  -> RegexID {reject}

  lexical restrictions
    RegexID -/- [a-zA-Z0-9\_\$]

module WebDSL-CSS

exports
  sorts TemplateElement
  context-free syntax
    "<" "style" Attribute* ">"
    JSParts
    "</" "style" ">"
    -> TemplateElement { cons("StyleElement"), prefer}

module WebDSL-JavaScript
  
exports 
  sorts TemplateElement
  context-free syntax
    "<" "script" Attribute* ">" 
    %%todo: should be javascript embedding
    JSParts
    "</" "script" ">"
    -> TemplateElement { cons("JSElement"), prefer}

  syntax  %% in kernel syntax to preserve spaces after ~exp, e.g. in a jquery selector $('~id span')
    JSPart*        -> <JSParts-CF>

	"~" <Exp-CF>   -> JSPart{cons("JSExp"), prefer}
	<JSString-LEX> -> JSPart{cons("JSString")}
    "\\~"          -> JSPart{cons("JSTilde"), prefer}

  sorts JSChar JSString
  lexical syntax
    JSChar+     -> JSString
    ~[\<\~]     -> JSChar
    SmallerThan -> JSChar
    [\<]        -> SmallerThan
 
    %% otherwise a '<' can split the JSString causing ambiguity, because '<' is allowed in follow restriction below for ending JSString with </script>
    [\<] JSChar* -> JSString{reject}

  lexical restrictions
    SmallerThan -/- [\/]
    JSString    -/- ~[\<\~]

module WebDSL-XML

exports
  context-free syntax

    "<" QualName Attribute* "/>" -> TemplateElement {cons("XMLEmptyElement")}

    "<" QualName Attribute* ">"
      TemplateElement*
    "</" QualName ">" -> TemplateElement {cons("XMLElement")}

  %% http://www.w3.org/html/wg/drafts/html/master/single-page.html#void-elements
  context-free syntax
    "<" HTML5VoidElement Attribute* ">" -> TemplateElement {cons("XMLEmptyElementUnclosed")}
  lexical syntax
    "area" -> HTML5VoidElement
    "base" -> HTML5VoidElement
    "br" -> HTML5VoidElement
    "col" -> HTML5VoidElement
    "embed" -> HTML5VoidElement
    "hr" -> HTML5VoidElement
    "img" -> HTML5VoidElement
    "input" -> HTML5VoidElement
    "keygen" -> HTML5VoidElement
    "link" -> HTML5VoidElement
    "menuitem" -> HTML5VoidElement
    "meta" -> HTML5VoidElement
    "param" -> HTML5VoidElement
    "source" -> HTML5VoidElement
    "track" -> HTML5VoidElement
    "wbr" -> HTML5VoidElement

  %% <!-- --> comments
  context-free syntax
    XMLComment -> TemplateElement {cons("XMLComment")}
  lexical syntax
    "<!--" XMLCommentChar* "-->" -> XMLComment
    ~[\-]                        -> XMLCommentChar
    OneDash                      -> XMLCommentChar
    TwoDashes                    -> XMLCommentChar
    [\-]                         -> OneDash
    [\-][\-]                     -> TwoDashes
  lexical restrictions
    OneDash   -/- [\-]
    TwoDashes -/- [\>]

  context-free syntax %% if(){} and if(){}else{} inside an XML element containing a list of attributes

    "if" "(" Exp ")" "{" Attribute* "}"		          -> Attribute {cons("XMLAttributesIf")}
    "if" "(" Exp ")" "{" Attribute* "}" "else" "{" Attribute* "}" -> Attribute {cons("XMLAttributesIfElse")}

  context-free syntax

    QualName "=" Exp -> Attribute {cons("Attribute")}

    %%easy injection of attributes from template call
    CommonAttribute -> Attribute
    "all attributes"  -> CommonAttribute {cons("AllAttributes")}
    "all attributes except" Exp        -> CommonAttribute {cons("AllAttributeExceptExp")}
    "attributes" Exp        -> CommonAttribute {cons("AttributesExp")}

    "attributes" -> KEYWORD

exports

  lexical syntax
    Qualifier? NCName -> QualName
    NCName ":"        -> Qualifier


    [A-Za-z\_] [A-Za-z0-9\.\-\_]* -> NCName

  lexical restrictions
    NCName -/- [A-Za-z0-9\.\-\_]

module WebDSL-AccessControl

imports
  WebDSL-UI
  WebDSL-Action
  WebDSL-DataModel
  WebDSL-Lexical

%% syntax for access control  
exports

  sorts MatchId

  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_\-]*[\*]? -> MatchId
    [\*]                          -> MatchId
    [\*]                          -> WildCardArg 

context-free syntax

  "access" "control" "rules" Id? AccessControlDefinition*  -> Section {cons("AccessControlDefinition")}
  %%deprecated: 
  "access" "control" "rules" "{" Id? AccessControlDefinition* "}"  -> Section {cons("AccessControlDefinition")}
  
  "principal" "is" Id "with" "credentials" {Id ","}+            -> Definition {cons("AccessControlPrincipal")} 
  "principal" "is" Id "with" "credentials" {Id ","}+            -> AccessControlDefinition {cons("AccessControlPrincipal")} 
  
  AccessControlRule                                             -> AccessControlDefinition
 
  "rule" Id MatchId OptMatchArgs
  "{" AccessControlCheck AccessControlRule* "}"                 -> AccessControlRule {cons("AccessControlRule")}

  "(" MatchArgs ")"             -> OptMatchArgs {ast("<1>")}
                                -> OptMatchArgs {ast("MatchArgs([],None())")}
  {FormalArg ","}* WildCardArg? -> MatchArgs {cons("MatchArgs"),prefer}
  {Exp ","}* WildCardArg?       -> MatchArgs {cons("MatchArgs")}

  Exp                                                           -> AccessControlCheck
  
  %% special rules, e.g. to protect ?logsql
  "rule" Id "{" AccessControlCheck "}"                 -> AccessControlRule {cons("SpecialAccessControlRule")}  
  
  %% pagecheck
  %%"pagecheck" "<" Id "," Exp ">"  -> TemplateElement {cons("PageCheck"),prefer}
  %%"pagecheck" "(" Id "," Exp ")"  -> TemplateCall {reject}
  %%"pagecheck" "(" {Exp ","}* ")"                          -> TemplateCall {reject}
  
  "predicate" Id OptFormalArgs "{" Exp "}" -> Definition {cons("Predicate")}
  "predicate" Id OptFormalArgs "{" Exp "}" -> AccessControlDefinition {cons("Predicate")}
  "predicate" Id OptFormalArgs "{" Exp "}" -> EntityBodyDeclaration {cons("PredicateInEntity")}
  
  Id MatchId "(" {Id ","}* WildCardArg? ")"                     -> AccessControlPointcutElement {cons("AccessControlPointcutElement")}
  
  "pointcut" Id "(" {FormalArg ","}* ")"
    "{" {AccessControlPointcutElement ","}* "}"                 -> AccessControlPointcut {cons("AccessControlPointcut")}
  
  AccessControlPointcut                                         -> AccessControlDefinition
  
  %%construct to import checks of another page or template, necessary for easily applying ac rules to lifted templates
  "apply ac rules" Id "(" {AccessControlImportRulesArg ","}* ")" -> TemplateElement {cons("AccessControlImportRules"), prefer}
  Id -> AccessControlImportRulesArg {cons("Var")} %%only vars supported, enough for current usage, see languages/access-control/access-control.str
  
context-free syntax  
  
  "access" "control" "policy" PolicyExp                         -> Section {cons("ACPolicy")}
  
  Id                                 -> PolicyExp {cons("Name")}
  "(" PolicyExp ")"                  -> PolicyExp {bracket}
  PolicyExp "AND" PolicyExp          -> PolicyExp {cons("PolicyAnd"), assoc}
  PolicyExp "OR" PolicyExp           -> PolicyExp {cons("PolicyOr"), assoc}
  
  
  %% hack for allowing multiple function checks to be added in different stages to a function call
  %%"acfunctioncheck" "(" Id "," Exp ")" Exp -> Exp {cons("ACFunctionCheck"), prefer}
  
context-free priorities
  {left:
       PolicyExp "AND" PolicyExp -> PolicyExp}
  > {left:
       PolicyExp "OR" PolicyExp -> PolicyExp}

context-free priorities
    Exp "in" Exp  -> Exp
  > Exp -> AccessControlCheck

context-free syntax
  
  "ignore-access-control" -> Modifier {cons("IgnoreAccessControl")}

module WebDSL-DataValidation

exports

  context-free syntax

    "validatecreate" "(" Exp "," Exp ")" -> Annotation {cons("ValidateCreateAnno"),prefer}
    "validateupdate" "(" Exp "," Exp ")" -> Annotation {cons("ValidateUpdateAnno"),prefer}
    "validatedelete" "(" Exp "," Exp ")" -> Annotation {cons("ValidateDeleteAnno"),prefer}
    "validate" "(" Exp "," Exp ")" -> Annotation {cons("ValidateAnno"),prefer}
    Id ":" "validate" "(" Exp "," Exp ")" -> Annotation {cons("NamedValidateAnno"),prefer}
    
    ValidateEntity -> EntityBodyDeclaration
    "validate" "(" Exp "," Exp ")" -> ValidateEntity {cons("ValidateEntity"),prefer}
    
    "validate" "(" Exp "," Exp ")" ";" -> Statement {cons("ValidateStatement"),prefer}
    Id ":" "validate" "(" Exp "," Exp ")" ";" -> Statement {cons("NamedValidateStatement"),prefer}
    
    "validationErrors" "(" Id ")" -> TemplateCall {cons("ValidationErrors"),prefer}
    "validationErrors" "(" ")" -> TemplateCall {cons("ValidationErrors"),prefer}

module WebDSL-DataModel

imports
  WebDSL-Action
  WebDSL-Lexical

exports

  context-free syntax

    "globals" "{" GlobalsDef* "}"                        -> Definition {prefer,cons("GlobalsDefinition"),deprecated("'globals{ }' block is no longer necessary around global variables and functions")}

    "entity" Id ":" Id "{" EntityBodyDeclaration* "}"       -> Entity {cons("Entity")}
    "entity" Id "{" EntityBodyDeclaration* "}"              -> Entity {cons("EntityNoSuper")}
    "session" Id "{" EntityBodyDeclaration* "}"             -> Entity {cons("SessionEntity")}
    Property -> EntityBodyDeclaration
    Function -> EntityBodyDeclaration
    StaticEntityFunction -> EntityBodyDeclaration
    "cache" -> EntityBodyDeclaration {cons("CachedEntity")}

    Entity                                   		     -> Definition

    "extend" "entity" Id "{" EntityBodyDeclaration* "}"	 -> Definition {cons("ExtendEntity")}
    "extend" "session" Id "{" EntityBodyDeclaration* "}"   -> Definition {cons("ExtendSessionEntity")}

  context-free restrictions
    "cache" -/- [a-zA-Z0-9\_] %% prevent ambiguity between CachedEntity and a property id beginning with cache

exports

  sorts Entity Property Sort Annotation

  context-free syntax

    "var" Id ":" Sort 	       -> GlobalVarDecl {cons("GlobalVarDecl")} %% not allowed, global vars need an initializer, still parsed to give clear error message from analysis
    "var" Id ":" Sort ":=" Exp -> GlobalVarDecl {cons("GlobalVarDeclInit")}
    "var" Id ":=" Exp          -> GlobalVarDecl {cons("GlobalVarDeclInitInferred")}
    "var" Id ":" Sort ";" 	       -> GlobalVarDecl {cons("GlobalVarDecl"),deprecated("remove ';' from global variable declaration")}
    "var" Id ":" Sort ":=" Exp ";" -> GlobalVarDecl {cons("GlobalVarDeclInit"),deprecated("remove ';' from global variable declaration")}
    "var" Id ":=" Exp ";"          -> GlobalVarDecl {cons("GlobalVarDeclInitInferred"),deprecated("remove ';' from global variable declaration")}

    "request" GlobalVarDecl    -> Definition {cons("RequestScope")}
    GlobalVarDecl              -> GlobalsDef
    Function                   -> GlobalsDef
    GlobalsDef                 -> Definition
    InitAction                 -> Definition

exports

  sorts Property Annotation

  context-free syntax

    Id PropKind Sort OptPropAnnos          -> Property {cons("Property")}
    Id PropKind Sort OptPropAnnos ":=" Exp -> Property {cons("DerivedProperty")}

    "(" {Annotation ","}* ")" -> OptPropAnnos {ast("<1>")}
                              -> OptPropAnnos {ast("[]")}

    "::" -> PropKind {cons("Simple")}
    "->" -> PropKind {cons("Ref")}
    "<>" -> PropKind {cons("Comp")}
    ":"  -> PropKind {cons("AnyProp")}

  sorts Sort

  context-free syntax

%% explicit syntax makes the annotations highlighted as keyword in the editor
%% removed generic SingleParamAnno due to http://yellowgrass.org/issue/StrategoXT/825

    Id                           -> Annotation {cons("SimpleAnno")}
    "inverse" "=" Id "." Id      -> Annotation {cons("InverseAnno")}
    %%fallback for code completion:
    "inverse" "=" Id             -> Annotation {cons("IncompleteInverseAnno")}
    "inverseSlave" "=" Id "." Id -> Annotation {cons("InverseSlaveAnno")}
    "inverse-reference-only"      -> Annotation {cons("InverseReferenceOnlyAnno")} %% only allowed on Set property with inverse
    "inline" "(" {Id ","}* ")"   -> Annotation {cons("InlineAnno")}
    "select" "=" Id              -> Annotation {cons("SelectAnno")}
    "not null"                   -> Annotation {cons("NotNullAnno")}
    "not empty"                  -> Annotation {cons("NotEmptyAnno")}
    "allowed" "=" Exp            -> Annotation {cons("AllowedAnno")}
    "default" "=" Exp            -> Annotation {cons("DefaultAnno")}
    "length" "=" Int             -> Annotation {cons("LengthAnno")}
    "format" "=" String          -> Annotation {cons("FormatAnno")}
    "index" "(" ")"              -> Annotation {cons("IndexAnno")}
    "index" "(" Int ")"          -> Annotation {cons("IndexAnno")}
    "collation" "(" Id ")"       -> Annotation {cons("CollationAnno")}
    "iderror" "=" String         -> Annotation {cons("IdErrorAnno")}
    "idemptyerror" "=" String    -> Annotation {cons("IdEmptyErrorAnno")}

module HQL

hiddens
  context-free start-symbols QueryRule Statement
  
exports
  lexical syntax
    [a-zA-Z\_][a-zA-Z0-9\_]* -> Identifier
  lexical restrictions
    Identifier -/- [a-zA-Z0-9\_]
    "from" -/- [a-zA-Z0-9\_]
    "select" -/- [a-zA-Z0-9\_]
    
  context-free syntax
   
    "from" | "select" | "by" | "order" -> Identifier {reject}
    
exports

  sorts Statement UpdateStatement DeleteStatement SelectStatement InsertStatement
  
  context-free syntax

    "delete" FromClause WhereClause? -> DeleteStatement {cons("DeleteStatement")}
    
    SelectStatement -> Statement

    QueryRule -> SelectStatement

    QueryRule "union" QueryRule -> Union {cons("QueryUnion")}

    SelectFrom WhereClause? GroupByClause? OrderByClause? -> QueryRule {cons("QueryRule")}
    
    SelectClause? FromClause -> SelectFrom {cons("SelectFrom")}
    
    "select" Distinct? Selection -> SelectClause {cons("Select")}

    "distinct"                   -> Distinct {cons("Distinct")}
    
    SelectedPropertiesList -> Selection
    NewExpression          -> Selection
    SelectObject           -> Selection

    QueryRule              -> Expression {avoid}
    
  "new" Path "(" SelectedPropertiesList ")" -> NewExpression {cons("NewExpression")}
  
  "object" "(" Identifier ")" -> SelectObject {cons("SelectObject")}
  
    "from" {FromRangeJoin ","}+ -> FromClause {cons("FromClause")}
    
    FromRange FromJoin* -> FromRangeJoin {cons("FromRangeJoin")}
    
    "left"          -> JoinType {cons("LeftJoin")}
    "right"         -> JoinType {cons("RightJoin")}
    "left"  "outer" -> JoinType {cons("LeftOuterJoin")}
    "right" "outer" -> JoinType {cons("RightOuterJoin")}
    "full"          -> JoinType {cons("FullJoin")}
    "inner"         -> JoinType {cons("InnerJoin")}
    
    JoinType? "join" Fetch? Path AsAlias? PropertyFetch? WithClause? -> FromJoin {cons("FromJoin")}
    
    "fetch" -> Fetch {cons("Fetch")}
        
  "with" Expression -> WithClause {cons("WithClause")}
  
    FromClassOrOuterQueryPath       -> FromRange
    InClassDeclaration              -> FromRange
    InCollectionDeclaration         -> FromRange
    InCollectionElementsDeclaration -> FromRange
    
    Path AsAlias? PropertyFetch? -> FromClassOrOuterQueryPath {cons("FromClass")}
    
    Alias "in" "class" Path -> InClassDeclaration {cons("InClassDeclaration")}
    
    "in" "(" Path ")" Alias -> InCollectionDeclaration {cons("InCollection")}
    
    Alias "in" "elements" "(" Path ")" -> InCollectionElementsDeclaration {cons("InCollectionElements")}

    "as" Alias -> AsAlias {cons("AsAlias")}
  
    Identifier -> Alias {cons("Alias")}
  
  
    "fetch" "all" "properties" -> PropertyFetch {cons("PropertyFetch")}
    
    "group" "by" {Expression ","}+ HavingClause? -> GroupByClause {cons("GroupBy")}
    
    "order" "by" {OrderElement ","}+ -> OrderByClause {cons("OrderByClause")}
    
    Expression AscendingOrDescending? -> OrderElement {cons("OrderElement")}
    
   "asc"       -> AscendingOrDescending {cons("Ascending")}
   "ascending" -> AscendingOrDescending {cons("Ascending")}
   
   "desc"      -> AscendingOrDescending {cons("Descending")}
   "descending" -> AscendingOrDescending {cons("Descending")}
   
    "having" Expression -> HavingClause {cons("HavingClause")}
    
    "where" Expression -> WhereClause {cons("WhereClause")}
    
    { AliasedExpression ","}+ -> SelectedPropertiesList {cons("SelectedPropertiesList")}
    
    %%QuotedAliasedExpression -> OptionallyQuotedAliasedExpression
    %%AliasedExpression       -> OptionallyQuotedAliasedExpression
    
    "'" Expression AsAlias? "'" -> QuotedAliasedExpression {cons("QuotedAliasedExpression")}
    Expression AsAlias? -> AliasedExpression {cons("AliasedExpression")}
    
   Expression "or" Expression -> Expression {cons("QueryOr")}
   
    Expression "and" Expression -> Expression {cons("QueryAnd")}
    
    "not" Expression -> Expression {cons("QueryNot")}
    
    Expression "=" Expression -> Expression {cons("EQ")}
    Expression "is" Expression -> Expression {cons("IS")}
    Expression "!=" Expression -> Expression {cons("NE")}
    Expression "<>" Expression -> Expression {cons("SQLNE")}
    Expression "like" Expression -> Expression {cons("LIKE")}
    Expression "not" "like" Expression -> Expression {cons("NOTLIKE")}

    Expression "<" Expression -> Expression {cons("LT")}
    Expression "<=" Expression -> Expression {cons("LE")}
    Expression ">" Expression -> Expression {cons("GT")}
    Expression ">=" Expression -> Expression {cons("GE")}
    
    Expression "in" Expression -> Expression {cons("In")}
    Expression "not" "in" Expression -> Expression {cons("NotIn")}
    
    Expression "member" "of" Expression -> Expression {cons("MemberOf")}
    Expression "not" "member" "of" Expression -> Expression {cons("NotMemberOf")}
  
    Expression "||" Expression -> Expression {cons("Concat")}
    
    Expression "+" Expression -> Expression {cons("Plus")}
    Expression "-" Expression -> Expression {cons("Minus")}

    Expression "*" Expression -> Expression {cons("Multiply")}
    Expression "/" Expression -> Expression {cons("Divide")}
    Expression "%" Expression -> Expression {cons("Modulo")}
    
    "-" Expression -> Expression {cons("UMinus")}
    
    %% current_date(), current_time(), and current_timestamp()
    "current_date" "(" ")" -> Expression {cons("HQLFunCurDate")}
    "current_time" "(" ")" -> Expression {cons("HQLFunCurTime")}
    "current_timestamp" "(" ")" -> Expression {cons("HQLFunCurTimestamp")}
    %% second(...), minute(...), hour(...), day(...), month(...), and year(...)
    "second" "(" Expression ")" -> Expression {cons("HQLFunSecond")} 
    "minute" "(" Expression ")" -> Expression {cons("HQLFunMinute")} 
    "hour" "(" Expression ")" -> Expression {cons("HQLFunHour")} 
    "day" "(" Expression ")" -> Expression {cons("HQLFunDay")} 
    "month" "(" Expression ")" -> Expression {cons("HQLFunMonth")} 
    "year" "(" Expression ")" -> Expression {cons("HQLFunYear")} 
    
   lexical syntax 
     ":" Identifier -> IdParameter 
     "?" NumInt     -> NumParameter
   context-free syntax
     IdParameter -> Expression {cons("IdParam")}
     NumParameter -> Expression {cons("NumParam")}
   
    "avg" "(" Expression ")" -> Expression {cons("Avg")}
    "sum" "(" Expression ")" -> Expression {cons("Sum")}
    "min" "(" Expression ")" -> Expression {cons("Min")}
    "max" "(" Expression ")" -> Expression {cons("Max")}
    "count" "(" "*" ")" -> Expression {cons("CountStar")}
    "count" "(" Expression ")" -> Expression {cons("Count")}
    "size" "(" Expression ")" -> Expression {cons("Size")}
    "substring" "(" Expression "," Expression "," Expression ")" -> Expression {cons("SubString")}
    
     "elements" "(" Path ")" -> Expression {cons("Elements")}
     "indices" "(" Path ")" -> Expression {cons("Indices")}
                     
     Path                      -> Expression
     "(" {Expression ","}+ ")" -> Expression {cons("Paren")}
     "(" QueryRule ")"         -> Expression {cons("Paren"), prefer}
     
    Constant -> Expression
    
    "true" -> Constant {cons("True")}
    "false" -> Constant {cons("False")}
    "empty" -> Constant {cons("Empty")}
    "null" -> Constant {cons("Null")}

    "true" -> Identifier {reject}
    "false" -> Identifier {reject}
    "empty" -> Identifier {reject}
    "null"  -> Identifier {reject}
    
    {Identifier "."}+ -> Path {cons("Path")} 
    
  context-free syntax
    QuotedString -> Constant {cons("HqlString")}
    
  lexical syntax
    "'" (~[\'] | "\\'")* "'" -> QuotedString
     
  lexical syntax
    [0-9]+ -> NumInt
  context-free syntax
    NumInt -> Constant
  
context-free priorities
  {
    {Identifier "."}+ -> Path
    "(" {Expression ","}+ ")" -> Expression
    "avg" "(" Expression ")" -> Expression
    "sum" "(" Expression ")" -> Expression
    "min" "(" Expression ")" -> Expression
    "max" "(" Expression ")" -> Expression
    "count" "(" "*" ")" -> Expression
    "count" "(" Expression ")" -> Expression
    "size" "(" Expression ")" -> Expression
    "elements" "(" Path ")" -> Expression
    "indices" "(" Path ")" -> Expression
    "-" Expression -> Expression
  }
  > {left:
    Expression "*" Expression -> Expression
    Expression "/" Expression -> Expression
    Expression "%" Expression -> Expression
    Expression "||" Expression -> Expression
  }
  > {left:
    Expression "+" Expression -> Expression
    Expression "-" Expression -> Expression
  }
  > {left:
    Expression "<" Expression -> Expression
    Expression "<=" Expression -> Expression
    Expression ">" Expression -> Expression
    Expression ">=" Expression -> Expression
    Expression "like" Expression -> Expression 
    Expression "not" "like" Expression -> Expression
    Expression "in" Expression -> Expression
    Expression "not" "in" Expression -> Expression
    Expression "member" "of" Expression -> Expression
    Expression "not" "member" "of" Expression -> Expression
    }
  > {left:
    Expression "=" Expression -> Expression
    Expression "is" Expression -> Expression
    Expression "!=" Expression -> Expression
    Expression "<>" Expression -> Expression
    }
  > "not" Expression -> Expression
  > {left: Expression "and" Expression -> Expression}
  > {left: Expression "or" Expression -> Expression }

module MixHQL[Ctx0]
imports 
        HQL
          [ Constant                        => Constant[[Ctx0]]
            AliasedExpression               => AliasedExpression[[Ctx0]]
            QuotedAliasedExpression         => QuotedAliasedExpression[[Ctx0]]
            SelectedPropertiesList          => SelectedPropertiesList[[Ctx0]]
            WhereClause                     => WhereClause[[Ctx0]]
            HavingClause                    => HavingClause[[Ctx0]]
            AscendingOrDescending           => AscendingOrDescending[[Ctx0]]
            OrderElement                    => OrderElement[[Ctx0]]
            OrderByClause                   => OrderByClause[[Ctx0]]
            GroupByClause                   => GroupByClause[[Ctx0]]
            PropertyFetch                   => PropertyFetch[[Ctx0]]
            Alias                           => Alias[[Ctx0]]
            AsAlias                         => AsAlias[[Ctx0]]
            InCollectionElementsDeclaration => InCollectionElementsDeclaration[[Ctx0]]
            InCollectionDeclaration         => InCollectionDeclaration[[Ctx0]]
            InClassDeclaration              => InClassDeclaration[[Ctx0]]
            FromClassOrOuterQueryPath       => FromClassOrOuterQueryPath[[Ctx0]]
            FromRange                       => FromRange[[Ctx0]]
            WithClause                      => WithClause[[Ctx0]]
            Fetch                           => Fetch[[Ctx0]]
            FromJoin                        => FromJoin[[Ctx0]]
            JoinType                        => JoinType[[Ctx0]]
            FromRangeJoin                   => FromRangeJoin[[Ctx0]]
            FromClause                      => FromClause[[Ctx0]]
            SelectObject                    => SelectObject[[Ctx0]]
            NewExpression                   => NewExpression[[Ctx0]]
            Selection                       => Selection[[Ctx0]]
            Distinct                        => Distinct[[Ctx0]]
            SelectClause                    => SelectClause[[Ctx0]]
            SelectFrom                      => SelectFrom[[Ctx0]]
            QueryRule                       => QueryRule[[Ctx0]]
            Union                           => Union[[Ctx0]]
            SelectStatement                 => SelectStatement[[Ctx0]]
            Statement                       => Statement[[Ctx0]]
            DeleteStatement                 => DeleteStatement[[Ctx0]]
            NumInt                          => NumInt[[Ctx0]]
            QuotedString                    => QuotedString[[Ctx0]]
            NumParameter                    => NumParameter[[Ctx0]]
            IdParameter                     => IdParameter[[Ctx0]]
            Identifier                      => Identifier[[Ctx0]]
            Path                            => Path[[Ctx0]]
            Expression                      => Expression[[Ctx0]] ]


module WebDSL-Action

imports
  WebDSL-Lexical
  MixHQL[HQL]

exports

  context-free syntax %% Functions

    "function" Id OptFormalArgs FunctionReturn Block -> Function {cons("Function")}

    -> FunctionReturn {ast("SimpleSort(\"Void\")")}
    ":" Sort -> FunctionReturn {ast("<1>")}

    "cached" Function -> EntityBodyDeclaration {cons("CachedFunction")}
    "cached" Function -> GlobalsDef {cons("CachedGlobalFunction")}

    "extend" Function -> ExtendFunction {cons("ExtendFunction")}
    ExtendFunction -> EntityBodyDeclaration
    ExtendFunction -> GlobalsDef

  %% static entity function

    "static" "function" Id OptFormalArgs ReturnType Block -> StaticEntityFunction {cons("StaticEntityFunction")}

    ":" Sort -> ReturnType{cons("ReturnType")}
    -> ReturnType {ast("ReturnType(SimpleSort(\"Void\"))")}

  context-free syntax %% inline anonymous functions/closures

    FunctionExp -> Exp
    "function" OptFormalArgs FunctionReturn Block -> FunctionExp {cons("FunctionExp")}

    %% reference to a function, something to help desugar lifted function exp
    FunctionRef -> Exp
    "function." Id "(" {Sort ","}* ")" FunctionReturn -> FunctionRef {cons("FunctionRef")}


    FunctionRef "(" {Exp ","}* ")" -> Exp {cons("FunctionRefCall")}
    FunctionRef "(" "*" "," {Exp ","}* ")" -> Exp {cons("FunctionRefCallPartial")}

  context-free syntax
    "{" Statements "}" 		-> Block {cons("Block")}
    Block              		-> Statement
    %%Assignment ";"	   	-> Statement {cons("Assign")}
    Exp ";"		       		-> Statement {cons("Stat")}

    "return" Exp ";"     	-> Statement {cons("Return")}

    "return" ";"         	-> Statement {cons("ReturnEmpty")}

    "goto" PageCall ";"       	-> Statement {cons("GoTo"),prefer}
    "goto" "(" PageCall ")" ";"         -> Statement {cons("GoTo"),prefer}

    "schedule" Exp "for" Exp ";" -> Statement {cons("Schedule")}
    "schedule" Exp ";"           -> Statement {cons("ScheduleNoFor")}

  context-free syntax

    "var" Id ":" Sort ";" 	       -> VarDeclStat {cons("VarDecl")}
    "var" Id ":" Sort ":=" Exp ";" -> VarDeclStat {cons("VarDeclInit")}
    "var" Id ":=" Exp ";"          -> VarDeclStat {cons("VarDeclInitInferred")}
    VarDeclStat -> Statement

  context-free syntax

    "if" "(" Exp ")" Block "else" Block  -> Statement {cons("If")}
    "if" "(" Exp ")" Block               -> Statement {cons("IfNoElse")}
    "if" "(" Exp ")" Block ElseIfStatement+ OptElse  -> Statement {cons("IfWithElseIf")}
    "else" "if" "(" Exp ")" Block  -> ElseIfStatement {cons("ElseIf")}
    "else" Block                   -> OptElse {ast("<1>")}
                                   -> OptElse {ast("Block([])")}

    "case" "(" {Exp ","}+ ")" "{" Case* "}"  -> Statement {cons("CaseStmt")}
    {Exp ","}+ Block                         -> Case {cons("CaseStmtAlt")}
    "default" Block                          -> Case {cons("CaseStmtDefault"), prefer}

    "typecase" "(" TypeCaseExp OptTypeCaseAlias ")" "{" TypeCaseAlt* "}" -> Statement {cons("TypeCaseStmt")}
    -> OptTypeCaseAlias {ast("None()")}
    "as" Id -> OptTypeCaseAlias {ast("<1>")}
    
    %% 'x as y' is ambiguous, but a Cast expression does not make sense in typecase, reject it
    Exp -> TypeCaseExp
    Exp "as" Sort -> TypeCaseExp {reject}

    Sort Block                                          -> TypeCaseAlt {cons("TypeCaseStmtAlt")}
    "default" Block                                     -> TypeCaseAlt {cons("TypeCaseStmtDefault"), prefer}

  context-free syntax %% if in expression:  if(e) e1 else e2

    "if" "(" Exp ")" Exp "else" Exp -> Exp {cons("IfExp")}

  context-free syntax

    "for" "(" Id ":" Sort "in" Exp OptFilter ")"
      Block 				-> Statement {cons("ForStmt")}

    "for" "(" Id "in" Exp OptFilter ")"
      Block 				-> Statement {cons("ForStmtInferred")}

    "for" "(" Id ":" Sort OptFilter ")"
      Block 				-> Statement {cons("ForAllStmt")}

    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" Block -> Statement {cons("ForCountStmt")}
    "for" "(" Id "from" Exp "to" Exp ")" Block -> Statement {cons("ForCountStmt")}

    "while" "(" Exp ")" Block -> Statement {cons("WhileStmt")}

exports %% Expression language

  sorts ConstValue Exp

  context-free syntax
    Int                    -> ConstValue {cons("Int")}
    Long                   -> ConstValue {cons("Long")}
    Float                  -> ConstValue {cons("Float")}
    String                 -> ConstValue

    ConstValue                  -> Exp

    VarId -> Exp {cons("Var")}
    Id    -> VarId

  %% highlight principal as keyword, and make it a shorthand for securityContext.principal
  context-free syntax
    "principal" -> PrincipalId {cons("PrincipalId")}
    PrincipalId -> Exp
    PrincipalId -> SimpleVar  %% allows string interpolation "~principal"
    "principal" -> VarId {reject}
  context-free restrictions
    PrincipalId -/- [a-zA-Z0-9\_]
  context-free syntax

    "in"                   -> Exp {reject}

    "global" "." Id -> Exp {cons("GlobalVar"), prefer}
    "session" "." Id -> Exp {cons("SessionVar"),prefer}

    Exp "." Id             -> Exp {cons("FieldAccess")}

    CollectionExp "[" Exp "]" -> Exp {cons("CollectionIndex")}
    %% CollectionExp is a workaround for a priorities issue in SDF2 related to Exp "[" Exp "]"
    VarId -> CollectionVar {cons("Var")}
    CollectionVar -> CollectionExp
    CollectionCreation -> CollectionExp
    CollectionExp "." Id -> CollectionExp {cons("FieldAccess")}
    Id "(" {Exp ","}* ")" -> CollectionExp {cons("ThisCall")}
    CollectionExp "." Id "(" {Exp ","}* ")" -> CollectionExp {cons("Call")}
    CollectionExp "[" Exp "]" -> CollectionExp {cons("CollectionIndex")}
    ForExp -> CollectionExp
    InvokeTemplate -> CollectionExp
    "(" Exp ")" -> CollectionExp {bracket}

    Sort "{" ObjectPropertyAssignment* "}"         -> ObjectCreation {cons("ObjectCreation")}
    Sort "{" { ObjectPropertyAssignment "," }* "}" -> ObjectCreation {cons("ObjectCreation"), prefer}
    ObjectCreation -> Exp

    Id ":=" Exp           -> ObjectPropertyAssignment {cons("ObjectPropertyAssignment")}
    %% fallback for code completion:
    Id -> ObjectPropertyAssignment {cons("IncompleteObjectPropertyAssignment")}

    Exp ":=" Exp             -> Assignment {cons("Assignment")}
    Assignment				-> Exp

    CollectionCreation -> Exp

    "[" Mapping* "]"       -> CollectionCreation {cons("MapCreation"), avoid} %%avoid to prevent ambiguity between with empty untyped list creation and empty map creation
    Exp "->" Exp           -> Mapping {cons("Mapping")}

    "[" {ExpListCreation ","}* "]" -> CollectionCreation {cons("ListCreation")}
    "{" {ExpListCreation ","}+ "}" -> CollectionCreation {cons("SetCreation")}

    "List" "<" Sort ">" "(" {ExpListCreation ","}* ")" -> CollectionCreation {cons("TypedListCreation"), prefer}
    "Set"  "<" Sort ">" "(" {ExpListCreation ","}* ")" -> CollectionCreation {cons("TypedSetCreation"), prefer}

    Exp -> ExpListCreation

    "for" "(" Id ":" Sort "in" Exp OptFilter ")" "{" {Exp ","}* "}"
    -> ExpListCreation {cons("ExpVarArgFor")}

    "for" "(" Id "in" Exp OptFilter ")" "{" {Exp ","}* "}"
    -> ExpListCreation {cons("ExpVarArgForInferred")}

    "for" "(" Id ":" Sort OptFilter ")" "{" {Exp ","}* "}"
    -> ExpListCreation {cons("ExpVarArgForAll")}

    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" "{" {Exp ","}* "}"
    -> ExpListCreation {cons("ExpVarArgForCount")}
    "for" "(" Id "from" Exp "to" Exp ")" "{" {Exp ","}* "}"
    -> ExpListCreation {cons("ExpVarArgForCount")}

  context-free syntax  %% tuples

    "(" {Exp ","}+ ")"  -> Exp  {cons("TupleCreation"), avoid}
    "(" {Sort ","}+ ")" -> Sort {cons("TupleSort")}
    "[" {Sort ","}+ "]" -> Sort {ast("GenericSort(\"List\",[TupleSort(<1>)])"), avoid}

  lexical syntax
    Id -> GlobalFunCallId  %% hook for reject rules on global function call names
  context-free syntax
    GlobalFunCallId "(" {Exp ","}* ")" -> Exp {cons("ThisCall")}
    "replace"  -> KeywordGlobalFunName {ast("\"replace\"")}
    "rollback" -> KeywordGlobalFunName {ast("\"rollback\"")}
    "cancel"   -> KeywordGlobalFunName {ast("\"cancel\"")}
    KeywordGlobalFunName "(" {Exp ","}* ")" -> Exp {ast("ThisCall(<1>, <2>)")}
    KeywordGlobalFunName -> GlobalFunCallId {reject}
    Keyword -> GlobalFunCallId {reject}

    "!" "(" {Exp ","}* ")"  -> Exp {reject}

    Exp "." Id "(" {Exp ","}* ")"  -> Exp {cons("Call")}

    Exp "is" "a" Sort      -> Exp {cons("IsA")}
    Exp "as" Sort          -> Exp {cons("Cast"), avoid} %% avoid, to give hql query AsAlias more priority, 'from Page as p' should make the 'as p' part of the query

  context-free syntax
    Exp "in" Exp           -> Exp {non-assoc, cons("InColl")}
  context-free restrictions
    "in" -/- [a-zA-Z0-9\_] %% there must be whitespace after the 'in' keyword for collection test

  context-free syntax
    Exp "==" Exp           -> Exp {cons("Eq"), left}
    Exp "!=" Exp           -> Exp {cons("NotEq"), left}
    Exp ">" Exp           -> Exp {cons("LargerThan"), left}
    Exp ">=" Exp           -> Exp {cons("LargerThanOrEqual"), left}
    Exp "<" Exp           -> Exp {cons("SmallerThan"), left}
    Exp "<=" Exp           -> Exp {cons("SmallerThanOrEqual"), left}

    "true"                 -> Exp {prefer,cons("True")}
    "false"                -> Exp {prefer,cons("False")}

    "null"                 -> Exp {prefer,cons("Null")}

    Exp "&&" Exp          -> Exp {cons("And"), assoc}
    Exp "||" Exp           -> Exp {cons("Or"), assoc}
    "!" Exp              -> Exp {cons("Not")}

    "(" Exp ")"            -> Exp {bracket}


    "[" Exp "|" Id OptSort "in" Exp OptFilter OptGroupBy "]"  -> ForExp {cons("ForExp")}
    "[" Id OptSort "in" Exp OptFilter OptGroupBy "]"          -> ForExp {ast("ForExp(Var(<1>),<1>,<2>,<3>,<4>,<5>)")}
    ForExp          -> Exp
    "group by" Exp  -> OptGroupBy {cons("GroupBy")}
                    -> OptGroupBy {cons("None")}


    "And" ForExp  -> Exp {cons("AndForExp")}
    "Or"  ForExp  -> Exp {cons("OrForExp")}


    Exp "*" Exp  -> Exp {cons("Mul"),assoc}
    Exp "/" Exp  -> Exp {cons("Div"),assoc}
    Exp "%" Exp  -> Exp {cons("Mod"),assoc}
    Exp "+" Exp  -> Exp {cons("Add"),assoc}
    Exp "-" Exp  -> Exp {cons("Sub"),assoc}

context-free priorities
  {left:
    Exp "." Id "(" {Exp ","}* ")"  -> Exp
    Exp "." Id  -> Exp
    %%Exp "[" Exp "]"  -> Exp  %% this gives syntax error on 'list[x+y]' in SDF2, using workaround with CollectionExp
    "session" "." Id -> Exp
  }
  > {non-assoc:
       Exp "is" "a" Sort -> Exp
       Exp "as" Sort     -> Exp
    }
  > "!" Exp -> Exp
  > {left:
       Exp "*" Exp -> Exp
       Exp "%" Exp -> Exp
       Exp "/" Exp -> Exp }
  > {left:
       Exp "+" Exp -> Exp
       Exp "-" Exp -> Exp }
  > Exp "in" Exp -> Exp
  > {left:
       Exp "==" Exp -> Exp
       Exp "!=" Exp -> Exp
       Exp ">" Exp -> Exp
       Exp ">=" Exp -> Exp
       Exp "<" Exp -> Exp
       Exp "<=" Exp -> Exp }
  > {left:
       Exp "&&" Exp -> Exp }
  > {left:
       Exp "||" Exp -> Exp }
  > Assignment -> Exp
  > HqlExp -> Exp
  > "if" "(" Exp ")" Exp "else" Exp -> Exp


exports

  context-free syntax

    QueryRule[[HQL]]                     -> HqlExp {cons("HqlQuery")}
    QueryRule[[HQL]] "limit" LimitValueExp         -> HqlExp {cons("HqlQueryLimit")}
    QueryRule[[HQL]] "limit" LimitValueExp "," LimitValueExp -> HqlExp {cons("HqlQueryLimitOffset")}

    %%although limit is not part of HQL, it has been added in WebDSL so it should support the ~var style of injecting values into HQL
    Exp -> LimitValueExp
    DslExp -> LimitValueExp

    DslExp -> Expression[[HQL]]
    "~" Exp -> DslExp {cons("DslExp")}

    DeleteStatement[[HQL]] ";" -> Statement {cons("HqlStatement")}

  context-free syntax

    QueryRule[[HQL]] "." Id -> Exp {reject}

context-free syntax %% email functions

  Id "(" {Exp ","}* ")" -> EmailCall {cons("EmailCall")}

  "renderemail" "(" EmailCall ")" -> InvokeTemplate {cons("RenderEmailFunctionCall"),prefer}
  "email" "(" EmailCall ")" -> Exp {cons("EmailFunctionCall"),prefer}
  "email" EmailCall -> Exp {cons("EmailFunctionCall"),prefer}
  "sendemail" "(" EmailCall ")" -> Exp {cons("SendEmailFunctionCall"),prefer}

context-free syntax %% function to execute a particular template phase

  InvokeTemplate -> Exp
  "rendertemplate" "(" TemplateCall ")" -> InvokeTemplate {cons("RenderTemplateFunctionCall"),prefer}
  "validatetemplate" "(" TemplateCall ")" -> InvokeTemplate {cons("ValidateTemplateFunctionCall"),prefer}

context-free syntax %% template elements passed as template argument

  "{" TemplateElement* "}" -> Exp {cons("TemplateElementsArgument"), avoid}

module WebDSL-Ajax

exports

  sorts Statement Exp InlineTemplate AjaxStatement
  context-free syntax

%% support dropped -> http://yellowgrass.org/issue/WebDSL/713
%%     "event" "(" Id "," "[" { EventArg "," }* "]" ")" -> Exp {cons("EventCall")}
%%     "event" "(" Id "," "[" { EventArg "," }* "]" ")" -> TemplateElement {cons("EventCallElement")}
%%
%%     Id ":=" Exp -> EventArg {cons("EventArg")}

%%  	replace <element_id> << <templatecall>(<argumenten>);
%%	append  <element_id> << <templatecall>(<argumenten>);
%%	visibility <element_id> << < "show" | "hide" | "toggle">;
%%	relocate this << <pagecall>(<argumenten>);
%%	restyle <element_id> << "<css classname>";
%%	clear <element_id> << "<niet terzake doende string>"

  AjaxStatement ";" -> Statement {cons("AjaxStatement"), prefer}
    "replace" "(" Exp "," TemplateCall ")" -> AjaxStatement {cons("AjaxReplace")}

    "append" "(" Exp "," TemplateCall ")" -> AjaxStatement {cons("AjaxAppend")}

    "visibility" "(" Exp "," AjaxVisibility ")" -> AjaxStatement {cons("AjaxVisibility")}
    "show" -> AjaxVisibility{cons("Show")}
    "toggle" -> AjaxVisibility{cons("Toggle")}
    "hide" -> AjaxVisibility{cons("Hide")}

    "relocate" "(" PageCall ")" -> AjaxStatement { cons("AjaxRelocate") }

    "restyle" "(" Exp "," Exp ")" -> AjaxStatement { cons("AjaxRestyle") }

    "clear" "(" Exp ")" -> AjaxStatement{cons("AjaxClear")}

    "refresh" "(" ")" -> AjaxStatement{cons("AjaxRefresh")}

    "runscript" "(" Exp ")" -> AjaxStatement { cons("AjaxRunScript"), prefer }

%%    Id Id "<<" Id  ";" 	 -> Statement {cons("AjaxActionIdParam"),prefer}
%%    Id Id "<<" ";"		-> Statement {cons("AjaxActionNoParam")}
%%    Id "<<" Exp ";"	 	-> Statement {cons("AjaxActionNoTarget")}
%%    Id Id "<<" Exp ";"   	-> Statement {cons("AjaxAction")}

    Placeholder -> TemplateElement
    PlaceholderKeyword "<" Id ">" Id "{" TemplateElement* "}" -> Placeholder{ast("Placeholder(<2>,<3>,<4>)"), prefer}
    PlaceholderKeyword "<" Id ">" Exp "{" TemplateElement* "}"-> Placeholder{ast("Placeholder(<2>,<3>,<4>)")}
    PlaceholderKeyword "<" Id ">" Id TemplateCall -> Placeholder{ast("PlaceholderWithAjaxCall(<2>,<3>,<4>)"), prefer}
    PlaceholderKeyword "<" Id ">" PHExp TemplateCall -> Placeholder{ast("PlaceholderWithAjaxCall(<2>,<3>,<4>)")}
    
    PlaceholderKeyword Id "{" TemplateElement* "}" -> Placeholder{ast("Placeholder(<2>,<3>)"), prefer}
    PlaceholderKeyword Exp "{" TemplateElement* "}"-> Placeholder{ast("Placeholder(<2>,<3>)")}
    PlaceholderKeyword Id TemplateCall -> Placeholder{ast("PlaceholderWithAjaxCall(<2>,<3>)"), prefer}
    PlaceholderKeyword PHExp TemplateCall -> Placeholder{ast("PlaceholderWithAjaxCall(<2>,<3>)")}
    
    %% node for describing a placeholder var declaration without body
    %% making it explicit in the syntax is convenient for desugaring, testing and debugging
    PlaceholderVar -> TemplateElement
    PlaceholderVarKeyword Id -> PlaceholderVar{ast("PlaceholderVar(<2>)"), prefer}

  context-free syntax
    "placeholder" -> PlaceholderKeyword
    "placeholdervar" -> PlaceholderVarKeyword
  context-free restrictions
    PlaceholderKeyword
    PlaceholderVarKeyword
    -/- [a-zA-Z0-9\_]

  context-free syntax

    %% issue http://yellowgrass.org/issue/Spoofax/331
    %% workaround:
    Id "(" {Exp ","}* ")"  -> PHExp {cons("ThisCall")}
    Exp "." Id "(" {Exp ","}* ")"  -> PHExp {cons("Call")}
    Exp "." Id             -> PHExp {cons("FieldAccess"),prefer}
    Exp "[" Exp "]"        -> PHExp {cons("CollectionIndex"),prefer}
    Exp "+" Exp  -> PHExp {cons("Add")}
    ConstValue -> PHExp
    %%
    %% more general implementation, currently broken in java back-end:
    %% "placeholder" Exp TemplateCall -> TemplateElement{cons("PlaceholderWithAjaxCall")}
    %% reject ambiguous placeholder target{} next{} where target{} is parsed as object creation,
    %% which is never the case since the expression must produce a String
    %% "placeholder" ObjectCreation TemplateCall   -> TemplateElement {reject}


module WebDSL-UI

imports
  WebDSL-Action
  WebDSL-Lexical

exports

  sorts TemplateDefinition Modifier Exp

  context-free syntax

    TemplateDefinition -> Definition

    "define" Modifier*
       Id OptFormalArgs
       TemplateArgs
       "{" TemplateElement* "}"             -> TemplateDefinition {cons("Define")}

    "requires" {TemplateArg "," }*            -> TemplateArgs{cons("TemplateArgs"), prefer}
    Id "(" {Sort ","}* ")"                  -> TemplateArg {cons("TemplateArg")}

      -> TemplateArgs{cons("None")}

    "define" Modifier* Id "(" {FormalArg ","}* ")" "=" Id OptLocalRedefineArgs -> TemplateDefinition {cons("LocalRedefine")}
    -> OptLocalRedefineArgs {cons("None")}
    "(" "*" "," {LocalRedefineArg ","}+ ")" -> OptLocalRedefineArgs {cons("LocalRedefineArgs")}
    Id -> LocalRedefineArg{cons("Var")}

    %% new page syntax
    Modifier*
    "page"
    PageId
    OptFormalArgs
    TemplateArgs
    "{" TemplateElement* "}"  -> TemplateDefinition {cons("DefinePage")}

    %% new template syntax
    Modifier*
    "template"
    Id
    OptFormalArgs
    TemplateArgs
    "{" TemplateElement* "}"  -> TemplateDefinition {cons("DefineTemplate")}

    Modifier*
    "email"
    Id
    OptFormalArgs
    TemplateArgs
    "{" TemplateElement* "}"  -> TemplateDefinition {ast("Define([Email()], <2>, <3>, <4>, <5>)")}

    "(" {FormalArg ","}* ")" -> OptFormalArgs {ast("<1>")}
                             -> OptFormalArgs {ast("[]")}

    %%"define" Modifier*
    %%   Id UNDEFINED*
    %%   "{" TemplateElement* "}"             -> TemplateDefinition {cons("Define")}

    "page"                                  -> Modifier {cons("Page")}
    "email"                                 -> Modifier {cons("Email")}
    "ajax"                                  -> Modifier {cons("AjaxTemplate")}
    "template"                              -> Modifier {cons("Template")}
    "feed"                                  -> Modifier {cons("Feed")}
    "local"                                 -> Modifier {cons("Local")}
    "no-span"                               -> Modifier {cons("NoSpan")}
    "span"                                  -> Modifier {cons("TemplateModSpan")}
    "inline"                                -> Modifier {cons("TemplateModInline")}
    "override"                              -> Modifier {cons("TemplateModOverride")}
    "deprecated"                            -> Modifier {cons("TemplateDeprecated")}
    "expire-cache"                          -> Modifier {cons("ExpireCache")}
    "read-only"                             -> Modifier {cons("ReadOnlyPage")}
    "service"                               -> Modifier {cons("WebService")}

    InitAction                              -> TemplateElement
    Action                                  -> TemplateElement

    "var" Id ":" Sort                       -> VarDecl {cons("TemplateVarDecl")}
    "var" Id ":" Sort ":=" Exp              -> VarDecl {cons("TemplateVarDeclInit")}
    "var" Id ":=" Exp                       -> VarDecl {cons("TemplateVarDeclInitInferred")}
    VarDecl                                 -> TemplateElement
    %% still allow ";" behind page var for backwards comp.
    "var" Id ":" Sort ";" 	       -> VarDecl {cons("TemplateVarDecl"), deprecated ("remove ';'")}
    "var" Id ":" Sort ":=" Exp ";" -> VarDecl {cons("TemplateVarDeclInit"), deprecated ("remove ';'")}
    "var" Id ":=" Exp ";"          -> VarDecl {cons("TemplateVarDeclInitInferred"), deprecated ("remove ';'")}
    "request" VarDecl                       -> TemplateElement {cons("RequestScopeTemplate")}
    "local" VarDecl                         -> TemplateElement {cons("LocalScopeTemplate")}

    TemplateDefinition                      -> TemplateElement
    TemplateCall                            -> TemplateElement {avoid}


    "where" Exp                                    -> Filter {cons("FilterNoOrderByNoLimit")}
    "order" "by" {OrderExp ","}+                   -> Filter {cons("FilterNoWhereNoLimit")}
    "where" Exp "order" "by" {OrderExp ","}+       -> Filter {cons("FilterNoLimit")}
    "where" Exp Limit                              -> Filter {cons("FilterNoOrderBy")}
    "order" "by" {OrderExp ","}+ Limit             -> Filter {cons("FilterNoWhere")}
    Limit                                          -> Filter {cons("FilterNoWhereNoOrderBy")}
    "where" Exp "order" "by" {OrderExp ","}+ Limit -> Filter {cons("Filter")}
    Exp                      -> OrderExp {cons("OrderNonSpecific")}
    Exp "asc"                -> OrderExp {cons("OrderAscending")}
    Exp "desc"               -> OrderExp {cons("OrderDescending")}
    "limit" Exp "offset" Exp -> Limit {cons("Limit")}
    "limit" Exp              -> Limit {cons("LimitNoOffset")}
    "offset" Exp             -> Limit {cons("LimitNoLimit")}


    "for" "(" Id ":" Sort "in" Exp OptFilter ")"
       "{" TemplateElement* "}" ForSeparator       -> TemplateElement {cons("For")}

    Filter -> OptFilter
    -> OptFilter {cons("None")}

    ":" Sort -> OptSort {ast("<1>")}
    -> OptSort {cons("None")}

    "for" "(" Id "in" Exp OptFilter ")"
       "{" TemplateElement* "}" ForSeparator       -> TemplateElement {cons("ForInferred")}

    "for" "(" Id ":" Sort OptFilter ")"
       "{" TemplateElement* "}" ForSeparator       -> TemplateElement {cons("ForAll")}

    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")"
      "{" TemplateElement* "}" ForSeparator        -> TemplateElement {cons("ForCount")}
    "for" "(" Id "from" Exp "to" Exp ")"
      "{" TemplateElement* "}" ForSeparator        -> TemplateElement {cons("ForCount")}

    "separated-by" "{" TemplateElement* "}" -> ForSeparator{cons("ForSeparator")}
    -> ForSeparator{cons("None")}


    "if" "(" Exp ")" "{" TemplateElement* "}" ElseIfTempl* ElseTempl? -> TemplateElement {cons("IfElseIfTempl"),prefer}
    "else" "if" "(" Exp ")" "{" TemplateElement* "}"                  -> ElseIfTempl {cons("ElseIfTempl"),prefer}
    "else" "{" TemplateElement* "}"                                   -> ElseTempl  {cons("ElseTempl"),prefer}


    "case" "(" {Exp ","}+ ")" "{" TemplateCaseAlt* "}"  -> TemplateElement {cons("TemplateCase")}
    {Exp ","}+ "{" TemplateElement* "}"                 -> TemplateCaseAlt {cons("TemplateCaseAlt")}
    "default" "{" TemplateElement* "}"                  -> TemplateCaseAlt {cons("TemplateCaseAltDefault"), prefer}

    "typecase" "(" TypeCaseExp OptTypeCaseAlias ")" "{" TemplateTypeCaseAlt* "}" -> TemplateElement {cons("TemplateTypeCase")}
    Sort "{" TemplateElement* "}"                               -> TemplateTypeCaseAlt {cons("TemplateTypeCaseAlt")}
    "default" "{" TemplateElement* "}"                          -> TemplateTypeCaseAlt {cons("TemplateTypeCaseDefault"), prefer}

  %%
    TemplateCallId OptTCallArgs OptTCallPropAssigns TemplateBody -> TemplateCall {cons("TemplateCall")}

    "(" {TemplateArgExp ","}* ")" -> OptTCallArgs {ast("<1>")}
                                  -> OptTCallArgs {ast("[]")}

    Exp -> TemplateArgExp

    "[" {PropertyAssignment ","}* "]" -> OptTCallPropAssigns {ast("<1>")}
                                      -> OptTCallPropAssigns {ast("[]")}

    "{" TemplateElement* "}" -> TemplateBody {cons("TemplateBody")}
                             -> TemplateBody {ast("TemplateBody([])")}

    "with" "{" ArgDefine* "}" -> TemplateBody {cons("TemplateWith")}

    TemplateCallId "(" {FormalArg ","}* ")" "{" TemplateElement* "}" -> ArgDefine {cons("ArgDefine")}

    "with" "{" TemplateElement* "}" -> TemplateCall {reject}



    "navigate" "(" PageCall ")" OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("NavigateCall"), deprecated("Use 'navigate pagecall() { elements }'")}

    "navigate" PageCall OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("NavigateCall")}

    PageId OptExpArgs  -> PageCall {cons("PageCall")}

    "(" {Exp ","}* ")" -> OptExpArgs {ast("<1>")}
                       -> OptExpArgs {ast("[]")}



    "action"     "(" Exp "," ActionCallOrInline ")" OptTCallPropAssigns -> TemplateElement {cons("Submit"), deprecated("Use 'submit action { elements }'")}
    "actionLink" "(" Exp "," ActionCallOrInline ")" OptTCallPropAssigns -> TemplateElement {cons("SubmitLink"), deprecated("Use 'submitlink action { elements }'")}

    "submit"     "(" Exp "," ActionCallOrInline ")" OptTCallPropAssigns -> TemplateElement {cons("Submit"), deprecated("Use 'submit action { elements }'")}
    "submitlink" "(" Exp "," ActionCallOrInline ")" OptTCallPropAssigns -> TemplateElement {cons("SubmitLink"), deprecated("Use 'submitlink action { elements }'")}

    "submit"     ActionCallOrInline OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("SubmitElem")}
    "submitlink" ActionCallOrInline OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("SubmitLinkElem")}

    "downloadlink" ActionCallOrInline OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("DownloadLink")}
    "outputimage"  ActionCallOrInline OptTCallPropAssigns "{" TemplateElement* "}" -> TemplateElement {cons("OutputImage")}

    ActionCall   -> ActionCallOrInline
    InlineAction -> ActionCallOrInline
                 -> ActionCallOrInline {ast("InlineAction(Block([])")}
    ReplaceAction -> ActionCallOrInline

    "replace" "(" {Exp ","}+ ")" -> ReplaceAction {cons("ReplaceAction")}

    ActionCallId OptExpArgs -> ActionCall {cons("ActionCall")}

  lexical syntax
    Id -> ActionCallId  %% hook for reject rules on action names
    "replace" -> ActionCallId {reject}

  context-free restrictions
    "submit" -/- [l]  %% avoid ambiguity 'submitlink{}' (submitlink with action omitted / submit with 'link' action)

  context-free syntax

    "action" Block -> InlineAction {cons("InlineAction")}
    %% reject ambiguous ObjectCreation(SimpleSort("action"), [])
    "action" -> Sort {reject}
    %%"template" "{" TemplateElement* "}" -> InlineTemplate {cons("InlineTemplateCall")}
    %% "template"               -> Id {reject}

    %% Template call without braces must be disambiguated in some cases
    "action" -> TemplateCall {reject}  %%this is an action definiton, not a templatecall without params
    "action" -> Exp {reject}           %%this is an inline action, not a variable
    "action" -> PropertyValue {reject} %%this is an inline action, not an id



    SubmitProp ":"  ActionCallOrInline -> PropertyAssignment {cons("PropertySubmit"),deprecated("Use '=' instead"),prefer}
    SubmitProp ":=" ActionCallOrInline -> PropertyAssignment {cons("PropertySubmit"),deprecated("Use '=' instead"),prefer}
    SubmitProp "="  ActionCallOrInline -> PropertyAssignment {cons("PropertySubmit"),prefer}
    ExtendedId ":"  PropertyValue      -> PropertyAssignment {cons("PropertyAssignment"),deprecated("Use '=' instead")}
    ExtendedId ":=" PropertyValue      -> PropertyAssignment {cons("PropertyAssignment"),deprecated("Use '=' instead")}
    ExtendedId "="  PropertyValue      -> PropertyAssignment {cons("PropertyAssignment")}

    Exp -> PropertyValue

    "ajax"                -> PropertyAssignment {cons("TemplateCallPropertyAjax")}
    "no loading feedback" -> PropertyAssignment {cons("TemplateCallPropertyNoLoadingFeedback")}
    "ignore-validation"   -> PropertyAssignment {cons("TemplateCallPropertyIgnoreValidation")}
    "not null"            -> PropertyAssignment {cons("TemplateCallPropertyNotNull")}

    CommonAttribute -> PropertyAssignment

    %% multiple action calls, e.g. trigger an onkeyup action and also execute the onkeyup passed in attributes
    SubmitProp "=" {ActionCallOrInlineOrExp ";"}+ -> PropertyAssignment {cons("PropertySubmitMultiple"), avoid}
    ActionCallOrInline -> ActionCallOrInlineOrExp {prefer}
    PropertyValue      -> ActionCallOrInlineOrExp

  lexical syntax
    "onabort" -> SubmitProp
    "onblur"  -> SubmitProp
    "onchange"  -> SubmitProp
    "onclick"  -> SubmitProp
    "ondblclick" -> SubmitProp

    "onerror"  -> SubmitProp
    "onfocus"  -> SubmitProp
    "onkeydown"  -> SubmitProp
    "onkeypress" -> SubmitProp
    "onkeyup" -> SubmitProp

    "onload" -> SubmitProp
    "onmousedown" -> SubmitProp
    "onmousemove" -> SubmitProp
    "onmouseout" -> SubmitProp
    "onmouseover" -> SubmitProp
    "onmouseenter" -> SubmitProp
    "onmouseleave" -> SubmitProp
    "onmouseup" -> SubmitProp

    "onreset" -> SubmitProp
    "onresize" -> SubmitProp
    "onselect" -> SubmitProp
    "onsubmit" -> SubmitProp

    "onunload" -> SubmitProp
    "oninput" -> SubmitProp

  context-free syntax
  %%

    %% "if" "(" Exp ")" "{" TemplateElement* "}"      -> TemplateCall {reject}
    %% "else" "{" TemplateElement* "}"                -> TemplateCall {reject}
    "separated-by" "{" TemplateElement* "}"        -> TemplateCall {reject}

    "init" Block       -> InitAction {cons("InitAction"),prefer}
    "databind" Block   -> TemplateElement {cons("DataBindAction"),prefer}
    "render" Block     -> TemplateElement {cons("RenderAction"),prefer}
    "allphases" Block  -> TemplateElement {cons("AllPhasesAction"),prefer}
    "validate" Block   -> TemplateElement {cons("ValidateAction"),prefer}

    "action" ActionModifier* Id OptFormalArgs Block -> Action {cons("Action")}
    "ignore-validation" -> ActionModifier{cons("ActionModifierIgnoreValidation")}

  context-free syntax

    Id ".elements" -> TemplateCallId {cons("QualifiedElementsCall"),prefer}

  context-free syntax  %% template var args

    "[" {FormalVarArg ","}+ "]"             -> Sort {cons("TemplateVarArgSort")}
    Id ":" Sort                             -> FormalVarArg {cons("FormalVarArg")}
    Id "." TemplateCall                     -> TemplateCall {cons("MemberTemplateCall"), avoid}

    "[" {ExpVarArg ","}+ "]"                -> TemplateArgExp {cons("TemplateVarArgExp"), prefer}
    "(" {Exp ","}* ")"                      -> ExpVarArg {cons("ExpVarArg")}

    "for" "(" Id ":" Sort "in" Exp OptFilter ")" "{" {ExpVarArg ","}* "}"
    -> ExpVarArg {cons("ExpVarArgFor")}

    "for" "(" Id "in" Exp OptFilter ")" "{" {ExpVarArg ","}* "}"
    -> ExpVarArg {cons("ExpVarArgForInferred")}

    "for" "(" Id ":" Sort OptFilter ")" "{" {ExpVarArg ","}* "}"
    -> ExpVarArg {cons("ExpVarArgForAll")}

    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" "{" {ExpVarArg ","}* "}"
    -> ExpVarArg {cons("ExpVarArgForCount")}
    "for" "(" Id "from" Exp "to" Exp ")" "{" {ExpVarArg ","}* "}"
    -> ExpVarArg {cons("ExpVarArgForCount")}

  context-free syntax %% htmlwrapper shorthand

    "htmlwrapper" Id OptFormalArgs Id HTMLWrapperAssigns -> HTMLWrapper {cons("HTMLWrapper")}

    "[" {Attribute ","}*"]"                -> HTMLWrapperAssigns{cons("HTMLWrapperAssigns")}
    "[" Attribute* "]"                     -> HTMLWrapperAssigns{cons("HTMLWrapperAssigns"), prefer}
                                           -> HTMLWrapperAssigns{ast("HTMLWrapperAssigns([])")}

    HTMLWrapper                            -> TemplateDefinition
    "htmlwrapper" "{" HTMLWrapperBody* "}" -> TemplateDefinition {cons("HTMLWrapperMultiple")}
    Id OptFormalArgs Id HTMLWrapperAssigns -> HTMLWrapperBody {cons("HTMLWrapperBody")}

  context-free syntax %% id -> getTemplate().getUniqueId()

    "id" -> TemplateId {cons("TemplateId")}
    TemplateId -> Exp
    TemplateId -> SimpleVar  %% allows string interpolation "~id"
    "id" -> VarId {reject}

  context-free restrictions

    TemplateId -/- [a-zA-Z0-9\_]

module WebDSL-Keywords

exports

  sorts
    Keyword

  context-free syntax

    Keyword -> Id {reject}  %% (not rejected in HQL as keyword)

  context-free syntax

    "function" -> Keyword
    "return"   -> Keyword
    "as"       -> Keyword
    "define"   -> Keyword
    "for"      -> Keyword

  context-free restrictions

    "as" -/- [a-zA-Z0-9\_]  %% prevent ambiguity between as and asc (used in for-filters)


  context-free syntax  %%  keywords specific to UI template context

    "define"   -> TemplateCallId {reject}
    "template" -> TemplateCallId {reject}
    "var"      -> TemplateCallId {reject}
    "for"      -> TemplateCallId {reject}
    "if"       -> TemplateCallId {reject}
    "else"     -> TemplateCallId {reject}
    "as"       -> TemplateCallId {reject}
    "is"       -> TemplateCallId {reject}
    "null"     -> TemplateCallId {reject}
    "and"      -> TemplateCallId {reject}
    "or"       -> TemplateCallId {reject}
    "order"    -> TemplateCallId {reject}
    "by"       -> TemplateCallId {reject}
    "where"    -> TemplateCallId {reject}
    "in"       -> TemplateCallId {reject}
    "navigate" -> TemplateCallId {reject}
    "action"   -> TemplateCallId {reject}
    "submit"   -> TemplateCallId {reject}
    "goto"     -> TemplateCallId {reject}
    "foreach"  -> TemplateCallId {reject}
    "request"  -> TemplateCallId {reject}
    "local"    -> TemplateCallId {reject}
    "init"     -> TemplateCallId {reject}
    "databind" -> TemplateCallId {reject}
    "derive"   -> TemplateCallId {reject}
    "ajax"     -> TemplateCallId {reject}
    "rules"    -> TemplateCallId {reject}  %% avoid amb: apply ac rules foo()
    "actionLink"   -> TemplateCallId {reject}
    "submitlink"   -> TemplateCallId {reject}
    "downloadlink" -> TemplateCallId {reject}
    "outputimage"  -> TemplateCallId {reject}
    "placeholder"  -> TemplateCallId {reject}
    "expand"       -> TemplateCallId {reject}
    PlaceholderKeyword    -> TemplateCallId {reject}
    PlaceholderVarKeyword -> TemplateCallId {reject}

module WebDSL-Lexical

exports

  lexical syntax
    Id -> TemplateCallId  %% hook for reject rules on templatecall names
    [a-zA-Z][a-zA-Z0-9\_]* -> Id
    [a-zA-Z][a-zA-Z0-9\_\-]* -> PageId
    [a-zA-Z0-9\-\_\.]+     -> ExtendedId
    {ExtendedId "/"}+      -> ModuleName
    ~[\n\r]*               -> SectionName

  lexical restrictions
    Id         -/- [a-zA-Z0-9\_]
    PageId     -/- [a-zA-Z0-9\_\-]
    ModuleName -/- [a-zA-Z0-9\/]

  lexical syntax
    "-"? [0-9]+            -> Int
    "-"? [0-9]+ "L"        -> Long

  lexical syntax
    "-"? FloatDigits
     ExponentPart? [fFdD]? -> Float
    [0-9]* "." [0-9]+      -> FloatDigits
    [0-9]+                 -> FloatDigits
    [eE] SignedInteger     -> ExponentPart
    [\+\-]? [0-9]+         -> SignedInteger

    "-"? [0-9]+            -> Float {reject}
    "."                    -> FloatDigits  {reject}

  lexical restrictions
    Int           -/- [0-9]
    Float         -/- [fFdD]
    FloatDigits   -/- [0-9]
    SignedInteger -/- [0-9]

  %% Kernel syntax is required here since we do not want LAYOUT to be parsed between
  %% the first QMLex and StringLex
  syntax
    %% string literal as expression
    <QMLex-LEX> <StringLex-LEX> <QMLex-LEX>  -> <String-CF>  {ast("String(<2>)")}
    <QMLex-LEX> StringPart* <QMLex-LEX>      -> <String-CF>  {ast("StringInterp(<2>)"), avoid}

    %% string literal as template element
    <QMLex-LEX> <StringLex-LEX> <QMLex-LEX> -> <TemplateElement-CF> {ast("Text(<2>)")}
    <QMLex-LEX> StringPart* <QMLex-LEX>     -> <TemplateElement-CF> {ast("TextInterp(<2>)"), avoid}

    SimpleStringPart       -> StringPart
    <StringLexInterp-LEX>  -> StringPart

    "~" <SimpleExp-CF>    -> SimpleStringPart {cons("InterpExp")}
    "~" "(" <Exp-CF> ")"  -> StringPart {cons("InterpExp")}

  restrictions
    SimpleStringPart -/- [\.\(]  %% make fieldaccess/call not part of string that follows
                                 %% use parentheses variant if a . is needed in the string

  context-free syntax
    %% ~SimpleExp and ~(Exp) shorthand for output template call
    "~" SimpleExp    -> OutputShorthand {cons("OutputShorthand")}
    "~" "(" Exp ")"  -> OutputShorthand {cons("OutputShorthand")}
    OutputShorthand  -> TemplateElement

  context-free syntax
  %% SimpleExp: specific commonly occuring expressions allowed directly after '~' inside string
  %% allowing all expressions directly after '~' causes too many ambiguities
  %% parentheses expression is used as delimiter for inserting any expression
  %% allowed after '~': var/fieldaccess/thiscall/call/brackets a, a.b, a(), a.b(), (exp)
  %% a '.' after a SimpleExp must be rejected as part of String to avoid amb, e.g. not allowed: "~a."
  %% in these cases, use '()' if a '.' is needed as part of the string,       e.g.     allowed: "~(a)."

   VarId             -> SimpleVar {cons("Var")}
   SimpleVar         -> SimpleExp
   SimpleExp "." Id  -> SimpleExp {cons("FieldAccess")}

   Id "(" {Exp ","}* ")"                -> SimpleExp {cons("ThisCall")}
   SimpleExp "." Id "(" {Exp ","}* ")"  -> SimpleExp {cons("Call")}

  lexical syntax
    "\""                         -> QMLex
    StringChar*                  -> StringLex
    StringChar+                  -> StringLexInterp
    ~[\"\n\~\\]                  -> StringChar
    %% Escape sequences adopted from Java, does not require transformation
    %% '~' is WebDSL-specific escape, needs to be unescaped when generating Java String
    "\\" [0-9btnfr\'\"\\\~]      -> StringChar
    [0-9a-fA-F]                  -> HexPart
    "\\u" HexPart HexPart HexPart HexPart  -> StringChar

  lexical restrictions
    StringLex
    StringLexInterp -/- ~[\"\n\~]

  lexical syntax
    [\ \t\n\r]                   -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | Eof) -> LAYOUT
    "/*" CommentChar* "*/"       -> LAYOUT
                                 -> Eof
    ~[\*]                        -> CommentChar
    Asterisk                     -> CommentChar
    [\*]                         -> Asterisk

  lexical restrictions
    Asterisk   -/- [\/]
    Eof        -/- ~[]

  context-free restrictions
    LAYOUT?     -/- [\ \t\n\r]
    LAYOUT?     -/- [\/].[\/]
    LAYOUT?     -/- [\/].[\*]
    SectionName -/- ~[\n\r]

  lexical syntax
    ~[\ \t\n\r\}]+ -> Word
  lexical restrictions
     Word -/- ~[\ \t\n\r\}]

  context-free restrictions
    "page" "local" "email" "feed" "template" "schedule" -/- [a-zA-Z0-9]

module WebDSL

imports
  WebDSL-Lexical
  WebDSL-Keywords
  WebDSL-UI
  WebDSL-Ajax
  WebDSL-Action
  WebDSL-DataModel
  WebDSL-DataValidation
  WebDSL-AccessControl
  WebDSL-XML
  WebDSL-JavaScript
  WebDSL-CSS
  WebDSL-Regex
  WebDSL-Enums
  WebDSL-Expand
  WebDSL-Native
  WebDSL-Exception
  WebDSL-Type
  WebDSL-Test
  WebDSL-TimeInterval
  WebDSL-Service
  WebDSL-Search
  WebDSL-Prefetch
  WebDSL-Routing
  WebDSL-Attributes
  WebDSL-EntityDerive

hiddens
  context-free start-symbols
    Unit

exports

  sorts
    Id QId Int ModuleName SectionHeader Float FloatDigits ExponentPart
    SignedInteger String UNDEFINED Eof


  context-free syntax
    Id         -> QId
    QId "." Id -> QId {cons("Qualified")}

  context-free syntax %% Types
    SimpleSort   -> Sort
    GenericSort  -> Sort
    RefSort      -> Sort
    ListSort     -> Sort
    SetSort      -> Sort
    FunctionSort -> Sort

    Id                     -> SimpleSort {cons("SimpleSort")}
    Id "<" {Sort ","}+ ">" -> GenericSort {cons("GenericSort")}
    "Ref" "<" Sort ">"     -> RefSort {cons("RefSort")}
    "ref" Sort             -> RefSort {cons("RefSort")}
    "Ref" "<" Sort ">"     -> GenericSort {reject}

    %% List type '[Type]' and Set type '{Type}' notation
    "[" Sort "]" -> ListSort {ast("GenericSort(\"List\",[<1>])")}
    "{" Sort "}" -> SetSort  {ast("GenericSort(\"Set\",[<1>])")}

    %% function type; optionally specify (named) args and return type
    "function" FunctionSortParams FunctionSortReturn -> FunctionSort {cons("FunctionSort")}
    -> FunctionSortParams {ast("[]")}
    "(" {FunctionSortParam ","}* ")" -> FunctionSortParams {ast("<1>")}
    Sort -> FunctionSortParam {cons("UnnamedArg")}
    Id ":" Sort -> FunctionSortParam {cons("Arg")}
    -> FunctionSortReturn {ast("SimpleSort(\"Void\")")}
    ":" Sort -> FunctionSortReturn {ast("<1>")}
     "function" -> SimpleSort {reject}


    Id ":" Sort            -> FormalArg {cons("Arg")}

exports

  sorts Application Module Unit

  syntax

    "section" <SectionName-CF> <LAYOUT?-CF> <Definition*-CF> -> <Section-CF> {cons("Section")}

  context-free syntax

    "application" QId Definition+ Section* -> Application {cons("ApplicationDefs")}
    "application" QId Section*      -> Application {cons("Application")}

    "description" "{" Word* "}"     -> Description {cons("Description")}

    "note" "{" Word* "}"            -> Description {cons("Note")}

    Description                   -> Definition
    %%Description                   -> Definition {prefer}

    "module" ModuleName Section*  -> Module {cons("Module")}
    "module" ModuleName Definition+ Section*  -> Module {cons("ModuleDefs")}

    "imports" ModuleName          -> Definition {cons("Imports")}

    Application                   -> Unit
    Module                        -> Unit

exports

  sorts Action Statements Statement Exp

  context-free syntax

    Action		       	        -> Definition
    Statement*		   	        -> Statements
    NativeClassDeclaration      -> Definition



module WebDslMix[E]

imports
  WebDSL
  AccessControlMix
  DeriveMix

exports

  lexical syntax

    [0-9]* -> MetaVarSuffix
    "_" [A-Za-z0-9\_\-]+ -> MetaVarSuffix

  context-free syntax
    "webdsl"  "|[" Application      "]|" -> E {cons("ToMetaExpr")}
    "application" "|[" Application      "]|" -> E {cons("ToMetaExpr")}
              "|[" Application      "]|" -> E {cons("ToMetaExpr")}
    "module"  "|[" Module      		"]|" -> E {cons("ToMetaExpr")}
              "|[" Module   	   	"]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" Section          "]|" -> E {cons("ToMetaExpr")}
    "section" "|[" Section          "]|" -> E {cons("ToMetaExpr")}
              "|[" Section          "]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" Section*         "]|" -> E {cons("ToMetaExpr")}
    "section*" "|[" Section*         "]|" -> E {cons("ToMetaExpr")}
              "|[" Section*         "]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" TemplateElement  "]|" -> E {cons("ToMetaExpr")}
    "webdsl*" "|[" TemplateElement* "]|" -> E {cons("ToMetaExpr")}

    "def"   "|[" Definition  "]|" -> E {cons("ToMetaExpr")}
    "def*"  "|[" Definition* "]|" -> E {cons("ToMetaExpr")}
    "fun"   "|[" Function  "]|"   -> E {cons("ToMetaExpr")}
    "fun*"  "|[" Function* "]|"   -> E {cons("ToMetaExpr")}
    "sdef"  "|["  SecurityDefinition   "]|" -> E {cons("ToMetaExpr")}
    "sdef*" "|["  SecurityDefinition*  "]|" -> E {cons("ToMetaExpr")}

    "webdsl" "|[" Description "]|" -> E {cons("ToMetaExpr")}
             "|[" Description "]|" -> E {cons("ToMetaExpr")}
    
    "|[" NativeClassElement  "]|" -> E {cons("ToMetaExpr")}
    "|[" NativeClassElement* "]|" -> E {cons("ToMetaExpr")}
    "native"  "|[" NativeClassElement  "]|" -> E {cons("ToMetaExpr")}
    "native*" "|[" NativeClassElement* "]|" -> E {cons("ToMetaExpr")}

  variables

    "app" [0-9]*                -> Application {prefer}
    "sec" [0-9]*                -> Section     {prefer}
    "sec" [0-9]* "*"            -> Section*    {prefer}
    "sec" MetaVarSuffix         -> Section     {prefer}
    "sec" MetaVarSuffix "*"     -> Section*    {prefer}
    "def" [0-9]*                -> Definition  {prefer}
    "def" [0-9]* "*"            -> Definition* {prefer}
    "def" MetaVarSuffix         -> Definition  {prefer}
    "def" MetaVarSuffix "*"     -> Definition* {prefer}
    "procelem" [0-9]*           -> ProcedureElement  {prefer}
    "procelem" [0-9]* "*"       -> ProcedureElement* {prefer}
    "procelem_"[A-Za-z0-9]+     -> ProcedureElement  {prefer}
    "procelem_"[A-Za-z0-9]+ "*" -> ProcedureElement* {prefer}
    "processexp" [0-9]*         -> ProcessExp  {prefer}
    "processexp" [0-9]* "*"     -> ProcessExp* {prefer}
    "desc"[0-9]*                -> Description {prefer}
    "mod" [0-9]*                -> Modifier    {prefer}
    "mod" [0-9]* "*"            -> Modifier*   {prefer}
    "native" [0-9]*             -> NativeClassElement  {prefer}
    "native" [0-9]* "*"         -> NativeClassElement* {prefer}
    "native" MetaVarSuffix      -> NativeClassElement  {prefer}
    "native" MetaVarSuffix "*"  -> NativeClassElement* {prefer}

  context-free syntax

    "webdsl" "|[" Entity            "]|" -> E {cons("ToMetaExpr")}
             "|[" Entity            "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" EntityBodyDeclaration  "]|" -> E {cons("ToMetaExpr")}
    "ebd"    "|[" EntityBodyDeclaration  "]|" -> E {cons("ToMetaExpr")}
             "|[" EntityBodyDeclaration  "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" EntityBodyDeclaration* "]|" -> E {cons("ToMetaExpr")}
    "ebd*"   "|[" EntityBodyDeclaration* "]|" -> E {cons("ToMetaExpr")}
             "|[" EntityBodyDeclaration* "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Sort              "]|" -> E {cons("ToMetaExpr")}
             "|[" Sort              "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" {Sort ","}*       "]|" -> E {cons("ToMetaExpr")}
             "|[" {Sort ","}*       "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Annotation        "]|" -> E {cons("ToMetaExpr")}
    "anno"   "|[" Annotation        "]|" -> E {cons("ToMetaExpr")}
             "|[" Annotation        "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" {Annotation ","}* "]|" -> E {cons("ToMetaExpr")}
    "anno*"  "|[" {Annotation ","}* "]|" -> E {cons("ToMetaExpr")}
             "|[" {Annotation ","}* "]|" -> E {cons("ToMetaExpr")}

  variables
    "ent" [0-9]*     -> Entity            {prefer}
    "ent" [0-9]* "*" -> Entity*           {prefer}
    "prop"[0-9]*     -> Property          {prefer}
    "prop"[0-9]* "*" -> Property*         {prefer} %% doesn't seem to work, use ebd* instead
    "srt" MetaVarSuffix     -> Sort              {prefer}
    "srt" MetaVarSuffix "*" -> {Sort ","}*       {prefer}
    "ann" [0-9]*     -> Annotation        {prefer}
    "ann" [0-9]* "*" -> {Annotation ","}* {prefer}
    "k"   [0-9]*     -> PropKind          {prefer}

    "dprop"[0-9]*     -> DeriveProperty   {prefer}
    "dprop"[0-9]* "*" -> {DeriveProperty ","}*  {prefer}

  context-free syntax
    "tdef"      "|[" TemplateDefinition  "]|" -> E {cons("ToMetaExpr")}
    "farg"      "|[" FormalArg           "]|" -> E {cons("ToMetaExpr")}
    "farg*"     "|[" {FormalArg ","}*    "]|" -> E {cons("ToMetaExpr")}
    "procelem"  "|[" ProcedureElement    "]|" -> E {cons("ToMetaExpr")}
    "procelem*" "|[" ProcedureElement*   "]|" -> E {cons("ToMetaExpr")}
    "elem"      "|[" TemplateElement     "]|" -> E {cons("ToMetaExpr")}
    "elem*"     "|[" TemplateElement*    "]|" -> E {cons("ToMetaExpr")}
    "call"      "|[" TemplateCall        "]|" -> E {cons("ToMetaExpr")}
    "call*"     "|[" TemplateCall*       "]|" -> E {cons("ToMetaExpr")}
    "exp"       "|[" Exp                 "]|" -> E {cons("ToMetaExpr")}
    "passign"   "|[" PropertyAssignment  "]|" -> E {cons("ToMetaExpr")}
    "passign*"  "|[" PropertyAssignment* "]|" -> E {cons("ToMetaExpr")}

  variables
    "tdef"[0-9]*                -> TemplateDefinition {prefer}
    "farg"[0-9]*                -> FormalArg          {prefer}
    "farg" MetaVarSuffix "*"    -> {FormalArg ","}*   {prefer}
    "elem"[0-9]+                -> TemplateElement    {prefer} %%[0-9]+ instead of [0-9]*, otherwise elements() is split into elem-ents()
    "elem"[0-9]* "*"            -> TemplateElement*   {prefer}
    "elem_"[A-Za-z0-9]+         -> TemplateElement    {prefer}
    "elem_"[A-Za-z0-9]+ "*"     -> TemplateElement*   {prefer}
    "call"[0-9]*                -> TemplateCall       {prefer}
    "call"[0-9]* "*"            -> TemplateCall*      {prefer}
    "passign" MetaVarSuffix     -> PropertyAssignment          {prefer}
    "passign" MetaVarSuffix "*" -> {PropertyAssignment ","}*   {prefer}
%%    "req" MetaVarSuffix     -> TemplateArg          {prefer}
%%    "req" MetaVarSuffix "*" -> {TemplateArg ","}*   {prefer}
    "req" MetaVarSuffix "*"   -> TemplateArgs {prefer}
    "template-body" MetaVarSuffix -> TemplateBody{prefer}
    "withblock" MetaVarSuffix   -> TemplateWith       {prefer}
    "withdef" MetaVarSuffix     -> ArgDefine          {prefer}
    "withdef" MetaVarSuffix "*"     -> {ArgDefine ","}* {prefer}

    "talt"[0-9]*            -> TemplateCaseAlt {prefer}
    "talt"[0-9]* "*"        -> TemplateCaseAlt* {prefer}

  context-free syntax
    "webdsl" "|[" Action     "]|" -> E {cons("ToMetaExpr")}
             "|[" Action     "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
             "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
    "stat"   "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Statement* "]|" -> E {cons("ToMetaExpr")}
    "stat*"  "|[" Statement* "]|" -> E {cons("ToMetaExpr")}
             "|[" Statement* "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Case       "]|" -> E {cons("ToMetaExpr")}
             "|[" Case       "]|" -> E {cons("ToMetaExpr")}

  variables

    "_act" [0-9]*          -> Action     {prefer}
    "stat" [0-9]*          -> Statement  {prefer}
    "stat" [0-9]* "*"      -> Statement* {prefer}
    "stat_"[A-Za-z0-9]*    -> Statement  {prefer}
    "stat_"[A-Za-z0-9]*"*" -> Statement* {prefer}
    "block"[0-9]*          -> Block      {prefer}

    "alt"[0-9]*            -> Case {prefer}
    "alt"[0-9]* "*"        -> Case* {prefer}

  context-free syntax
    "webdsl:e" "|[" Exp         "]|" -> E {cons("ToMetaExpr")}
    "|[" Exp         "]|" -> E {cons("ToMetaExpr")}
    "|[" Assignment  "]|" -> E {cons("ToMetaExpr")}
    "|[" Assignment* "]|" -> E {cons("ToMetaExpr")}

  variables

    "e"   [0-9\']*           -> Exp         {prefer}
    "e_"  [A-Za-z0-9\']+     -> Exp         {prefer}
    "e"   [0-9\']* "*"       -> {Exp ","}*  {prefer}
    "e_"  [A-Za-z0-9\']+ "*" -> {Exp ","}*  {prefer}

    "e"   [0-9\']*           -> TemplateArgExp        {prefer}
    "e_"  [A-Za-z0-9\']+     -> TemplateArgExp        {prefer}
    "e"   [0-9\']* "*"       -> {TemplateArgExp ","}* {prefer}
    "e_"  [A-Za-z0-9\']+ "*" -> {TemplateArgExp ","}* {prefer}

    "fltr"[0-9]*             -> Filter      {prefer}
    "asgn"[0-9]*             -> Assignment  {prefer}
    "asgn"[0-9]* "*"         -> Assignment* {prefer}
    "fun"[0-9]*              -> Function    {prefer}
    "fun"[0-9]* "*"          -> Function*   {prefer}
    "ebd"[0-9]*              -> EntityBodyDeclaration    {prefer}
    "ebd"[0-9]* "*"          -> EntityBodyDeclaration*   {prefer}
    "ebd" MetaVarSuffix      -> EntityBodyDeclaration    {prefer}
    "ebd" MetaVarSuffix "*"  -> EntityBodyDeclaration*   {prefer}

  variables

    "qid"[0-9]*                -> QId     {prefer}
    [xyz][0-9]*                -> Id      {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> Id      {prefer}
    [xyz][0-9]*                -> PageId  {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> PageId  {prefer}
    [xyz][0-9]*                -> ModuleName      {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> ModuleName      {prefer}
    [xyz][0-9]*                -> SectionName     {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> SectionName     {prefer}
    [xyz][0-9]*                -> ExtendedId      {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> ExtendedId      {prefer}
    [xyz][0-9]*                -> TemplateCallId  {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> TemplateCallId  {prefer}
    [xyz][0-9]*                -> GlobalFunCallId {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> GlobalFunCallId {prefer}
    [xyz] MetaVarSuffix        -> Identifier[[HQL]] {prefer} %%hql identifier
    %%[xyz]"_"[A-Za-z0-9\']+ "*" -> Id*     {prefer}
    [xyz][0-9]*                -> MatchId {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> MatchId {prefer}
    "str"[0-9]*                -> StringLex  {prefer}
    "str_"[A-Za-z0-9]+         -> StringLex-LEX  {prefer}
    "i_"[A-Za-z0-9]+           -> Int      {prefer}

    "const"[0-9]*              -> ConstValue {prefer}

  lexical syntax

    [\$][A-Za-z0-9]* -> IdVar
    [\$][A-Za-z0-9]* -> Id[[StrategoHost]]

  lexical restrictions

    IdVar -/- [A-Za-z0-9]

  variables

    IdVar -> Id {prefer}
     IdVar -> TemplateCallId {prefer}
     IdVar -> MatchId {prefer}

module Stratego-Sugar-Overlays
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Terms

exports
  sorts Overlay
  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module Stratego-Sugar-DynamicRules
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules

exports
 
  sorts ScopeLabels
  context-free syntax

    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}

    {DynRuleScopeId ","}*   -> ScopeLabels
    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}

  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
  context-free syntax

    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}

    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}

    DynRuleId ":="  Term        -> DynRuleDef {cons("DynRuleAssign")}
    DynRuleId ":+="  Term       -> DynRuleDef {cons("DynRuleAssignAdd")}

    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}

    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
    RuleDec                     -> DynRuleId {cons("DynRuleId")}

    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}

  context-free syntax

    Id                          -> RuleDec {cons("RDecNoArgs")}
    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}

  sorts RuleNames
  context-free syntax
    {Id ","}*				  -> RuleNames
    "~" Term				  -> RuleNames {cons("RuleNames")}

    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}

  syntax
    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}


  context-free syntax
    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}

    Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}

  priorities
    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")}
  > {

    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    }
  > <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("AM")}

  context-free priorities
    StrategyAngle Term 		          -> Strategy {cons("BA")}
  > "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
  > Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}

module Stratego-Sugar-Rules
imports Stratego-Sugar-Strategies
exports

  sorts RuleDef
  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
    
    Anno+ RuleDef               -> Def {cons("AnnoDef")}

    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}

    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}
       
    %% Rule definition with pattern matched term parameters
    Id "(" {Typedid ","}* 
       "|" {Term ","}* ")" ":" Rule 		-> RuleDef {cons("RDefP"), avoid}

  sorts Rule RuleCond
  context-free syntax
    Term "->" Term           	    -> Rule {cons("RuleNoCond")} %% backward comp.
    Term "->" Term "where" Strategy -> Rule {cons("Rule")}       %% backward comp.
    Term "->" Term RuleCond+	    -> Rule {cons("Rule"), avoid}

    "where" Strategy -> RuleCond {cons("WhereClause")}
    "with"  Strategy -> RuleCond {cons("WithClause")}

module Stratego-Sugar-Strategies
imports
  Stratego-Core-Strategies
  Stratego-Sugar-Terms
  Stratego-Sugar-Constants
  Stratego-Sugar-Signatures

exports
  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

    %% Strategy definition with pattern matched term parameters
    Id "(" {Typedid ","}* "|" {Term ","}* ")" "=" Strategy -> StrategyDef {cons("SDefP"), avoid}

  context-free syntax
    ID 				  	  -> Typedid {cons("DefaultVarDec")}

  sorts Rule

  sorts StrategyParen StrategyCurly StrategyAngle
  context-free syntax

    %% Abstraction

    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}

    %% Match and build

    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}

     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}

    %% Combinators

    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "with"  "(" Strategy ")" 		  -> Strategy {cons("With"), prefer}
    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}

    %% Primitives

    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}

    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}
    Char 			 	  -> Strategy {cons("CharCong")}

    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    
    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}

    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
   "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

%%    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
%%    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
%%    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

  %% Syntactic sugar sugar

  sorts SwitchCase
  context-free syntax

    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
    "(" Rule ")" 			  -> Strategy {cons("SRule")}
    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

    "proceed" "(" {Strategy "," }+ ")" -> Strategy {cons("Proceed"), prefer}

    "if" Strategy "then" Strategy 
                  "else" Strategy "end"   -> Strategy {cons("CondChoice")}
    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}

    "switch" Strategy SwitchCase* "end"   -> Strategy {cons("SwitchChoiceNoOtherwise")}
    "switch" Strategy SwitchCase*
         "otherwise" ":" Strategy "end"   -> Strategy {cons("SwitchChoice")}

    "case" Strategy ":" Strategy          -> SwitchCase {cons("SwitchCase")}

    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}

    Term ":=" Term			  -> Strategy {cons("Assign")}

  %% Priorities

  context-free priorities
    { Strategy StrategyCurly		  -> Strategy
      Strategy "#" StrategyParen          -> Strategy
    }
  > { "!" Term 				  -> Strategy
      "?" Term 				  -> Strategy
    }
  > StrategyAngle Term 		          -> Strategy
  > Strategy "=>" Term 		  	  -> Strategy
  > Strategy ";" Strategy 		  -> Strategy
  > {right: 
     Strategy "+" Strategy 		  -> Strategy
     Strategy "<+" Strategy 		  -> Strategy
     Strategy "+>" Strategy 		  -> Strategy
     
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy
    }

  context-free priorities
    Strategy 				  -> StrategyMid
  > Strategy "+" Strategy 		  -> Strategy

  context-free priorities
    { Strategy StrategyCurly      -> Strategy
      Strategy "#" StrategyParen  -> Strategy
    }
    .> Term ":=" Term -> Strategy


module Stratego-Sugar-Terms
imports
  Stratego-Core-Terms
  Stratego-Sugar-Strategies

exports
  sorts LID
  context-free syntax
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    LID				-> ID

  context-free syntax
    "_" PreTerm 		 -> PreTerm {cons("BuildDefaultPT")}
    "_" Term 			 -> Term {cons("BuildDefault"),prefer}

    Char 			 -> PreTerm {cons("Char")}

    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
    PreTerm                      -> Term {cons("NoAnnoList")}

    "<" Strategy ">" Term 	 -> PreTerm {cons("App")}
    "<" Strategy ">" Term 	 -> Term {cons("App"),prefer}

    StrategyAngle		 -> PreTerm {cons("RootApp")}
    StrategyAngle		 -> Term {cons("RootApp"),prefer}

    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Sugar-Signatures
imports
  Stratego-Core-Signatures
  Stratego-Sugar-Constants

exports

  sorts Sort
  context-free syntax
    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}

  sorts Kind
  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

module Stratego-Core-Signatures
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants
exports
  sorts Sdecl
  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  sorts Sort
  context-free syntax
    LCID 			 -> Sort {cons("SortVar")}
    UCID 			 -> Sort {cons("SortNoArgs")}
    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}

  sorts Opdecl
  context-free syntax
    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
           ":" Type 		-> Opdecl {cons("OpDeclInj")}

  context-free syntax
    "external" Id     ":" Type 	-> Opdecl {cons("ExtOpDecl")}
    "external" String ":" Type 	-> Opdecl {cons("ExtOpDeclQ")}
    "external"        ":" Type 	-> Opdecl {cons("ExtOpDeclInj")}

  sorts Type ArgType ConstType FunType RetType
  context-free syntax
    Sort	                -> ConstType {cons("ConstType")}
    {ArgType "*"}+ "->" RetType -> FunType {cons("FunType")}
    "(" Type ")"                -> ArgType {bracket}
    ConstType			-> ArgType
    Type	                -> RetType
    FunType			-> RetType {reject}

    FunType			-> Type
    ConstType			-> Type

  %%%
   %% Restriction is required for the Sort* in Sdecl: List(a) is
   %% ambiguous.
   %%%
  context-free restrictions
    Sort -/- [\(]

module Stratego-Core-Terms
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants

exports
  sorts ID Var Wld
  context-free syntax
    Id 				-> Var  {cons("Var")}
    Id				-> ID
    %% ":" Var                  -> Var  {cons("SeqVar")}

  sorts Term PreTerm
  context-free syntax
    Var 			 -> PreTerm 
    Var 			 -> Term {prefer}

    "_" 			 -> Wld {cons("Wld")}
    Wld 			 -> PreTerm
    Wld 			 -> Term {prefer}

    Int 			 -> PreTerm {cons("Int")}
    Real 			 -> PreTerm {cons("Real")}
    String 			 -> PreTerm {cons("Str")}

    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}

    PreTerm "{^" PreTerm "}"	 -> Term {cons("Anno")}

    Var "@" Term 		 -> Term {cons("As"),prefer}
    Var "@" PreTerm 		 -> PreTerm {cons("As")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Core-Strategies
imports
  Stratego-Core-Terms
  Stratego-Core-Constants
  Stratego-Core-Signatures

exports
  sorts Def
  context-free syntax
    StrategyDef					 -> Def 
    Id						 -> SVar {cons("SVar")}
    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}

    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}


  sorts StrategyDef
  context-free syntax
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}

    Anno+ StrategyDef -> Def {cons("AnnoDef")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}

    "external"
    EmptyId "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}


  sorts EmptyId
  lexical syntax
  
    -> EmptyId

  sorts Anno
  context-free syntax
    "extend"      -> Anno {cons("Extend")}
    "override"    -> Anno {cons("Override")}
    "internal"    -> Anno {cons("Internal")}
%%  "sealed"      -> Anno {cons("Sealed")}
%%  "extensible"  -> Anno {cons("Extensible")}
%%  "overridable" -> Anno {cons("Overridable")}

  lexical syntax
    
    "extend"      -> Keyword
    "override"    -> Keyword
    "internal"    -> Keyword
    "sealed"      -> Keyword
    "extensible"  -> Keyword
    "overridable" -> Keyword

  lexical restrictions
  
    "extend"
    "override"
    "internal"
    "sealed"
    "extensible"
    "overridable" -/- [a-zA-Z0-9\'\-\_]

  sorts Typedid
  context-free syntax
    ID ":" Type 			  -> Typedid {cons("VarDec")}


  sorts Strategy SVar StrategyParen StrategyMid 
  context-free syntax
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "fail" 				  -> Strategy {cons("Fail")}
    "id" 				  -> Strategy {cons("Id")}

    "proceed" "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("ProceedT"), prefer}
    "proceed"                                         -> Strategy {cons("ProceedNoArgs"), prefer}

    %% Match and build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}

    %% Combinators

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    %% Primitives

    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}

    %% Traversal

    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}

  %% Priorities

  context-free priorities
    { "!" Term 				  -> Strategy {cons("Build")}
      "?" Term 				  -> Strategy {cons("Match")}
    }
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

  context-free syntax
    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}

module Stratego-Core-Modules
imports
  Stratego-Core-Identifiers
  Stratego-Core-Strategies
  Stratego-Core-Signatures

exports 
  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}
    "specification" Decl*	 -> Module {cons("Specification")}

  sorts Decl 
  context-free syntax
    "imports" ImportModName* 	-> Decl {cons("Imports")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}

  sorts ImportModName
  context-free syntax
    ModName              -> ImportModName {cons("Import")}
  syntax
    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}

module Stratego-Sugar-Modules
imports
  Stratego-Core-Modules
  Stratego-Sugar-Strategies
  Stratego-Sugar-Signatures
  Stratego-Sugar-Overlays
  Stratego-Sugar-Rules

exports 

  sorts Decl Def
  context-free syntax
    "rules" Def* 		-> Decl {cons("Rules")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    RuleDef 			-> Def 


module Stratego-Sugar-StringQuotations
exports

  sorts
    StringQuotation
    StringQuotedPart1 StringQuotedChars1 DollarOpen1 DollarClose1 QuotedBracket1 Dollar1
    StringQuotedPart2 StringQuotedChars2 DollarOpen2 DollarClose2 QuotedBracket2 Dollar2
    StringQuotedPart3 StringQuotedChars3 DollarOpen3 DollarClose3 QuotedBracket3 Dollar3
    StringQuotedPart4 StringQuotedChars4 DollarOpen4 DollarClose4 QuotedBracket4  Dollar4
    Padding

  context-free syntax

    StringQuotation -> PreTerm

  syntax

    StringQuotation -> <PreTerm-CF>

    "$" "[" Padding StringQuotedPart1*               "]"    -> StringQuotation {cons("StringQuotation1") }
     Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]"    -> StringQuotedPart1 {cons("StringEscape1")}
    <StringQuotedChars1-LEX>                                -> StringQuotedPart1 {cons("QStr")}
    <Dollar1-LEX>                                           -> StringQuotedPart1 {cons("QDollar")}
    "$" <QuotedBracket1-LEX> "$"                            -> StringQuotedPart1 {cons("QBr")}
    ~[\[\]\$]+                                              -> <StringQuotedChars1-LEX>
    [\[\]]                                                  -> <QuotedBracket1-LEX>
    "$"                                                     -> <Dollar1-LEX>

    "$" "{" Padding StringQuotedPart2*               "}"    -> StringQuotation {cons("StringQuotation2") }
     Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}"    -> StringQuotedPart2 {cons("StringEscape2")}
    <StringQuotedChars2-LEX>                                -> StringQuotedPart2 {cons("QStr")}
    <Dollar2-LEX>                                           -> StringQuotedPart2 {cons("QDollar")}
    "$" <QuotedBracket2-LEX> "$"                            -> StringQuotedPart2 {cons("QBr")}
    ~[\{\}\$]+                                              -> <StringQuotedChars2-LEX>
    [\{\}]                                                  -> <QuotedBracket2-LEX>
    "$"                                                     -> <Dollar2-LEX>

    "$" "(" Padding StringQuotedPart3*              ")"     -> StringQuotation {cons("StringQuotation3") }
    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")"     -> StringQuotedPart3 {cons("StringEscape3")}
    <StringQuotedChars3-LEX>                                -> StringQuotedPart3 {cons("QStr")}
    <Dollar3-LEX>                                           -> StringQuotedPart3 {cons("QDollar")}
    "$" <QuotedBracket3-LEX> "$"                            -> StringQuotedPart3 {cons("QBr")}
    ~[\(\)\$]+                                              -> <StringQuotedChars3-LEX>
    [\(\)]                                                  -> <QuotedBracket3-LEX>
    "$"                                                     -> <Dollar3-LEX>

    "$" "<" Padding StringQuotedPart4*               ">"    -> StringQuotation {cons("StringQuotation4") }
    Padding "<"  <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">"    -> StringQuotedPart4 {cons("StringEscape4")}
    <StringQuotedChars4-LEX>                                -> StringQuotedPart4 {cons("QStr")}
    <Dollar4-LEX>                                           -> StringQuotedPart4 {cons("QDollar")}
    "$" <QuotedBracket4-LEX> "$"                            -> StringQuotedPart4 {cons("QBr")}
    ~[\<\>\$]+                                              -> <StringQuotedChars4-LEX>
    [\<\>]                                                  -> <QuotedBracket4-LEX>
    "$"                                                     -> <Dollar4-LEX>
   
    %% Padding is a dummy lexical that will contain the indentation prefix of every quotation
    <Padding-LEX>                                           -> Padding
                                                            -> <Padding-LEX> {indentpadding}

  lexical restrictions

    StringQuotedChars1 -/- ~[\[\]\$]   
    StringQuotedChars2 -/- ~[\{\}\$]    
    StringQuotedChars3 -/- ~[\(\)\$]    
    StringQuotedChars4 -/- ~[\<\>\$]
    Dollar1            -/- [\[\]] . [\$]
    Dollar2            -/- [\{\}] . [\$]
    Dollar3            -/- [\(\)] . [\$]
    Dollar4            -/- [\<\>] . [\$]

module Stratego-Core-Constants
exports
  sorts Int Real String StrChar
  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\\] 			-> StrChar
    [\\] [\"tnr\\] 		-> StrChar


module Stratego-Sugar-Constants
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants
  Stratego-Sugar-StringQuotations
exports
  sorts Char CharChar
  lexical syntax
    "'" CharChar "'"		-> Char
    ~[\']			-> CharChar
    [\\] [\'ntr\ ]		-> CharChar
    Char		 	-> Id {reject}

module Stratego-Core-Identifiers
exports
  sorts ModName ModNamePart
  lexical syntax
    {ModNamePart "/"}+ -> ModName
    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}

  sorts Id LId LCID UCID Wld
  lexical syntax
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
    [\'] [a-z]+                       -> Id

    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID

  lexical restrictions
    Id   -/- [a-zA-Z0-9\'\_\*]
    Id   -/- [\-].~[\>]
    LId  -/- [a-zA-Z0-9\'\-\_]
    LCID -/- [a-zA-Z0-9\'\-\_]
    UCID -/- [a-zA-Z0-9\'\-\_]

  lexical syntax
    "_"     -> Id {reject}
    "'"     -> Id {reject}

    Keyword -> Id   {reject}
    Keyword -> LId  {reject}
    Keyword -> LCID {reject}
    Keyword -> UCID {reject}

  lexical restrictions
    "all"
    "case" %% not reserved kw
    "constructors"
    "else" %% not reserved kw
    "end" %% not reserved kw
    "external" %% not reserved kw
    "fail"
    "id"
    "if" %% not reserved kw
    "in"
    "imports" %% not reserved kw
    "let"
    "module"
    "not"
    "one"
    "overlays"
    "otherwise" %% not reserved kw
    "prim"
    "rec" %% not reserved kw
    "rules"
    "script"
    "signature"
    "some"
    "sorts"
    "strategies"
    "stratego"
    "switch" %% not reserved kw
    "test"
    "then" %% not reserved kw
    "where"
    "import-term"
      -/- [a-zA-Z0-9\'\-\_]
  
  context-free restrictions
    Wld -/- [a-zA-Z0-9\'\-\_]

  sorts Keyword
  lexical syntax
    "all"               -> Keyword
    "constructors" 	-> Keyword
    "fail" 		-> Keyword
    "id" 		-> Keyword
    "in" 		-> Keyword
    "let" 		-> Keyword
    "module" 		-> Keyword
    "not" 		-> Keyword
    "one" 		-> Keyword
    "overlays" 		-> Keyword
    "prim" 		-> Keyword
    "rules" 		-> Keyword
    "script" 		-> Keyword
    "signature" 	-> Keyword
    "some" 		-> Keyword
    "sorts" 		-> Keyword
    "strategies" 	-> Keyword
    "stratego" 		-> Keyword
    "test" 		-> Keyword
    "where" 		-> Keyword
    "import-term"	-> Keyword


module Stratego-Core-Layout
exports
  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
  lexical syntax
    [\t\ \n\r]			-> Ws

    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
    "/*" CommChar* "*/"	-> LongCom
				-> Eof  

    ~[\*]     -> CommChar

    "*"       -> Asterisk
    Asterisk  -> CommChar

  lexical restrictions
    Asterisk -/- [\/]
    Eof      -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    Ws 		-> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\*]
    LAYOUT? -/- [\/].[\/]

module Stratego-Sugar-Layout
imports Stratego-Core-Layout
%%exports
%%  sorts VeryLongCom Eof VLCchar Backslash
%%  lexical syntax
%%    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
%%    "\\begin{code}" 			   -> VeryLongCom
%%    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
%%    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
%%    ~[\\] 				   -> VLCchar
%%    Backslash 				   -> VLCchar
%%    [\\] 				   -> Backslash

%%  lexical restrictions
%%    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
%%    Eof -/- ~[]

%%  lexical syntax
%%    VeryLongCom -> LAYOUT



module Stratego-Sugar
imports
  Stratego-Sugar-Layout
  Stratego-Core-Identifiers
  Stratego-Sugar-Constants 
  Stratego-Sugar-Modules
  Stratego-Sugar-Signatures
  Stratego-Sugar-Terms
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules
  Stratego-Sugar-DynamicRules
  Stratego-Sugar-Overlays

hiddens
  context-free start-symbols Module

module Stratego
imports Stratego-Sugar
hiddens
  context-free start-symbols Module

module StrategoMix[Ctx10]
imports Stratego
          [ RuleNames          => RuleNames[[Ctx10]]
            RuleDec            => RuleDec[[Ctx10]]
            DynRuleScopeId     => DynRuleScopeId[[Ctx10]]
            DynRuleId          => DynRuleId[[Ctx10]]
            DynRuleDef         => DynRuleDef[[Ctx10]]
            ScopeLabels        => ScopeLabels[[Ctx10]]
            RuleCond           => RuleCond[[Ctx10]]
            Rule               => Rule[[Ctx10]]
            RuleDef            => RuleDef[[Ctx10]]
            Overlay            => Overlay[[Ctx10]]
            SwitchCase         => SwitchCase[[Ctx10]]
            StrategyCurly      => StrategyCurly[[Ctx10]]
            StrategyAngle      => StrategyAngle[[Ctx10]]
            Kind               => Kind[[Ctx10]]
            LID                => LID[[Ctx10]]
            ImportModName      => ImportModName[[Ctx10]]
            Decl               => Decl[[Ctx10]]
            Module             => Module[[Ctx10]]
            StrategyParen      => StrategyParen[[Ctx10]]
            Typedid            => Typedid[[Ctx10]]
            Anno               => Anno[[Ctx10]]
            EmptyId            => EmptyId[[Ctx10]]
            StrategyDef        => StrategyDef[[Ctx10]]
            SVar               => SVar[[Ctx10]]
            Def                => Def[[Ctx10]]
            Type               => Type[[Ctx10]]
            RetType            => RetType[[Ctx10]]
            ArgType            => ArgType[[Ctx10]]
            FunType            => FunType[[Ctx10]]
            ConstType          => ConstType[[Ctx10]]
            Opdecl             => Opdecl[[Ctx10]]
            Sort               => Sort[[Ctx10]]
            Sdecl              => Sdecl[[Ctx10]]
            Wld                => Wld[[Ctx10]]
            ID                 => ID[[Ctx10]]
            Var                => Var[[Ctx10]]
            CharChar           => CharChar[[Ctx10]]
            Char               => Char[[Ctx10]]
            Padding            => Padding[[Ctx10]]
            Dollar4            => Dollar4[[Ctx10]]
            QuotedBracket4     => QuotedBracket4[[Ctx10]]
            StringQuotedChars4 => StringQuotedChars4[[Ctx10]]
            StringQuotedPart4  => StringQuotedPart4[[Ctx10]]
            Dollar3            => Dollar3[[Ctx10]]
            QuotedBracket3     => QuotedBracket3[[Ctx10]]
            StringQuotedChars3 => StringQuotedChars3[[Ctx10]]
            StringQuotedPart3  => StringQuotedPart3[[Ctx10]]
            Dollar2            => Dollar2[[Ctx10]]
            QuotedBracket2     => QuotedBracket2[[Ctx10]]
            StringQuotedChars2 => StringQuotedChars2[[Ctx10]]
            StringQuotedPart2  => StringQuotedPart2[[Ctx10]]
            Dollar1            => Dollar1[[Ctx10]]
            QuotedBracket1     => QuotedBracket1[[Ctx10]]
            StringQuotedChars1 => StringQuotedChars1[[Ctx10]]
            StringQuotedPart1  => StringQuotedPart1[[Ctx10]]
            StringQuotation    => StringQuotation[[Ctx10]]
            StrChar            => StrChar[[Ctx10]]
            String             => String[[Ctx10]]
            Real               => Real[[Ctx10]]
            Int                => Int[[Ctx10]]
            Keyword            => Keyword[[Ctx10]]
            UCID               => UCID[[Ctx10]]
            LCID               => LCID[[Ctx10]]
            LId                => LId[[Ctx10]]
            Id                 => Id[[Ctx10]]
            ModNamePart        => ModNamePart[[Ctx10]]
            ModName            => ModName[[Ctx10]]
            PreTerm            => PreTerm[[Ctx10]]
            Term               => Term[[Ctx10]]
            StrategyMid        => StrategyMid[[Ctx10]]
            Strategy           => Strategy[[Ctx10]] ]


module StrategoWebDSL

imports
  StrategoMix[StrategoHost]
  WebDslMix[ Term[[StrategoHost]] ]

hiddens
  context-free start-symbols Module[[StrategoHost]]

module Stratego-WebDSL-Java

imports
  StrategoWebDSL
  languages/java/EmbeddedJavaMix[Java Term[[StrategoHost]]]

hiddens
  context-free start-symbols Module[[StrategoHost]]

exports

  context-free syntax

    %% concat-ids extension for java; see java-concat-ids.str

    { ID[[Java]] "#" }+ -> ID[[Java]] {avoid, cons("ConcatIds")}