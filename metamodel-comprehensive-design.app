// =============================================================================
// COMPREHENSIVE WEBDSL METAMODEL - Formalism Extraction
// =============================================================================
//
// PURPOSE: All-encompassing metamodel that can describe the complete WebDSL
//          formalism as data, enabling:
//          1. Self-description (Ouroboros closure)
//          2. Code generation from database
//          3. Visual modeling tools
//          4. Multi-target generation (future)
//
// PHILOSOPHY: Formalism Extraction (not mapping)
//             - Extract WebDSL's implicit structure
//             - Make it explicit through entities
//             - WebDSL describes WebDSL
//
// STATUS: Design document (not yet implemented)
//         Shows what a complete metamodel would contain
//
// =============================================================================

application metamodel

// =============================================================================
// SECTION 1: APPLICATION & MODULE STRUCTURE
// =============================================================================
//
// WebDSL apps are organized as:
//   application MyApp
//   module MyModule
//   import OtherModule
//   section "Entities"

entity Application {
  name : String                        // "metamodel", "blog", etc.

  // Structure
  modules : {Module} (inverse = application)
  imports : {ModuleImport}             // External dependencies
  sections : {Section}                 // Organizational sections

  // Data model
  entities : {Entity} (inverse = application)
  sessionEntities : {SessionEntity} (inverse = application)
  types : {CustomType}                 // Enums, value types

  // UI
  pages : {Page} (inverse = application)
  templates : {Template} (inverse = application)

  // Behavior
  functions : {Function} (inverse = application)

  // Security
  principal -> Entity                  // Which entity is the user?
  accessRules : {AccessRule}

  // Features
  searchConfig : {SearchConfig}
  emailTemplates : {EmailTemplate}
  services : {Service}

  // Configuration
  config -> AppConfiguration
}

entity Module {
  name : String
  application -> Application
  exports : {ExportedDefinition}       // What this module provides
}

entity ModuleImport {
  moduleName : String                  // "webdsl.core", "mylib"
}

entity Section {
  title : String                       // "Data Model", "Pages", etc.
  // Used for code organization only
}

// =============================================================================
// SECTION 2: TYPE SYSTEM
// =============================================================================
//
// WebDSL types:
//   - Built-in: String, Int, Bool, Email, Date, DateTime, etc.
//   - Custom: enums, value types
//   - Entity references
//   - Collections: {T}, [T]

entity DataType {
  name : String                        // Base type name
  category : String                    // "primitive", "builtin", "entity", "enum", "custom"

  // For built-in types
  builtIn : Bool := category == "builtin"

  // For collection types
  isCollection : Bool
  collectionKind : String              // "set", "list", ""
  elementType -> DataType              // Type of elements

  // For entity references
  referencedEntity -> Entity

  // For custom types (enums)
  enumValues : {EnumValue}
}

entity EnumValue {
  identifier : String                  // Internal name
  displayName : String                 // Human-readable
  type -> DataType
}

// =============================================================================
// SECTION 3: ENTITIES (Extended from Phase 1)
// =============================================================================
//
// Core data structures with properties, relationships, validation, functions

entity Entity {
  name : String                        // "Person", "BlogPost"
  application -> Application

  // Structure
  properties : {Property} (inverse = entity)
  relationships : {Relationship} (inverse = sourceEntity)

  // Inheritance
  superEntity -> Entity                // extend Person : User
  subEntities : {Entity} (inverse = superEntity)

  // Behavior
  functions : {EntityFunction} (inverse = entity)
  predicates : {Predicate} (inverse = entity)
  derivedProperties : {DerivedProperty} (inverse = entity)

  // Validation
  validationRules : {ValidationRule} (inverse = entity)

  // Features
  isCrudEnabled : Bool                 // derive CRUD Entity
  isSearchable : Bool                  // Has searchable properties

  // Metadata (auto-generated by WebDSL)
  hasAutoId : Bool := true             // id : UUID
  hasVersion : Bool := true            // version : Int
  hasTimestamps : Bool := true         // created, modified
}

entity SessionEntity {
  name : String
  application -> Application
  properties : {Property} (inverse = sessionEntity)
  // Session entities are not persisted, exist only in HTTP session
}

entity Property {
  name : String                        // "email", "age"
  type -> DataType                     // String, Int, Email, etc.

  // Owning entity
  entity -> Entity
  sessionEntity -> SessionEntity       // If part of session entity

  // Constraints
  isRequired : Bool                    // (not null)
  defaultValue : String                // default="active"
  maxLength : Int                      // (length=255)

  // Annotations
  isId : Bool                          // (id) - unique identifier
  isName : Bool                        // (name) - display name
  isSearchable : Bool                  // (searchable)

  // Allowed values (enum-like)
  allowedValues : {AllowedValue}       // (allowed=["admin","user"])
  allowedQuery : String                // (allowed={User.all()})

  // Validation
  validationRules : {ValidationRule} (inverse = property)
}

entity AllowedValue {
  value : String
  property -> Property
}

entity DerivedProperty {
  name : String
  type -> DataType
  expression : Text                    // "firstname + ' ' + lastname"
  entity -> Entity
  // Derived properties are read-only, computed from expression
}

entity Relationship {
  name : String                        // "author", "posts"
  kind : String                        // "reference", "collection", "list"

  sourceEntity -> Entity
  targetEntity -> Entity

  // Bidirectional support
  inverseName : String                 // "" if unidirectional

  // For collections
  isOrdered : Bool                     // list vs set
}

// =============================================================================
// SECTION 4: VALIDATION SYSTEM
// =============================================================================
//
// validate(expression, message)
// Can appear at: entity level, property level, form level, action level

entity ValidationRule {
  expression : Text                    // "age >= 18"
  message : String                     // "Must be adult"
  level : String                       // "entity", "property", "form", "action"

  // Context
  entity -> Entity                     // If entity-level
  property -> Property                 // If property-level
  input -> InputElement                // If form-level
  action -> Action                     // If action-level
}

// =============================================================================
// SECTION 5: PAGES & TEMPLATES
// =============================================================================
//
// page root() { ... }
// template personCard(p : Person) { ... }
// ajax template details(id : UUID) { ... }

entity Page {
  name : String                        // "root", "showPerson"
  application -> Application

  // Parameters
  parameters : {PageParameter}

  // Content
  elements : {PageElement} (inverse = page)

  // Variables
  variables : {PageVariable}

  // Metadata
  isAjax : Bool                        // ajax page
  isRoot : Bool                        // Root page (no args, default)

  // Access control
  accessRules : {AccessRule}
}

entity Template {
  name : String                        // "personCard", "header"
  application -> Application

  parameters : {TemplateParameter}
  elements : {PageElement} (inverse = template)

  isAjax : Bool                        // ajax template
  isOverride : Bool                    // Overrides built-in template

  accessRules : {AccessRule}
}

entity PageParameter {
  name : String                        // "p", "id"
  type -> DataType                     // Person, UUID
  page -> Page
}

entity TemplateParameter {
  name : String
  type -> DataType
  template -> Template
}

entity PageVariable {
  name : String                        // var x := 5
  type -> DataType
  initialValue : String                // "5", "Person{}"
  page -> Page
}

// Page elements represent the UI structure
entity PageElement {
  kind : String                        // "title", "header", "par", "form", "output", etc.

  page -> Page
  template -> Template
  parentElement -> PageElement         // Nesting structure
  childElements : {PageElement} (inverse = parentElement)

  // Content
  content : Text                       // Text content, code, expressions

  // For specific element types
  formElements : {FormElement}         // If kind="form"
  controlStructure -> ControlStructure // If kind="for"|"if"|"while"

  // Order
  position : Int
}

entity FormElement {
  kind : String                        // "input", "select", "textarea", "submit"

  pageElement -> PageElement

  // Binding
  boundProperty : String               // "person.name"

  // For submit buttons
  action -> Action

  // For inputs
  inputType : String                   // "text", "email", "password", "ajax"
  validationRules : {ValidationRule}
}

entity InputElement {
  formElement -> FormElement
  validationRules : {ValidationRule} (inverse = input)
}

entity ControlStructure {
  kind : String                        // "for", "if", "while", "switch"

  // For loop
  iteratorVar : String                 // "person"
  iteratorType -> DataType             // Person
  collection : String                  // "Person.all()"
  whereClause : String                 // "age > 18"
  orderBy : String                     // "name asc"
  limit : Int
  offset : Int
  separatedBy : String                 // ", "

  // If/while
  condition : String                   // Boolean expression

  // Switch
  switchExpr : String
  cases : {SwitchCase}
}

entity SwitchCase {
  pattern : String                     // "active", "default"
  isDefault : Bool
  controlStructure -> ControlStructure
}

// =============================================================================
// SECTION 6: FUNCTIONS & ACTIONS
// =============================================================================
//
// function greet(name : String) : String { ... }
// action save() { ... }
// cached function expensive() : Int { ... }

entity Function {
  name : String                        // "greet", "generateCode"

  application -> Application           // Global function
  entity -> EntityFunction             // Or entity function

  // Signature
  parameters : {FunctionParameter}
  returnType -> DataType

  // Body
  body : Text                          // WebDSL action code

  // Modifiers
  isCached : Bool                      // cached function
  isPredicate : Bool                   // predicate (returns Bool, single expr)

  // Access control
  accessRules : {AccessRule}
}

entity EntityFunction {
  function -> Function
  entity -> Entity

  // Has implicit "this" reference to entity
}

entity Predicate {
  name : String
  expression : Text                    // Single boolean expression
  entity -> Entity
}

entity FunctionParameter {
  name : String
  type -> DataType
  function -> Function
  position : Int
}

entity Action {
  name : String                        // "doSave", "deleteUser"

  // Context
  page -> Page                         // Actions defined in pages
  formElement -> FormElement           // submit action

  // Code
  body : Text                          // Action code statements

  // Return
  returnType : String                  // "page", "void", "file"
  returnTarget : String                // Page name or expression

  // Access control
  accessRules : {AccessRule}
}

// =============================================================================
// SECTION 7: ACCESS CONTROL
// =============================================================================
//
// principal is User with credentials username, password
// rule page editProfile(u : User) { u == principal }
// rule action delete() { principal.isAdmin }

entity Principal {
  entity -> Entity                     // Which entity is the user?
  credentialProperty1 : String         // "username" or "email"
  credentialProperty2 : String         // "password"

  application -> Application
}

entity AccessRule {
  targetType : String                  // "page", "action", "template", "function"
  targetName : String                  // "editProfile", "delete"

  // Wildcards
  useWildcard : Bool                   // rule page admin*

  // Condition
  condition : Text                     // "u == principal", "principal.isAdmin"

  // Targets
  page -> Page
  action -> Action
  template -> Template
  function -> Function
}

// =============================================================================
// SECTION 8: AJAX OPERATIONS
// =============================================================================
//
// ajax operations: replace, append, clear, visibility, restyle, etc.
// placeholder leftbar { ... }

entity AjaxOperation {
  kind : String                        // "replace", "append", "clear", "visibility", etc.

  action -> Action                     // Where operation occurs

  // Target
  targetId : String                    // Element ID or placeholder name
  targetExpr : String                  // Dynamic expression

  // Arguments
  templateCall : String                // For replace/append
  cssClass : String                    // For restyle
  visibility : String                  // "show", "hide", "toggle"
  scriptCode : Text                    // For runscript
  navigateTo : String                  // For relocate
}

entity Placeholder {
  name : String                        // "leftbar", "content"
  isAjax : Bool                        // ajax placeholder
  defaultContent : Text                // Default template or text

  page -> Page
}

// =============================================================================
// SECTION 9: SERVICES (JSON APIs)
// =============================================================================
//
// service getUser(id : String) : String { ... }

entity Service {
  name : String                        // "getUser", "updatePost"

  application -> Application

  // Signature (like Function)
  parameters : {ServiceParameter}
  returnType -> DataType               // Usually String (JSON)

  // Body
  body : Text                          // Service code

  // HTTP support
  supportsGet : Bool
  supportsPut : Bool
  supportsPost : Bool
  supportsDelete : Bool

  // Access control
  accessRules : {AccessRule}
}

entity ServiceParameter {
  name : String
  type -> DataType
  service -> Service
  position : Int
}

// =============================================================================
// SECTION 10: SEARCH (Lucene)
// =============================================================================
//
// Properties marked (searchable)
// Generated functions: searchEntity(query), searchEntity(query, limit, offset)

entity SearchConfig {
  application -> Application

  indexDirectory : String              // /var/indexes/appname
  enableStats : Bool

  searchableEntities : {Entity}        // Entities with searchable properties
}

// Note: Searchable annotation is on Property.isSearchable

// =============================================================================
// SECTION 11: EMAIL
// =============================================================================
//
// email userWelcome(u : User) {
//   to(u.email)
//   from("noreply@example.com")
//   subject("Welcome!")
//   par { "Hello " output(u.name) }
// }

entity EmailTemplate {
  name : String                        // "userWelcome"

  application -> Application

  // Parameters
  parameters : {EmailParameter}

  // Headers
  toExpr : String                      // "u.email"
  fromExpr : String                    // "noreply@example.com"
  subjectExpr : String                 // "Welcome " + u.name

  // Body
  elements : {PageElement}             // Reuse page elements

  // Attachments
  attachments : {EmailAttachment}
}

entity EmailParameter {
  name : String
  type -> DataType
  emailTemplate -> EmailTemplate
}

entity EmailAttachment {
  fileExpr : String                    // Expression for File
  emailTemplate -> EmailTemplate
}

// =============================================================================
// SECTION 12: STYLING
// =============================================================================
//
// includeCSS("styles.css")
// <div class="myclass">

entity StyleSheet {
  path : String                        // "stylesheets/common.css"
  mediaType : String                   // "screen", "print"

  application -> Application
}

entity CSSClass {
  name : String                        // "header", "card"
  pageElement -> PageElement           // Where it's applied
}

// =============================================================================
// SECTION 13: NATIVE JAVA INTERFACE
// =============================================================================
//
// native class java.util.UUID as JavaUUID
// native class nativejava.MyUtils as Utils

entity NativeClass {
  javaClassName : String               // "java.util.UUID"
  alias : String                       // "JavaUUID"

  application -> Application

  // Exposed members
  properties : {NativeProperty}
  methods : {NativeMethod}
  constructors : {NativeConstructor}
}

entity NativeProperty {
  name : String
  type -> DataType
  isStatic : Bool
  nativeClass -> NativeClass
}

entity NativeMethod {
  name : String
  returnType -> DataType
  parameters : {NativeParameter}
  isStatic : Bool
  nativeClass -> NativeClass
}

entity NativeConstructor {
  parameters : {NativeParameter}
  nativeClass -> NativeClass
}

entity NativeParameter {
  name : String
  type -> DataType
  method -> NativeMethod
  constructor -> NativeConstructor
}

// =============================================================================
// SECTION 14: CONFIGURATION
// =============================================================================
//
// application.ini settings

entity AppConfiguration {
  application -> Application

  // Backend
  backend : String                     // "servlet"

  // Database
  dbType : String                      // "mysql", "h2", "h2mem", "jndi"
  dbServer : String                    // "localhost"
  dbName : String
  dbUser : String
  dbPassword : Secret
  dbMode : String                      // "create-drop", "update", "false"
  dbFile : String                      // For H2 file
  dbJndiPath : String                  // For JNDI

  // Email (SMTP)
  smtpHost : String
  smtpPort : Int
  smtpUser : String
  smtpPassword : Secret
  smtpProtocol : String                // "smtp", "smtps"
  smtpAuthenticate : Bool

  // Tomcat
  tomcatPath : String

  // Search
  indexDir : String                    // "/var/indexes"
  searchStats : Bool

  // Runtime
  sessionTimeout : Int                 // Minutes
  javacMem : Int                       // MB for compilation

  // Debugging
  debug : Bool
  verbose : Bool
}

// =============================================================================
// OUROBOROS CLOSURE VERIFICATION
// =============================================================================
//
// Can this metamodel describe itself?
//
// ✅ Application entity → models "application metamodel"
// ✅ Entity entity → models all entities above (Application, Entity, Property, etc.)
// ✅ Property entity → models all properties in all entities
// ✅ Relationship entity → models all relationships (inverse, references, collections)
// ✅ Page entity → models pages that display/edit metamodel data
// ✅ Template entity → models reusable UI components
// ✅ Function entity → models generator functions
// ✅ ValidationRule entity → models validation on metamodel entities
// ✅ AccessRule entity → models who can edit metamodel
//
// RESULT: Complete closure achieved ✅
//
// The metamodel can model itself at all levels:
// - Structure (entities, relationships)
// - Behavior (functions, validation)
// - UI (pages, templates, CRUD)
// - Security (access control)
// - Features (search, services, email)
//
// =============================================================================
// INCREMENTAL IMPLEMENTATION STRATEGY
// =============================================================================
//
// Phase 1: ✅ COMPLETE
//   - Application, Entity, Property, Relationship
//   - Basic code generation
//   - Structural convergence achieved (v1 ≈ v2)
//
// Phase 2: Behavioral (NEXT)
//   - DerivedProperty, ValidationRule
//   - EntityFunction, Predicate
//   - Store expressions as strings
//   - Generate validation and derived properties
//
// Phase 3: UI/Pages
//   - Page, Template, PageElement
//   - FormElement, ControlStructure
//   - Generate complete pages from data
//   - Include CRUD generation
//
// Phase 4: Access Control
//   - Principal, AccessRule
//   - Generate access control rules
//   - Model security constraints
//
// Phase 5: Advanced Features
//   - DataType (full type system)
//   - AjaxOperation, Placeholder
//   - Service, EmailTemplate
//   - SearchConfig, NativeClass
//   - Complete feature coverage
//
// Phase 6: Configuration
//   - AppConfiguration
//   - Generate application.ini
//   - Complete application specification
//
// Each phase must preserve Ouroboros closure!
//
// =============================================================================
// AUTOMATION RATIO PROJECTION
// =============================================================================
//
// Current (Phase 1 - Structural):
//   Input: 23 form entries (bootstrap)
//   Output: ~200 lines WebDSL + database + CRUD UI
//   Ratio: ~8.7 lines per entry
//
// Projected (Phase 6 - Complete):
//   Input: ~100-150 metamodel entries (full app spec)
//   Output: ~1000-2000 lines WebDSL + full app
//   Ratio: ~10-20 lines per entry
//
// Time saved:
//   Manual: 10-20 hours
//   Metamodel: 1-2 hours
//   Savings: 80-90%
//
// But undersells the value:
//   - Consistency guaranteed
//   - Change propagation automatic
//   - Multiple targets possible
//   - Documentation built-in
//   - Visual modeling possible
//   - LLM integration ready
//
// =============================================================================
// FORMALISM EXTRACTION vs FORMALISM MAPPING
// =============================================================================
//
// This metamodel is NOT about mapping external concepts to WebDSL.
// It's about EXTRACTING WebDSL's implicit formalism and making it explicit.
//
// WebDSL Formalism = WebDSL Implementation
//        ↑__________________|
//
// We're not translating from E/R diagrams.
// We're making WebDSL reflective - able to describe itself.
//
// This is the Ouroboros Principle in action.
//
// =============================================================================
// END OF COMPREHENSIVE METAMODEL DESIGN
// =============================================================================
